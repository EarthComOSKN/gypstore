type Address {
  id: ID!
  name: String!
  Address: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  customer: User!
  invoices(where: InvoiceWhereInput, orderBy: InvoiceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Invoice!]
  shipping(where: ShippingWhereInput, orderBy: ShippingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Shipping!]
}

type AddressConnection {
  pageInfo: PageInfo!
  edges: [AddressEdge]!
  aggregate: AggregateAddress!
}

input AddressCreateInput {
  id: ID
  name: String!
  Address: String!
  customer: UserCreateOneWithoutAddressesInput!
  invoices: InvoiceCreateManyWithoutAddressInput
  shipping: ShippingCreateManyWithoutAddressInput
}

input AddressCreateManyWithoutCustomerInput {
  create: [AddressCreateWithoutCustomerInput!]
  connect: [AddressWhereUniqueInput!]
}

input AddressCreateOneWithoutInvoicesInput {
  create: AddressCreateWithoutInvoicesInput
  connect: AddressWhereUniqueInput
}

input AddressCreateOneWithoutShippingInput {
  create: AddressCreateWithoutShippingInput
  connect: AddressWhereUniqueInput
}

input AddressCreateWithoutCustomerInput {
  id: ID
  name: String!
  Address: String!
  invoices: InvoiceCreateManyWithoutAddressInput
  shipping: ShippingCreateManyWithoutAddressInput
}

input AddressCreateWithoutInvoicesInput {
  id: ID
  name: String!
  Address: String!
  customer: UserCreateOneWithoutAddressesInput!
  shipping: ShippingCreateManyWithoutAddressInput
}

input AddressCreateWithoutShippingInput {
  id: ID
  name: String!
  Address: String!
  customer: UserCreateOneWithoutAddressesInput!
  invoices: InvoiceCreateManyWithoutAddressInput
}

type AddressEdge {
  node: Address!
  cursor: String!
}

enum AddressOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  Address_ASC
  Address_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AddressPreviousValues {
  id: ID!
  name: String!
  Address: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input AddressScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  Address: String
  Address_not: String
  Address_in: [String!]
  Address_not_in: [String!]
  Address_lt: String
  Address_lte: String
  Address_gt: String
  Address_gte: String
  Address_contains: String
  Address_not_contains: String
  Address_starts_with: String
  Address_not_starts_with: String
  Address_ends_with: String
  Address_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [AddressScalarWhereInput!]
  OR: [AddressScalarWhereInput!]
  NOT: [AddressScalarWhereInput!]
}

type AddressSubscriptionPayload {
  mutation: MutationType!
  node: Address
  updatedFields: [String!]
  previousValues: AddressPreviousValues
}

input AddressSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AddressWhereInput
  AND: [AddressSubscriptionWhereInput!]
  OR: [AddressSubscriptionWhereInput!]
  NOT: [AddressSubscriptionWhereInput!]
}

input AddressUpdateInput {
  name: String
  Address: String
  customer: UserUpdateOneRequiredWithoutAddressesInput
  invoices: InvoiceUpdateManyWithoutAddressInput
  shipping: ShippingUpdateManyWithoutAddressInput
}

input AddressUpdateManyDataInput {
  name: String
  Address: String
}

input AddressUpdateManyMutationInput {
  name: String
  Address: String
}

input AddressUpdateManyWithoutCustomerInput {
  create: [AddressCreateWithoutCustomerInput!]
  delete: [AddressWhereUniqueInput!]
  connect: [AddressWhereUniqueInput!]
  set: [AddressWhereUniqueInput!]
  disconnect: [AddressWhereUniqueInput!]
  update: [AddressUpdateWithWhereUniqueWithoutCustomerInput!]
  upsert: [AddressUpsertWithWhereUniqueWithoutCustomerInput!]
  deleteMany: [AddressScalarWhereInput!]
  updateMany: [AddressUpdateManyWithWhereNestedInput!]
}

input AddressUpdateManyWithWhereNestedInput {
  where: AddressScalarWhereInput!
  data: AddressUpdateManyDataInput!
}

input AddressUpdateOneRequiredWithoutShippingInput {
  create: AddressCreateWithoutShippingInput
  update: AddressUpdateWithoutShippingDataInput
  upsert: AddressUpsertWithoutShippingInput
  connect: AddressWhereUniqueInput
}

input AddressUpdateOneWithoutInvoicesInput {
  create: AddressCreateWithoutInvoicesInput
  update: AddressUpdateWithoutInvoicesDataInput
  upsert: AddressUpsertWithoutInvoicesInput
  delete: Boolean
  disconnect: Boolean
  connect: AddressWhereUniqueInput
}

input AddressUpdateWithoutCustomerDataInput {
  name: String
  Address: String
  invoices: InvoiceUpdateManyWithoutAddressInput
  shipping: ShippingUpdateManyWithoutAddressInput
}

input AddressUpdateWithoutInvoicesDataInput {
  name: String
  Address: String
  customer: UserUpdateOneRequiredWithoutAddressesInput
  shipping: ShippingUpdateManyWithoutAddressInput
}

input AddressUpdateWithoutShippingDataInput {
  name: String
  Address: String
  customer: UserUpdateOneRequiredWithoutAddressesInput
  invoices: InvoiceUpdateManyWithoutAddressInput
}

input AddressUpdateWithWhereUniqueWithoutCustomerInput {
  where: AddressWhereUniqueInput!
  data: AddressUpdateWithoutCustomerDataInput!
}

input AddressUpsertWithoutInvoicesInput {
  update: AddressUpdateWithoutInvoicesDataInput!
  create: AddressCreateWithoutInvoicesInput!
}

input AddressUpsertWithoutShippingInput {
  update: AddressUpdateWithoutShippingDataInput!
  create: AddressCreateWithoutShippingInput!
}

input AddressUpsertWithWhereUniqueWithoutCustomerInput {
  where: AddressWhereUniqueInput!
  update: AddressUpdateWithoutCustomerDataInput!
  create: AddressCreateWithoutCustomerInput!
}

input AddressWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  Address: String
  Address_not: String
  Address_in: [String!]
  Address_not_in: [String!]
  Address_lt: String
  Address_lte: String
  Address_gt: String
  Address_gte: String
  Address_contains: String
  Address_not_contains: String
  Address_starts_with: String
  Address_not_starts_with: String
  Address_ends_with: String
  Address_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  customer: UserWhereInput
  invoices_every: InvoiceWhereInput
  invoices_some: InvoiceWhereInput
  invoices_none: InvoiceWhereInput
  shipping_every: ShippingWhereInput
  shipping_some: ShippingWhereInput
  shipping_none: ShippingWhereInput
  AND: [AddressWhereInput!]
  OR: [AddressWhereInput!]
  NOT: [AddressWhereInput!]
}

input AddressWhereUniqueInput {
  id: ID
}

type AggregateAddress {
  count: Int!
}

type AggregateCategory {
  count: Int!
}

type AggregateImage {
  count: Int!
}

type AggregateInvoice {
  count: Int!
}

type AggregatePayment {
  count: Int!
}

type AggregateProductItem {
  count: Int!
}

type AggregateQuotation {
  count: Int!
}

type AggregateSaleman {
  count: Int!
}

type AggregateShipping {
  count: Int!
}

type AggregateShoppingCart {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Category {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  productItem(where: ProductItemWhereInput, orderBy: ProductItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductItem!]
  category: Category
}

type CategoryConnection {
  pageInfo: PageInfo!
  edges: [CategoryEdge]!
  aggregate: AggregateCategory!
}

input CategoryCreateInput {
  id: ID
  name: String!
  productItem: ProductItemCreateManyWithoutCategoryInput
  category: CategoryCreateOneInput
}

input CategoryCreateOneInput {
  create: CategoryCreateInput
  connect: CategoryWhereUniqueInput
}

input CategoryCreateOneWithoutProductItemInput {
  create: CategoryCreateWithoutProductItemInput
  connect: CategoryWhereUniqueInput
}

input CategoryCreateWithoutProductItemInput {
  id: ID
  name: String!
  category: CategoryCreateOneInput
}

type CategoryEdge {
  node: Category!
  cursor: String!
}

enum CategoryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CategoryPreviousValues {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CategorySubscriptionPayload {
  mutation: MutationType!
  node: Category
  updatedFields: [String!]
  previousValues: CategoryPreviousValues
}

input CategorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CategoryWhereInput
  AND: [CategorySubscriptionWhereInput!]
  OR: [CategorySubscriptionWhereInput!]
  NOT: [CategorySubscriptionWhereInput!]
}

input CategoryUpdateDataInput {
  name: String
  productItem: ProductItemUpdateManyWithoutCategoryInput
  category: CategoryUpdateOneInput
}

input CategoryUpdateInput {
  name: String
  productItem: ProductItemUpdateManyWithoutCategoryInput
  category: CategoryUpdateOneInput
}

input CategoryUpdateManyMutationInput {
  name: String
}

input CategoryUpdateOneInput {
  create: CategoryCreateInput
  update: CategoryUpdateDataInput
  upsert: CategoryUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: CategoryWhereUniqueInput
}

input CategoryUpdateOneRequiredWithoutProductItemInput {
  create: CategoryCreateWithoutProductItemInput
  update: CategoryUpdateWithoutProductItemDataInput
  upsert: CategoryUpsertWithoutProductItemInput
  connect: CategoryWhereUniqueInput
}

input CategoryUpdateWithoutProductItemDataInput {
  name: String
  category: CategoryUpdateOneInput
}

input CategoryUpsertNestedInput {
  update: CategoryUpdateDataInput!
  create: CategoryCreateInput!
}

input CategoryUpsertWithoutProductItemInput {
  update: CategoryUpdateWithoutProductItemDataInput!
  create: CategoryCreateWithoutProductItemInput!
}

input CategoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  productItem_every: ProductItemWhereInput
  productItem_some: ProductItemWhereInput
  productItem_none: ProductItemWhereInput
  category: CategoryWhereInput
  AND: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
}

input CategoryWhereUniqueInput {
  id: ID
}

scalar DateTime

type Image {
  id: ID!
  filename: String!
  description: String
}

type ImageConnection {
  pageInfo: PageInfo!
  edges: [ImageEdge]!
  aggregate: AggregateImage!
}

input ImageCreateInput {
  id: ID
  filename: String!
  description: String
}

input ImageCreateOneInput {
  create: ImageCreateInput
  connect: ImageWhereUniqueInput
}

type ImageEdge {
  node: Image!
  cursor: String!
}

enum ImageOrderByInput {
  id_ASC
  id_DESC
  filename_ASC
  filename_DESC
  description_ASC
  description_DESC
}

type ImagePreviousValues {
  id: ID!
  filename: String!
  description: String
}

type ImageSubscriptionPayload {
  mutation: MutationType!
  node: Image
  updatedFields: [String!]
  previousValues: ImagePreviousValues
}

input ImageSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ImageWhereInput
  AND: [ImageSubscriptionWhereInput!]
  OR: [ImageSubscriptionWhereInput!]
  NOT: [ImageSubscriptionWhereInput!]
}

input ImageUpdateDataInput {
  filename: String
  description: String
}

input ImageUpdateInput {
  filename: String
  description: String
}

input ImageUpdateManyMutationInput {
  filename: String
  description: String
}

input ImageUpdateOneRequiredInput {
  create: ImageCreateInput
  update: ImageUpdateDataInput
  upsert: ImageUpsertNestedInput
  connect: ImageWhereUniqueInput
}

input ImageUpsertNestedInput {
  update: ImageUpdateDataInput!
  create: ImageCreateInput!
}

input ImageWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  filename: String
  filename_not: String
  filename_in: [String!]
  filename_not_in: [String!]
  filename_lt: String
  filename_lte: String
  filename_gt: String
  filename_gte: String
  filename_contains: String
  filename_not_contains: String
  filename_starts_with: String
  filename_not_starts_with: String
  filename_ends_with: String
  filename_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  AND: [ImageWhereInput!]
  OR: [ImageWhereInput!]
  NOT: [ImageWhereInput!]
}

input ImageWhereUniqueInput {
  id: ID
}

type Invoice {
  id: ID!
  docId: String!
  creditTerm: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  user: User!
  quotation: Quotation!
  saleman: Saleman!
  address: Address
  payment: Payment
}

type InvoiceConnection {
  pageInfo: PageInfo!
  edges: [InvoiceEdge]!
  aggregate: AggregateInvoice!
}

input InvoiceCreateInput {
  id: ID
  docId: String!
  creditTerm: String!
  user: UserCreateOneInput!
  quotation: QuotationCreateOneInput!
  saleman: SalemanCreateOneWithoutInvoicesInput!
  address: AddressCreateOneWithoutInvoicesInput
  payment: PaymentCreateOneWithoutInvoiceInput
}

input InvoiceCreateManyWithoutAddressInput {
  create: [InvoiceCreateWithoutAddressInput!]
  connect: [InvoiceWhereUniqueInput!]
}

input InvoiceCreateManyWithoutSalemanInput {
  create: [InvoiceCreateWithoutSalemanInput!]
  connect: [InvoiceWhereUniqueInput!]
}

input InvoiceCreateOneInput {
  create: InvoiceCreateInput
  connect: InvoiceWhereUniqueInput
}

input InvoiceCreateOneWithoutPaymentInput {
  create: InvoiceCreateWithoutPaymentInput
  connect: InvoiceWhereUniqueInput
}

input InvoiceCreateWithoutAddressInput {
  id: ID
  docId: String!
  creditTerm: String!
  user: UserCreateOneInput!
  quotation: QuotationCreateOneInput!
  saleman: SalemanCreateOneWithoutInvoicesInput!
  payment: PaymentCreateOneWithoutInvoiceInput
}

input InvoiceCreateWithoutPaymentInput {
  id: ID
  docId: String!
  creditTerm: String!
  user: UserCreateOneInput!
  quotation: QuotationCreateOneInput!
  saleman: SalemanCreateOneWithoutInvoicesInput!
  address: AddressCreateOneWithoutInvoicesInput
}

input InvoiceCreateWithoutSalemanInput {
  id: ID
  docId: String!
  creditTerm: String!
  user: UserCreateOneInput!
  quotation: QuotationCreateOneInput!
  address: AddressCreateOneWithoutInvoicesInput
  payment: PaymentCreateOneWithoutInvoiceInput
}

type InvoiceEdge {
  node: Invoice!
  cursor: String!
}

enum InvoiceOrderByInput {
  id_ASC
  id_DESC
  docId_ASC
  docId_DESC
  creditTerm_ASC
  creditTerm_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type InvoicePreviousValues {
  id: ID!
  docId: String!
  creditTerm: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input InvoiceScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  docId: String
  docId_not: String
  docId_in: [String!]
  docId_not_in: [String!]
  docId_lt: String
  docId_lte: String
  docId_gt: String
  docId_gte: String
  docId_contains: String
  docId_not_contains: String
  docId_starts_with: String
  docId_not_starts_with: String
  docId_ends_with: String
  docId_not_ends_with: String
  creditTerm: String
  creditTerm_not: String
  creditTerm_in: [String!]
  creditTerm_not_in: [String!]
  creditTerm_lt: String
  creditTerm_lte: String
  creditTerm_gt: String
  creditTerm_gte: String
  creditTerm_contains: String
  creditTerm_not_contains: String
  creditTerm_starts_with: String
  creditTerm_not_starts_with: String
  creditTerm_ends_with: String
  creditTerm_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [InvoiceScalarWhereInput!]
  OR: [InvoiceScalarWhereInput!]
  NOT: [InvoiceScalarWhereInput!]
}

type InvoiceSubscriptionPayload {
  mutation: MutationType!
  node: Invoice
  updatedFields: [String!]
  previousValues: InvoicePreviousValues
}

input InvoiceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InvoiceWhereInput
  AND: [InvoiceSubscriptionWhereInput!]
  OR: [InvoiceSubscriptionWhereInput!]
  NOT: [InvoiceSubscriptionWhereInput!]
}

input InvoiceUpdateDataInput {
  docId: String
  creditTerm: String
  user: UserUpdateOneRequiredInput
  quotation: QuotationUpdateOneRequiredInput
  saleman: SalemanUpdateOneRequiredWithoutInvoicesInput
  address: AddressUpdateOneWithoutInvoicesInput
  payment: PaymentUpdateOneWithoutInvoiceInput
}

input InvoiceUpdateInput {
  docId: String
  creditTerm: String
  user: UserUpdateOneRequiredInput
  quotation: QuotationUpdateOneRequiredInput
  saleman: SalemanUpdateOneRequiredWithoutInvoicesInput
  address: AddressUpdateOneWithoutInvoicesInput
  payment: PaymentUpdateOneWithoutInvoiceInput
}

input InvoiceUpdateManyDataInput {
  docId: String
  creditTerm: String
}

input InvoiceUpdateManyMutationInput {
  docId: String
  creditTerm: String
}

input InvoiceUpdateManyWithoutAddressInput {
  create: [InvoiceCreateWithoutAddressInput!]
  delete: [InvoiceWhereUniqueInput!]
  connect: [InvoiceWhereUniqueInput!]
  set: [InvoiceWhereUniqueInput!]
  disconnect: [InvoiceWhereUniqueInput!]
  update: [InvoiceUpdateWithWhereUniqueWithoutAddressInput!]
  upsert: [InvoiceUpsertWithWhereUniqueWithoutAddressInput!]
  deleteMany: [InvoiceScalarWhereInput!]
  updateMany: [InvoiceUpdateManyWithWhereNestedInput!]
}

input InvoiceUpdateManyWithoutSalemanInput {
  create: [InvoiceCreateWithoutSalemanInput!]
  delete: [InvoiceWhereUniqueInput!]
  connect: [InvoiceWhereUniqueInput!]
  set: [InvoiceWhereUniqueInput!]
  disconnect: [InvoiceWhereUniqueInput!]
  update: [InvoiceUpdateWithWhereUniqueWithoutSalemanInput!]
  upsert: [InvoiceUpsertWithWhereUniqueWithoutSalemanInput!]
  deleteMany: [InvoiceScalarWhereInput!]
  updateMany: [InvoiceUpdateManyWithWhereNestedInput!]
}

input InvoiceUpdateManyWithWhereNestedInput {
  where: InvoiceScalarWhereInput!
  data: InvoiceUpdateManyDataInput!
}

input InvoiceUpdateOneRequiredInput {
  create: InvoiceCreateInput
  update: InvoiceUpdateDataInput
  upsert: InvoiceUpsertNestedInput
  connect: InvoiceWhereUniqueInput
}

input InvoiceUpdateOneWithoutPaymentInput {
  create: InvoiceCreateWithoutPaymentInput
  update: InvoiceUpdateWithoutPaymentDataInput
  upsert: InvoiceUpsertWithoutPaymentInput
  delete: Boolean
  disconnect: Boolean
  connect: InvoiceWhereUniqueInput
}

input InvoiceUpdateWithoutAddressDataInput {
  docId: String
  creditTerm: String
  user: UserUpdateOneRequiredInput
  quotation: QuotationUpdateOneRequiredInput
  saleman: SalemanUpdateOneRequiredWithoutInvoicesInput
  payment: PaymentUpdateOneWithoutInvoiceInput
}

input InvoiceUpdateWithoutPaymentDataInput {
  docId: String
  creditTerm: String
  user: UserUpdateOneRequiredInput
  quotation: QuotationUpdateOneRequiredInput
  saleman: SalemanUpdateOneRequiredWithoutInvoicesInput
  address: AddressUpdateOneWithoutInvoicesInput
}

input InvoiceUpdateWithoutSalemanDataInput {
  docId: String
  creditTerm: String
  user: UserUpdateOneRequiredInput
  quotation: QuotationUpdateOneRequiredInput
  address: AddressUpdateOneWithoutInvoicesInput
  payment: PaymentUpdateOneWithoutInvoiceInput
}

input InvoiceUpdateWithWhereUniqueWithoutAddressInput {
  where: InvoiceWhereUniqueInput!
  data: InvoiceUpdateWithoutAddressDataInput!
}

input InvoiceUpdateWithWhereUniqueWithoutSalemanInput {
  where: InvoiceWhereUniqueInput!
  data: InvoiceUpdateWithoutSalemanDataInput!
}

input InvoiceUpsertNestedInput {
  update: InvoiceUpdateDataInput!
  create: InvoiceCreateInput!
}

input InvoiceUpsertWithoutPaymentInput {
  update: InvoiceUpdateWithoutPaymentDataInput!
  create: InvoiceCreateWithoutPaymentInput!
}

input InvoiceUpsertWithWhereUniqueWithoutAddressInput {
  where: InvoiceWhereUniqueInput!
  update: InvoiceUpdateWithoutAddressDataInput!
  create: InvoiceCreateWithoutAddressInput!
}

input InvoiceUpsertWithWhereUniqueWithoutSalemanInput {
  where: InvoiceWhereUniqueInput!
  update: InvoiceUpdateWithoutSalemanDataInput!
  create: InvoiceCreateWithoutSalemanInput!
}

input InvoiceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  docId: String
  docId_not: String
  docId_in: [String!]
  docId_not_in: [String!]
  docId_lt: String
  docId_lte: String
  docId_gt: String
  docId_gte: String
  docId_contains: String
  docId_not_contains: String
  docId_starts_with: String
  docId_not_starts_with: String
  docId_ends_with: String
  docId_not_ends_with: String
  creditTerm: String
  creditTerm_not: String
  creditTerm_in: [String!]
  creditTerm_not_in: [String!]
  creditTerm_lt: String
  creditTerm_lte: String
  creditTerm_gt: String
  creditTerm_gte: String
  creditTerm_contains: String
  creditTerm_not_contains: String
  creditTerm_starts_with: String
  creditTerm_not_starts_with: String
  creditTerm_ends_with: String
  creditTerm_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  user: UserWhereInput
  quotation: QuotationWhereInput
  saleman: SalemanWhereInput
  address: AddressWhereInput
  payment: PaymentWhereInput
  AND: [InvoiceWhereInput!]
  OR: [InvoiceWhereInput!]
  NOT: [InvoiceWhereInput!]
}

input InvoiceWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createAddress(data: AddressCreateInput!): Address!
  updateAddress(data: AddressUpdateInput!, where: AddressWhereUniqueInput!): Address
  updateManyAddresses(data: AddressUpdateManyMutationInput!, where: AddressWhereInput): BatchPayload!
  upsertAddress(where: AddressWhereUniqueInput!, create: AddressCreateInput!, update: AddressUpdateInput!): Address!
  deleteAddress(where: AddressWhereUniqueInput!): Address
  deleteManyAddresses(where: AddressWhereInput): BatchPayload!
  createCategory(data: CategoryCreateInput!): Category!
  updateCategory(data: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category
  updateManyCategories(data: CategoryUpdateManyMutationInput!, where: CategoryWhereInput): BatchPayload!
  upsertCategory(where: CategoryWhereUniqueInput!, create: CategoryCreateInput!, update: CategoryUpdateInput!): Category!
  deleteCategory(where: CategoryWhereUniqueInput!): Category
  deleteManyCategories(where: CategoryWhereInput): BatchPayload!
  createImage(data: ImageCreateInput!): Image!
  updateImage(data: ImageUpdateInput!, where: ImageWhereUniqueInput!): Image
  updateManyImages(data: ImageUpdateManyMutationInput!, where: ImageWhereInput): BatchPayload!
  upsertImage(where: ImageWhereUniqueInput!, create: ImageCreateInput!, update: ImageUpdateInput!): Image!
  deleteImage(where: ImageWhereUniqueInput!): Image
  deleteManyImages(where: ImageWhereInput): BatchPayload!
  createInvoice(data: InvoiceCreateInput!): Invoice!
  updateInvoice(data: InvoiceUpdateInput!, where: InvoiceWhereUniqueInput!): Invoice
  updateManyInvoices(data: InvoiceUpdateManyMutationInput!, where: InvoiceWhereInput): BatchPayload!
  upsertInvoice(where: InvoiceWhereUniqueInput!, create: InvoiceCreateInput!, update: InvoiceUpdateInput!): Invoice!
  deleteInvoice(where: InvoiceWhereUniqueInput!): Invoice
  deleteManyInvoices(where: InvoiceWhereInput): BatchPayload!
  createPayment(data: PaymentCreateInput!): Payment!
  updatePayment(data: PaymentUpdateInput!, where: PaymentWhereUniqueInput!): Payment
  updateManyPayments(data: PaymentUpdateManyMutationInput!, where: PaymentWhereInput): BatchPayload!
  upsertPayment(where: PaymentWhereUniqueInput!, create: PaymentCreateInput!, update: PaymentUpdateInput!): Payment!
  deletePayment(where: PaymentWhereUniqueInput!): Payment
  deleteManyPayments(where: PaymentWhereInput): BatchPayload!
  createProductItem(data: ProductItemCreateInput!): ProductItem!
  updateProductItem(data: ProductItemUpdateInput!, where: ProductItemWhereUniqueInput!): ProductItem
  updateManyProductItems(data: ProductItemUpdateManyMutationInput!, where: ProductItemWhereInput): BatchPayload!
  upsertProductItem(where: ProductItemWhereUniqueInput!, create: ProductItemCreateInput!, update: ProductItemUpdateInput!): ProductItem!
  deleteProductItem(where: ProductItemWhereUniqueInput!): ProductItem
  deleteManyProductItems(where: ProductItemWhereInput): BatchPayload!
  createQuotation(data: QuotationCreateInput!): Quotation!
  updateQuotation(data: QuotationUpdateInput!, where: QuotationWhereUniqueInput!): Quotation
  updateManyQuotations(data: QuotationUpdateManyMutationInput!, where: QuotationWhereInput): BatchPayload!
  upsertQuotation(where: QuotationWhereUniqueInput!, create: QuotationCreateInput!, update: QuotationUpdateInput!): Quotation!
  deleteQuotation(where: QuotationWhereUniqueInput!): Quotation
  deleteManyQuotations(where: QuotationWhereInput): BatchPayload!
  createSaleman(data: SalemanCreateInput!): Saleman!
  updateSaleman(data: SalemanUpdateInput!, where: SalemanWhereUniqueInput!): Saleman
  upsertSaleman(where: SalemanWhereUniqueInput!, create: SalemanCreateInput!, update: SalemanUpdateInput!): Saleman!
  deleteSaleman(where: SalemanWhereUniqueInput!): Saleman
  deleteManySalemen(where: SalemanWhereInput): BatchPayload!
  createShipping(data: ShippingCreateInput!): Shipping!
  updateShipping(data: ShippingUpdateInput!, where: ShippingWhereUniqueInput!): Shipping
  updateManyShippings(data: ShippingUpdateManyMutationInput!, where: ShippingWhereInput): BatchPayload!
  upsertShipping(where: ShippingWhereUniqueInput!, create: ShippingCreateInput!, update: ShippingUpdateInput!): Shipping!
  deleteShipping(where: ShippingWhereUniqueInput!): Shipping
  deleteManyShippings(where: ShippingWhereInput): BatchPayload!
  createShoppingCart(data: ShoppingCartCreateInput!): ShoppingCart!
  updateShoppingCart(data: ShoppingCartUpdateInput!, where: ShoppingCartWhereUniqueInput!): ShoppingCart
  updateManyShoppingCarts(data: ShoppingCartUpdateManyMutationInput!, where: ShoppingCartWhereInput): BatchPayload!
  upsertShoppingCart(where: ShoppingCartWhereUniqueInput!, create: ShoppingCartCreateInput!, update: ShoppingCartUpdateInput!): ShoppingCart!
  deleteShoppingCart(where: ShoppingCartWhereUniqueInput!): ShoppingCart
  deleteManyShoppingCarts(where: ShoppingCartWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Payment {
  id: ID!
  docId: String!
  amount: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  customer: User!
  saleman: Saleman!
  quotation: Quotation!
  Invoice: Invoice
}

type PaymentConnection {
  pageInfo: PageInfo!
  edges: [PaymentEdge]!
  aggregate: AggregatePayment!
}

input PaymentCreateInput {
  id: ID
  docId: String!
  amount: String!
  customer: UserCreateOneWithoutPaymentsInput!
  saleman: SalemanCreateOneWithoutPaymentsInput!
  quotation: QuotationCreateOneWithoutPaymentInput!
  Invoice: InvoiceCreateOneWithoutPaymentInput
}

input PaymentCreateManyWithoutCustomerInput {
  create: [PaymentCreateWithoutCustomerInput!]
  connect: [PaymentWhereUniqueInput!]
}

input PaymentCreateManyWithoutSalemanInput {
  create: [PaymentCreateWithoutSalemanInput!]
  connect: [PaymentWhereUniqueInput!]
}

input PaymentCreateOneWithoutInvoiceInput {
  create: PaymentCreateWithoutInvoiceInput
  connect: PaymentWhereUniqueInput
}

input PaymentCreateOneWithoutQuotationInput {
  create: PaymentCreateWithoutQuotationInput
  connect: PaymentWhereUniqueInput
}

input PaymentCreateWithoutCustomerInput {
  id: ID
  docId: String!
  amount: String!
  saleman: SalemanCreateOneWithoutPaymentsInput!
  quotation: QuotationCreateOneWithoutPaymentInput!
  Invoice: InvoiceCreateOneWithoutPaymentInput
}

input PaymentCreateWithoutInvoiceInput {
  id: ID
  docId: String!
  amount: String!
  customer: UserCreateOneWithoutPaymentsInput!
  saleman: SalemanCreateOneWithoutPaymentsInput!
  quotation: QuotationCreateOneWithoutPaymentInput!
}

input PaymentCreateWithoutQuotationInput {
  id: ID
  docId: String!
  amount: String!
  customer: UserCreateOneWithoutPaymentsInput!
  saleman: SalemanCreateOneWithoutPaymentsInput!
  Invoice: InvoiceCreateOneWithoutPaymentInput
}

input PaymentCreateWithoutSalemanInput {
  id: ID
  docId: String!
  amount: String!
  customer: UserCreateOneWithoutPaymentsInput!
  quotation: QuotationCreateOneWithoutPaymentInput!
  Invoice: InvoiceCreateOneWithoutPaymentInput
}

type PaymentEdge {
  node: Payment!
  cursor: String!
}

enum PaymentOrderByInput {
  id_ASC
  id_DESC
  docId_ASC
  docId_DESC
  amount_ASC
  amount_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PaymentPreviousValues {
  id: ID!
  docId: String!
  amount: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input PaymentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  docId: String
  docId_not: String
  docId_in: [String!]
  docId_not_in: [String!]
  docId_lt: String
  docId_lte: String
  docId_gt: String
  docId_gte: String
  docId_contains: String
  docId_not_contains: String
  docId_starts_with: String
  docId_not_starts_with: String
  docId_ends_with: String
  docId_not_ends_with: String
  amount: String
  amount_not: String
  amount_in: [String!]
  amount_not_in: [String!]
  amount_lt: String
  amount_lte: String
  amount_gt: String
  amount_gte: String
  amount_contains: String
  amount_not_contains: String
  amount_starts_with: String
  amount_not_starts_with: String
  amount_ends_with: String
  amount_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PaymentScalarWhereInput!]
  OR: [PaymentScalarWhereInput!]
  NOT: [PaymentScalarWhereInput!]
}

type PaymentSubscriptionPayload {
  mutation: MutationType!
  node: Payment
  updatedFields: [String!]
  previousValues: PaymentPreviousValues
}

input PaymentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PaymentWhereInput
  AND: [PaymentSubscriptionWhereInput!]
  OR: [PaymentSubscriptionWhereInput!]
  NOT: [PaymentSubscriptionWhereInput!]
}

input PaymentUpdateInput {
  docId: String
  amount: String
  customer: UserUpdateOneRequiredWithoutPaymentsInput
  saleman: SalemanUpdateOneRequiredWithoutPaymentsInput
  quotation: QuotationUpdateOneRequiredWithoutPaymentInput
  Invoice: InvoiceUpdateOneWithoutPaymentInput
}

input PaymentUpdateManyDataInput {
  docId: String
  amount: String
}

input PaymentUpdateManyMutationInput {
  docId: String
  amount: String
}

input PaymentUpdateManyWithoutCustomerInput {
  create: [PaymentCreateWithoutCustomerInput!]
  delete: [PaymentWhereUniqueInput!]
  connect: [PaymentWhereUniqueInput!]
  set: [PaymentWhereUniqueInput!]
  disconnect: [PaymentWhereUniqueInput!]
  update: [PaymentUpdateWithWhereUniqueWithoutCustomerInput!]
  upsert: [PaymentUpsertWithWhereUniqueWithoutCustomerInput!]
  deleteMany: [PaymentScalarWhereInput!]
  updateMany: [PaymentUpdateManyWithWhereNestedInput!]
}

input PaymentUpdateManyWithoutSalemanInput {
  create: [PaymentCreateWithoutSalemanInput!]
  delete: [PaymentWhereUniqueInput!]
  connect: [PaymentWhereUniqueInput!]
  set: [PaymentWhereUniqueInput!]
  disconnect: [PaymentWhereUniqueInput!]
  update: [PaymentUpdateWithWhereUniqueWithoutSalemanInput!]
  upsert: [PaymentUpsertWithWhereUniqueWithoutSalemanInput!]
  deleteMany: [PaymentScalarWhereInput!]
  updateMany: [PaymentUpdateManyWithWhereNestedInput!]
}

input PaymentUpdateManyWithWhereNestedInput {
  where: PaymentScalarWhereInput!
  data: PaymentUpdateManyDataInput!
}

input PaymentUpdateOneWithoutInvoiceInput {
  create: PaymentCreateWithoutInvoiceInput
  update: PaymentUpdateWithoutInvoiceDataInput
  upsert: PaymentUpsertWithoutInvoiceInput
  delete: Boolean
  disconnect: Boolean
  connect: PaymentWhereUniqueInput
}

input PaymentUpdateOneWithoutQuotationInput {
  create: PaymentCreateWithoutQuotationInput
  update: PaymentUpdateWithoutQuotationDataInput
  upsert: PaymentUpsertWithoutQuotationInput
  delete: Boolean
  disconnect: Boolean
  connect: PaymentWhereUniqueInput
}

input PaymentUpdateWithoutCustomerDataInput {
  docId: String
  amount: String
  saleman: SalemanUpdateOneRequiredWithoutPaymentsInput
  quotation: QuotationUpdateOneRequiredWithoutPaymentInput
  Invoice: InvoiceUpdateOneWithoutPaymentInput
}

input PaymentUpdateWithoutInvoiceDataInput {
  docId: String
  amount: String
  customer: UserUpdateOneRequiredWithoutPaymentsInput
  saleman: SalemanUpdateOneRequiredWithoutPaymentsInput
  quotation: QuotationUpdateOneRequiredWithoutPaymentInput
}

input PaymentUpdateWithoutQuotationDataInput {
  docId: String
  amount: String
  customer: UserUpdateOneRequiredWithoutPaymentsInput
  saleman: SalemanUpdateOneRequiredWithoutPaymentsInput
  Invoice: InvoiceUpdateOneWithoutPaymentInput
}

input PaymentUpdateWithoutSalemanDataInput {
  docId: String
  amount: String
  customer: UserUpdateOneRequiredWithoutPaymentsInput
  quotation: QuotationUpdateOneRequiredWithoutPaymentInput
  Invoice: InvoiceUpdateOneWithoutPaymentInput
}

input PaymentUpdateWithWhereUniqueWithoutCustomerInput {
  where: PaymentWhereUniqueInput!
  data: PaymentUpdateWithoutCustomerDataInput!
}

input PaymentUpdateWithWhereUniqueWithoutSalemanInput {
  where: PaymentWhereUniqueInput!
  data: PaymentUpdateWithoutSalemanDataInput!
}

input PaymentUpsertWithoutInvoiceInput {
  update: PaymentUpdateWithoutInvoiceDataInput!
  create: PaymentCreateWithoutInvoiceInput!
}

input PaymentUpsertWithoutQuotationInput {
  update: PaymentUpdateWithoutQuotationDataInput!
  create: PaymentCreateWithoutQuotationInput!
}

input PaymentUpsertWithWhereUniqueWithoutCustomerInput {
  where: PaymentWhereUniqueInput!
  update: PaymentUpdateWithoutCustomerDataInput!
  create: PaymentCreateWithoutCustomerInput!
}

input PaymentUpsertWithWhereUniqueWithoutSalemanInput {
  where: PaymentWhereUniqueInput!
  update: PaymentUpdateWithoutSalemanDataInput!
  create: PaymentCreateWithoutSalemanInput!
}

input PaymentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  docId: String
  docId_not: String
  docId_in: [String!]
  docId_not_in: [String!]
  docId_lt: String
  docId_lte: String
  docId_gt: String
  docId_gte: String
  docId_contains: String
  docId_not_contains: String
  docId_starts_with: String
  docId_not_starts_with: String
  docId_ends_with: String
  docId_not_ends_with: String
  amount: String
  amount_not: String
  amount_in: [String!]
  amount_not_in: [String!]
  amount_lt: String
  amount_lte: String
  amount_gt: String
  amount_gte: String
  amount_contains: String
  amount_not_contains: String
  amount_starts_with: String
  amount_not_starts_with: String
  amount_ends_with: String
  amount_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  customer: UserWhereInput
  saleman: SalemanWhereInput
  quotation: QuotationWhereInput
  Invoice: InvoiceWhereInput
  AND: [PaymentWhereInput!]
  OR: [PaymentWhereInput!]
  NOT: [PaymentWhereInput!]
}

input PaymentWhereUniqueInput {
  id: ID
}

type ProductItem {
  id: ID!
  name: String!
  price: String!
  salePrice: String!
  brand: String!
  unitType: String!
  description: String
  MenuDetail: String!
  TermDetail: String!
  amount: Int!
  isPublished: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  category: Category!
  shoppingCart: ShoppingCart
  quotation: Quotation
  image: Image!
  relatedProduct(where: ProductItemWhereInput, orderBy: ProductItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductItem!]
}

type ProductItemConnection {
  pageInfo: PageInfo!
  edges: [ProductItemEdge]!
  aggregate: AggregateProductItem!
}

input ProductItemCreateInput {
  id: ID
  name: String!
  price: String!
  salePrice: String!
  brand: String!
  unitType: String!
  description: String
  MenuDetail: String!
  TermDetail: String!
  amount: Int!
  isPublished: Boolean
  category: CategoryCreateOneWithoutProductItemInput!
  shoppingCart: ShoppingCartCreateOneWithoutProductItemsInput
  quotation: QuotationCreateOneWithoutProductItemsInput
  image: ImageCreateOneInput!
  relatedProduct: ProductItemCreateManyInput
}

input ProductItemCreateManyInput {
  create: [ProductItemCreateInput!]
  connect: [ProductItemWhereUniqueInput!]
}

input ProductItemCreateManyWithoutCategoryInput {
  create: [ProductItemCreateWithoutCategoryInput!]
  connect: [ProductItemWhereUniqueInput!]
}

input ProductItemCreateManyWithoutQuotationInput {
  create: [ProductItemCreateWithoutQuotationInput!]
  connect: [ProductItemWhereUniqueInput!]
}

input ProductItemCreateManyWithoutShoppingCartInput {
  create: [ProductItemCreateWithoutShoppingCartInput!]
  connect: [ProductItemWhereUniqueInput!]
}

input ProductItemCreateWithoutCategoryInput {
  id: ID
  name: String!
  price: String!
  salePrice: String!
  brand: String!
  unitType: String!
  description: String
  MenuDetail: String!
  TermDetail: String!
  amount: Int!
  isPublished: Boolean
  shoppingCart: ShoppingCartCreateOneWithoutProductItemsInput
  quotation: QuotationCreateOneWithoutProductItemsInput
  image: ImageCreateOneInput!
  relatedProduct: ProductItemCreateManyInput
}

input ProductItemCreateWithoutQuotationInput {
  id: ID
  name: String!
  price: String!
  salePrice: String!
  brand: String!
  unitType: String!
  description: String
  MenuDetail: String!
  TermDetail: String!
  amount: Int!
  isPublished: Boolean
  category: CategoryCreateOneWithoutProductItemInput!
  shoppingCart: ShoppingCartCreateOneWithoutProductItemsInput
  image: ImageCreateOneInput!
  relatedProduct: ProductItemCreateManyInput
}

input ProductItemCreateWithoutShoppingCartInput {
  id: ID
  name: String!
  price: String!
  salePrice: String!
  brand: String!
  unitType: String!
  description: String
  MenuDetail: String!
  TermDetail: String!
  amount: Int!
  isPublished: Boolean
  category: CategoryCreateOneWithoutProductItemInput!
  quotation: QuotationCreateOneWithoutProductItemsInput
  image: ImageCreateOneInput!
  relatedProduct: ProductItemCreateManyInput
}

type ProductItemEdge {
  node: ProductItem!
  cursor: String!
}

enum ProductItemOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  price_ASC
  price_DESC
  salePrice_ASC
  salePrice_DESC
  brand_ASC
  brand_DESC
  unitType_ASC
  unitType_DESC
  description_ASC
  description_DESC
  MenuDetail_ASC
  MenuDetail_DESC
  TermDetail_ASC
  TermDetail_DESC
  amount_ASC
  amount_DESC
  isPublished_ASC
  isPublished_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ProductItemPreviousValues {
  id: ID!
  name: String!
  price: String!
  salePrice: String!
  brand: String!
  unitType: String!
  description: String
  MenuDetail: String!
  TermDetail: String!
  amount: Int!
  isPublished: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ProductItemScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  price: String
  price_not: String
  price_in: [String!]
  price_not_in: [String!]
  price_lt: String
  price_lte: String
  price_gt: String
  price_gte: String
  price_contains: String
  price_not_contains: String
  price_starts_with: String
  price_not_starts_with: String
  price_ends_with: String
  price_not_ends_with: String
  salePrice: String
  salePrice_not: String
  salePrice_in: [String!]
  salePrice_not_in: [String!]
  salePrice_lt: String
  salePrice_lte: String
  salePrice_gt: String
  salePrice_gte: String
  salePrice_contains: String
  salePrice_not_contains: String
  salePrice_starts_with: String
  salePrice_not_starts_with: String
  salePrice_ends_with: String
  salePrice_not_ends_with: String
  brand: String
  brand_not: String
  brand_in: [String!]
  brand_not_in: [String!]
  brand_lt: String
  brand_lte: String
  brand_gt: String
  brand_gte: String
  brand_contains: String
  brand_not_contains: String
  brand_starts_with: String
  brand_not_starts_with: String
  brand_ends_with: String
  brand_not_ends_with: String
  unitType: String
  unitType_not: String
  unitType_in: [String!]
  unitType_not_in: [String!]
  unitType_lt: String
  unitType_lte: String
  unitType_gt: String
  unitType_gte: String
  unitType_contains: String
  unitType_not_contains: String
  unitType_starts_with: String
  unitType_not_starts_with: String
  unitType_ends_with: String
  unitType_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  MenuDetail: String
  MenuDetail_not: String
  MenuDetail_in: [String!]
  MenuDetail_not_in: [String!]
  MenuDetail_lt: String
  MenuDetail_lte: String
  MenuDetail_gt: String
  MenuDetail_gte: String
  MenuDetail_contains: String
  MenuDetail_not_contains: String
  MenuDetail_starts_with: String
  MenuDetail_not_starts_with: String
  MenuDetail_ends_with: String
  MenuDetail_not_ends_with: String
  TermDetail: String
  TermDetail_not: String
  TermDetail_in: [String!]
  TermDetail_not_in: [String!]
  TermDetail_lt: String
  TermDetail_lte: String
  TermDetail_gt: String
  TermDetail_gte: String
  TermDetail_contains: String
  TermDetail_not_contains: String
  TermDetail_starts_with: String
  TermDetail_not_starts_with: String
  TermDetail_ends_with: String
  TermDetail_not_ends_with: String
  amount: Int
  amount_not: Int
  amount_in: [Int!]
  amount_not_in: [Int!]
  amount_lt: Int
  amount_lte: Int
  amount_gt: Int
  amount_gte: Int
  isPublished: Boolean
  isPublished_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ProductItemScalarWhereInput!]
  OR: [ProductItemScalarWhereInput!]
  NOT: [ProductItemScalarWhereInput!]
}

type ProductItemSubscriptionPayload {
  mutation: MutationType!
  node: ProductItem
  updatedFields: [String!]
  previousValues: ProductItemPreviousValues
}

input ProductItemSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductItemWhereInput
  AND: [ProductItemSubscriptionWhereInput!]
  OR: [ProductItemSubscriptionWhereInput!]
  NOT: [ProductItemSubscriptionWhereInput!]
}

input ProductItemUpdateDataInput {
  name: String
  price: String
  salePrice: String
  brand: String
  unitType: String
  description: String
  MenuDetail: String
  TermDetail: String
  amount: Int
  isPublished: Boolean
  category: CategoryUpdateOneRequiredWithoutProductItemInput
  shoppingCart: ShoppingCartUpdateOneWithoutProductItemsInput
  quotation: QuotationUpdateOneWithoutProductItemsInput
  image: ImageUpdateOneRequiredInput
  relatedProduct: ProductItemUpdateManyInput
}

input ProductItemUpdateInput {
  name: String
  price: String
  salePrice: String
  brand: String
  unitType: String
  description: String
  MenuDetail: String
  TermDetail: String
  amount: Int
  isPublished: Boolean
  category: CategoryUpdateOneRequiredWithoutProductItemInput
  shoppingCart: ShoppingCartUpdateOneWithoutProductItemsInput
  quotation: QuotationUpdateOneWithoutProductItemsInput
  image: ImageUpdateOneRequiredInput
  relatedProduct: ProductItemUpdateManyInput
}

input ProductItemUpdateManyDataInput {
  name: String
  price: String
  salePrice: String
  brand: String
  unitType: String
  description: String
  MenuDetail: String
  TermDetail: String
  amount: Int
  isPublished: Boolean
}

input ProductItemUpdateManyInput {
  create: [ProductItemCreateInput!]
  update: [ProductItemUpdateWithWhereUniqueNestedInput!]
  upsert: [ProductItemUpsertWithWhereUniqueNestedInput!]
  delete: [ProductItemWhereUniqueInput!]
  connect: [ProductItemWhereUniqueInput!]
  set: [ProductItemWhereUniqueInput!]
  disconnect: [ProductItemWhereUniqueInput!]
  deleteMany: [ProductItemScalarWhereInput!]
  updateMany: [ProductItemUpdateManyWithWhereNestedInput!]
}

input ProductItemUpdateManyMutationInput {
  name: String
  price: String
  salePrice: String
  brand: String
  unitType: String
  description: String
  MenuDetail: String
  TermDetail: String
  amount: Int
  isPublished: Boolean
}

input ProductItemUpdateManyWithoutCategoryInput {
  create: [ProductItemCreateWithoutCategoryInput!]
  delete: [ProductItemWhereUniqueInput!]
  connect: [ProductItemWhereUniqueInput!]
  set: [ProductItemWhereUniqueInput!]
  disconnect: [ProductItemWhereUniqueInput!]
  update: [ProductItemUpdateWithWhereUniqueWithoutCategoryInput!]
  upsert: [ProductItemUpsertWithWhereUniqueWithoutCategoryInput!]
  deleteMany: [ProductItemScalarWhereInput!]
  updateMany: [ProductItemUpdateManyWithWhereNestedInput!]
}

input ProductItemUpdateManyWithoutQuotationInput {
  create: [ProductItemCreateWithoutQuotationInput!]
  delete: [ProductItemWhereUniqueInput!]
  connect: [ProductItemWhereUniqueInput!]
  set: [ProductItemWhereUniqueInput!]
  disconnect: [ProductItemWhereUniqueInput!]
  update: [ProductItemUpdateWithWhereUniqueWithoutQuotationInput!]
  upsert: [ProductItemUpsertWithWhereUniqueWithoutQuotationInput!]
  deleteMany: [ProductItemScalarWhereInput!]
  updateMany: [ProductItemUpdateManyWithWhereNestedInput!]
}

input ProductItemUpdateManyWithoutShoppingCartInput {
  create: [ProductItemCreateWithoutShoppingCartInput!]
  delete: [ProductItemWhereUniqueInput!]
  connect: [ProductItemWhereUniqueInput!]
  set: [ProductItemWhereUniqueInput!]
  disconnect: [ProductItemWhereUniqueInput!]
  update: [ProductItemUpdateWithWhereUniqueWithoutShoppingCartInput!]
  upsert: [ProductItemUpsertWithWhereUniqueWithoutShoppingCartInput!]
  deleteMany: [ProductItemScalarWhereInput!]
  updateMany: [ProductItemUpdateManyWithWhereNestedInput!]
}

input ProductItemUpdateManyWithWhereNestedInput {
  where: ProductItemScalarWhereInput!
  data: ProductItemUpdateManyDataInput!
}

input ProductItemUpdateWithoutCategoryDataInput {
  name: String
  price: String
  salePrice: String
  brand: String
  unitType: String
  description: String
  MenuDetail: String
  TermDetail: String
  amount: Int
  isPublished: Boolean
  shoppingCart: ShoppingCartUpdateOneWithoutProductItemsInput
  quotation: QuotationUpdateOneWithoutProductItemsInput
  image: ImageUpdateOneRequiredInput
  relatedProduct: ProductItemUpdateManyInput
}

input ProductItemUpdateWithoutQuotationDataInput {
  name: String
  price: String
  salePrice: String
  brand: String
  unitType: String
  description: String
  MenuDetail: String
  TermDetail: String
  amount: Int
  isPublished: Boolean
  category: CategoryUpdateOneRequiredWithoutProductItemInput
  shoppingCart: ShoppingCartUpdateOneWithoutProductItemsInput
  image: ImageUpdateOneRequiredInput
  relatedProduct: ProductItemUpdateManyInput
}

input ProductItemUpdateWithoutShoppingCartDataInput {
  name: String
  price: String
  salePrice: String
  brand: String
  unitType: String
  description: String
  MenuDetail: String
  TermDetail: String
  amount: Int
  isPublished: Boolean
  category: CategoryUpdateOneRequiredWithoutProductItemInput
  quotation: QuotationUpdateOneWithoutProductItemsInput
  image: ImageUpdateOneRequiredInput
  relatedProduct: ProductItemUpdateManyInput
}

input ProductItemUpdateWithWhereUniqueNestedInput {
  where: ProductItemWhereUniqueInput!
  data: ProductItemUpdateDataInput!
}

input ProductItemUpdateWithWhereUniqueWithoutCategoryInput {
  where: ProductItemWhereUniqueInput!
  data: ProductItemUpdateWithoutCategoryDataInput!
}

input ProductItemUpdateWithWhereUniqueWithoutQuotationInput {
  where: ProductItemWhereUniqueInput!
  data: ProductItemUpdateWithoutQuotationDataInput!
}

input ProductItemUpdateWithWhereUniqueWithoutShoppingCartInput {
  where: ProductItemWhereUniqueInput!
  data: ProductItemUpdateWithoutShoppingCartDataInput!
}

input ProductItemUpsertWithWhereUniqueNestedInput {
  where: ProductItemWhereUniqueInput!
  update: ProductItemUpdateDataInput!
  create: ProductItemCreateInput!
}

input ProductItemUpsertWithWhereUniqueWithoutCategoryInput {
  where: ProductItemWhereUniqueInput!
  update: ProductItemUpdateWithoutCategoryDataInput!
  create: ProductItemCreateWithoutCategoryInput!
}

input ProductItemUpsertWithWhereUniqueWithoutQuotationInput {
  where: ProductItemWhereUniqueInput!
  update: ProductItemUpdateWithoutQuotationDataInput!
  create: ProductItemCreateWithoutQuotationInput!
}

input ProductItemUpsertWithWhereUniqueWithoutShoppingCartInput {
  where: ProductItemWhereUniqueInput!
  update: ProductItemUpdateWithoutShoppingCartDataInput!
  create: ProductItemCreateWithoutShoppingCartInput!
}

input ProductItemWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  price: String
  price_not: String
  price_in: [String!]
  price_not_in: [String!]
  price_lt: String
  price_lte: String
  price_gt: String
  price_gte: String
  price_contains: String
  price_not_contains: String
  price_starts_with: String
  price_not_starts_with: String
  price_ends_with: String
  price_not_ends_with: String
  salePrice: String
  salePrice_not: String
  salePrice_in: [String!]
  salePrice_not_in: [String!]
  salePrice_lt: String
  salePrice_lte: String
  salePrice_gt: String
  salePrice_gte: String
  salePrice_contains: String
  salePrice_not_contains: String
  salePrice_starts_with: String
  salePrice_not_starts_with: String
  salePrice_ends_with: String
  salePrice_not_ends_with: String
  brand: String
  brand_not: String
  brand_in: [String!]
  brand_not_in: [String!]
  brand_lt: String
  brand_lte: String
  brand_gt: String
  brand_gte: String
  brand_contains: String
  brand_not_contains: String
  brand_starts_with: String
  brand_not_starts_with: String
  brand_ends_with: String
  brand_not_ends_with: String
  unitType: String
  unitType_not: String
  unitType_in: [String!]
  unitType_not_in: [String!]
  unitType_lt: String
  unitType_lte: String
  unitType_gt: String
  unitType_gte: String
  unitType_contains: String
  unitType_not_contains: String
  unitType_starts_with: String
  unitType_not_starts_with: String
  unitType_ends_with: String
  unitType_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  MenuDetail: String
  MenuDetail_not: String
  MenuDetail_in: [String!]
  MenuDetail_not_in: [String!]
  MenuDetail_lt: String
  MenuDetail_lte: String
  MenuDetail_gt: String
  MenuDetail_gte: String
  MenuDetail_contains: String
  MenuDetail_not_contains: String
  MenuDetail_starts_with: String
  MenuDetail_not_starts_with: String
  MenuDetail_ends_with: String
  MenuDetail_not_ends_with: String
  TermDetail: String
  TermDetail_not: String
  TermDetail_in: [String!]
  TermDetail_not_in: [String!]
  TermDetail_lt: String
  TermDetail_lte: String
  TermDetail_gt: String
  TermDetail_gte: String
  TermDetail_contains: String
  TermDetail_not_contains: String
  TermDetail_starts_with: String
  TermDetail_not_starts_with: String
  TermDetail_ends_with: String
  TermDetail_not_ends_with: String
  amount: Int
  amount_not: Int
  amount_in: [Int!]
  amount_not_in: [Int!]
  amount_lt: Int
  amount_lte: Int
  amount_gt: Int
  amount_gte: Int
  isPublished: Boolean
  isPublished_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  category: CategoryWhereInput
  shoppingCart: ShoppingCartWhereInput
  quotation: QuotationWhereInput
  image: ImageWhereInput
  relatedProduct_every: ProductItemWhereInput
  relatedProduct_some: ProductItemWhereInput
  relatedProduct_none: ProductItemWhereInput
  AND: [ProductItemWhereInput!]
  OR: [ProductItemWhereInput!]
  NOT: [ProductItemWhereInput!]
}

input ProductItemWhereUniqueInput {
  id: ID
}

type Query {
  address(where: AddressWhereUniqueInput!): Address
  addresses(where: AddressWhereInput, orderBy: AddressOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Address]!
  addressesConnection(where: AddressWhereInput, orderBy: AddressOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AddressConnection!
  category(where: CategoryWhereUniqueInput!): Category
  categories(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Category]!
  categoriesConnection(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CategoryConnection!
  image(where: ImageWhereUniqueInput!): Image
  images(where: ImageWhereInput, orderBy: ImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Image]!
  imagesConnection(where: ImageWhereInput, orderBy: ImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ImageConnection!
  invoice(where: InvoiceWhereUniqueInput!): Invoice
  invoices(where: InvoiceWhereInput, orderBy: InvoiceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Invoice]!
  invoicesConnection(where: InvoiceWhereInput, orderBy: InvoiceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InvoiceConnection!
  payment(where: PaymentWhereUniqueInput!): Payment
  payments(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Payment]!
  paymentsConnection(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PaymentConnection!
  productItem(where: ProductItemWhereUniqueInput!): ProductItem
  productItems(where: ProductItemWhereInput, orderBy: ProductItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductItem]!
  productItemsConnection(where: ProductItemWhereInput, orderBy: ProductItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductItemConnection!
  quotation(where: QuotationWhereUniqueInput!): Quotation
  quotations(where: QuotationWhereInput, orderBy: QuotationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Quotation]!
  quotationsConnection(where: QuotationWhereInput, orderBy: QuotationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): QuotationConnection!
  saleman(where: SalemanWhereUniqueInput!): Saleman
  salemen(where: SalemanWhereInput, orderBy: SalemanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Saleman]!
  salemenConnection(where: SalemanWhereInput, orderBy: SalemanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SalemanConnection!
  shipping(where: ShippingWhereUniqueInput!): Shipping
  shippings(where: ShippingWhereInput, orderBy: ShippingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Shipping]!
  shippingsConnection(where: ShippingWhereInput, orderBy: ShippingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ShippingConnection!
  shoppingCart(where: ShoppingCartWhereUniqueInput!): ShoppingCart
  shoppingCarts(where: ShoppingCartWhereInput, orderBy: ShoppingCartOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ShoppingCart]!
  shoppingCartsConnection(where: ShoppingCartWhereInput, orderBy: ShoppingCartOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ShoppingCartConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Quotation {
  id: ID!
  docId: String!
  productItems(where: ProductItemWhereInput, orderBy: ProductItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductItem!]
  createdAt: DateTime!
  updatedAt: DateTime!
  saleman: Saleman!
  payment: Payment
  shipping: Shipping
  customer: User!
}

type QuotationConnection {
  pageInfo: PageInfo!
  edges: [QuotationEdge]!
  aggregate: AggregateQuotation!
}

input QuotationCreateInput {
  id: ID
  docId: String!
  productItems: ProductItemCreateManyWithoutQuotationInput
  saleman: SalemanCreateOneWithoutQuotationsInput!
  payment: PaymentCreateOneWithoutQuotationInput
  shipping: ShippingCreateOneWithoutQuotationInput
  customer: UserCreateOneWithoutQuotationsInput!
}

input QuotationCreateManyWithoutCustomerInput {
  create: [QuotationCreateWithoutCustomerInput!]
  connect: [QuotationWhereUniqueInput!]
}

input QuotationCreateManyWithoutSalemanInput {
  create: [QuotationCreateWithoutSalemanInput!]
  connect: [QuotationWhereUniqueInput!]
}

input QuotationCreateOneInput {
  create: QuotationCreateInput
  connect: QuotationWhereUniqueInput
}

input QuotationCreateOneWithoutPaymentInput {
  create: QuotationCreateWithoutPaymentInput
  connect: QuotationWhereUniqueInput
}

input QuotationCreateOneWithoutProductItemsInput {
  create: QuotationCreateWithoutProductItemsInput
  connect: QuotationWhereUniqueInput
}

input QuotationCreateOneWithoutShippingInput {
  create: QuotationCreateWithoutShippingInput
  connect: QuotationWhereUniqueInput
}

input QuotationCreateWithoutCustomerInput {
  id: ID
  docId: String!
  productItems: ProductItemCreateManyWithoutQuotationInput
  saleman: SalemanCreateOneWithoutQuotationsInput!
  payment: PaymentCreateOneWithoutQuotationInput
  shipping: ShippingCreateOneWithoutQuotationInput
}

input QuotationCreateWithoutPaymentInput {
  id: ID
  docId: String!
  productItems: ProductItemCreateManyWithoutQuotationInput
  saleman: SalemanCreateOneWithoutQuotationsInput!
  shipping: ShippingCreateOneWithoutQuotationInput
  customer: UserCreateOneWithoutQuotationsInput!
}

input QuotationCreateWithoutProductItemsInput {
  id: ID
  docId: String!
  saleman: SalemanCreateOneWithoutQuotationsInput!
  payment: PaymentCreateOneWithoutQuotationInput
  shipping: ShippingCreateOneWithoutQuotationInput
  customer: UserCreateOneWithoutQuotationsInput!
}

input QuotationCreateWithoutSalemanInput {
  id: ID
  docId: String!
  productItems: ProductItemCreateManyWithoutQuotationInput
  payment: PaymentCreateOneWithoutQuotationInput
  shipping: ShippingCreateOneWithoutQuotationInput
  customer: UserCreateOneWithoutQuotationsInput!
}

input QuotationCreateWithoutShippingInput {
  id: ID
  docId: String!
  productItems: ProductItemCreateManyWithoutQuotationInput
  saleman: SalemanCreateOneWithoutQuotationsInput!
  payment: PaymentCreateOneWithoutQuotationInput
  customer: UserCreateOneWithoutQuotationsInput!
}

type QuotationEdge {
  node: Quotation!
  cursor: String!
}

enum QuotationOrderByInput {
  id_ASC
  id_DESC
  docId_ASC
  docId_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type QuotationPreviousValues {
  id: ID!
  docId: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input QuotationScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  docId: String
  docId_not: String
  docId_in: [String!]
  docId_not_in: [String!]
  docId_lt: String
  docId_lte: String
  docId_gt: String
  docId_gte: String
  docId_contains: String
  docId_not_contains: String
  docId_starts_with: String
  docId_not_starts_with: String
  docId_ends_with: String
  docId_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [QuotationScalarWhereInput!]
  OR: [QuotationScalarWhereInput!]
  NOT: [QuotationScalarWhereInput!]
}

type QuotationSubscriptionPayload {
  mutation: MutationType!
  node: Quotation
  updatedFields: [String!]
  previousValues: QuotationPreviousValues
}

input QuotationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: QuotationWhereInput
  AND: [QuotationSubscriptionWhereInput!]
  OR: [QuotationSubscriptionWhereInput!]
  NOT: [QuotationSubscriptionWhereInput!]
}

input QuotationUpdateDataInput {
  docId: String
  productItems: ProductItemUpdateManyWithoutQuotationInput
  saleman: SalemanUpdateOneRequiredWithoutQuotationsInput
  payment: PaymentUpdateOneWithoutQuotationInput
  shipping: ShippingUpdateOneWithoutQuotationInput
  customer: UserUpdateOneRequiredWithoutQuotationsInput
}

input QuotationUpdateInput {
  docId: String
  productItems: ProductItemUpdateManyWithoutQuotationInput
  saleman: SalemanUpdateOneRequiredWithoutQuotationsInput
  payment: PaymentUpdateOneWithoutQuotationInput
  shipping: ShippingUpdateOneWithoutQuotationInput
  customer: UserUpdateOneRequiredWithoutQuotationsInput
}

input QuotationUpdateManyDataInput {
  docId: String
}

input QuotationUpdateManyMutationInput {
  docId: String
}

input QuotationUpdateManyWithoutCustomerInput {
  create: [QuotationCreateWithoutCustomerInput!]
  delete: [QuotationWhereUniqueInput!]
  connect: [QuotationWhereUniqueInput!]
  set: [QuotationWhereUniqueInput!]
  disconnect: [QuotationWhereUniqueInput!]
  update: [QuotationUpdateWithWhereUniqueWithoutCustomerInput!]
  upsert: [QuotationUpsertWithWhereUniqueWithoutCustomerInput!]
  deleteMany: [QuotationScalarWhereInput!]
  updateMany: [QuotationUpdateManyWithWhereNestedInput!]
}

input QuotationUpdateManyWithoutSalemanInput {
  create: [QuotationCreateWithoutSalemanInput!]
  delete: [QuotationWhereUniqueInput!]
  connect: [QuotationWhereUniqueInput!]
  set: [QuotationWhereUniqueInput!]
  disconnect: [QuotationWhereUniqueInput!]
  update: [QuotationUpdateWithWhereUniqueWithoutSalemanInput!]
  upsert: [QuotationUpsertWithWhereUniqueWithoutSalemanInput!]
  deleteMany: [QuotationScalarWhereInput!]
  updateMany: [QuotationUpdateManyWithWhereNestedInput!]
}

input QuotationUpdateManyWithWhereNestedInput {
  where: QuotationScalarWhereInput!
  data: QuotationUpdateManyDataInput!
}

input QuotationUpdateOneRequiredInput {
  create: QuotationCreateInput
  update: QuotationUpdateDataInput
  upsert: QuotationUpsertNestedInput
  connect: QuotationWhereUniqueInput
}

input QuotationUpdateOneRequiredWithoutPaymentInput {
  create: QuotationCreateWithoutPaymentInput
  update: QuotationUpdateWithoutPaymentDataInput
  upsert: QuotationUpsertWithoutPaymentInput
  connect: QuotationWhereUniqueInput
}

input QuotationUpdateOneRequiredWithoutShippingInput {
  create: QuotationCreateWithoutShippingInput
  update: QuotationUpdateWithoutShippingDataInput
  upsert: QuotationUpsertWithoutShippingInput
  connect: QuotationWhereUniqueInput
}

input QuotationUpdateOneWithoutProductItemsInput {
  create: QuotationCreateWithoutProductItemsInput
  update: QuotationUpdateWithoutProductItemsDataInput
  upsert: QuotationUpsertWithoutProductItemsInput
  delete: Boolean
  disconnect: Boolean
  connect: QuotationWhereUniqueInput
}

input QuotationUpdateWithoutCustomerDataInput {
  docId: String
  productItems: ProductItemUpdateManyWithoutQuotationInput
  saleman: SalemanUpdateOneRequiredWithoutQuotationsInput
  payment: PaymentUpdateOneWithoutQuotationInput
  shipping: ShippingUpdateOneWithoutQuotationInput
}

input QuotationUpdateWithoutPaymentDataInput {
  docId: String
  productItems: ProductItemUpdateManyWithoutQuotationInput
  saleman: SalemanUpdateOneRequiredWithoutQuotationsInput
  shipping: ShippingUpdateOneWithoutQuotationInput
  customer: UserUpdateOneRequiredWithoutQuotationsInput
}

input QuotationUpdateWithoutProductItemsDataInput {
  docId: String
  saleman: SalemanUpdateOneRequiredWithoutQuotationsInput
  payment: PaymentUpdateOneWithoutQuotationInput
  shipping: ShippingUpdateOneWithoutQuotationInput
  customer: UserUpdateOneRequiredWithoutQuotationsInput
}

input QuotationUpdateWithoutSalemanDataInput {
  docId: String
  productItems: ProductItemUpdateManyWithoutQuotationInput
  payment: PaymentUpdateOneWithoutQuotationInput
  shipping: ShippingUpdateOneWithoutQuotationInput
  customer: UserUpdateOneRequiredWithoutQuotationsInput
}

input QuotationUpdateWithoutShippingDataInput {
  docId: String
  productItems: ProductItemUpdateManyWithoutQuotationInput
  saleman: SalemanUpdateOneRequiredWithoutQuotationsInput
  payment: PaymentUpdateOneWithoutQuotationInput
  customer: UserUpdateOneRequiredWithoutQuotationsInput
}

input QuotationUpdateWithWhereUniqueWithoutCustomerInput {
  where: QuotationWhereUniqueInput!
  data: QuotationUpdateWithoutCustomerDataInput!
}

input QuotationUpdateWithWhereUniqueWithoutSalemanInput {
  where: QuotationWhereUniqueInput!
  data: QuotationUpdateWithoutSalemanDataInput!
}

input QuotationUpsertNestedInput {
  update: QuotationUpdateDataInput!
  create: QuotationCreateInput!
}

input QuotationUpsertWithoutPaymentInput {
  update: QuotationUpdateWithoutPaymentDataInput!
  create: QuotationCreateWithoutPaymentInput!
}

input QuotationUpsertWithoutProductItemsInput {
  update: QuotationUpdateWithoutProductItemsDataInput!
  create: QuotationCreateWithoutProductItemsInput!
}

input QuotationUpsertWithoutShippingInput {
  update: QuotationUpdateWithoutShippingDataInput!
  create: QuotationCreateWithoutShippingInput!
}

input QuotationUpsertWithWhereUniqueWithoutCustomerInput {
  where: QuotationWhereUniqueInput!
  update: QuotationUpdateWithoutCustomerDataInput!
  create: QuotationCreateWithoutCustomerInput!
}

input QuotationUpsertWithWhereUniqueWithoutSalemanInput {
  where: QuotationWhereUniqueInput!
  update: QuotationUpdateWithoutSalemanDataInput!
  create: QuotationCreateWithoutSalemanInput!
}

input QuotationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  docId: String
  docId_not: String
  docId_in: [String!]
  docId_not_in: [String!]
  docId_lt: String
  docId_lte: String
  docId_gt: String
  docId_gte: String
  docId_contains: String
  docId_not_contains: String
  docId_starts_with: String
  docId_not_starts_with: String
  docId_ends_with: String
  docId_not_ends_with: String
  productItems_every: ProductItemWhereInput
  productItems_some: ProductItemWhereInput
  productItems_none: ProductItemWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  saleman: SalemanWhereInput
  payment: PaymentWhereInput
  shipping: ShippingWhereInput
  customer: UserWhereInput
  AND: [QuotationWhereInput!]
  OR: [QuotationWhereInput!]
  NOT: [QuotationWhereInput!]
}

input QuotationWhereUniqueInput {
  id: ID
}

type Saleman {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  payments(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Payment!]
  invoices(where: InvoiceWhereInput, orderBy: InvoiceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Invoice!]
  quotations(where: QuotationWhereInput, orderBy: QuotationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Quotation!]
}

type SalemanConnection {
  pageInfo: PageInfo!
  edges: [SalemanEdge]!
  aggregate: AggregateSaleman!
}

input SalemanCreateInput {
  id: ID
  payments: PaymentCreateManyWithoutSalemanInput
  invoices: InvoiceCreateManyWithoutSalemanInput
  quotations: QuotationCreateManyWithoutSalemanInput
}

input SalemanCreateOneWithoutInvoicesInput {
  create: SalemanCreateWithoutInvoicesInput
  connect: SalemanWhereUniqueInput
}

input SalemanCreateOneWithoutPaymentsInput {
  create: SalemanCreateWithoutPaymentsInput
  connect: SalemanWhereUniqueInput
}

input SalemanCreateOneWithoutQuotationsInput {
  create: SalemanCreateWithoutQuotationsInput
  connect: SalemanWhereUniqueInput
}

input SalemanCreateWithoutInvoicesInput {
  id: ID
  payments: PaymentCreateManyWithoutSalemanInput
  quotations: QuotationCreateManyWithoutSalemanInput
}

input SalemanCreateWithoutPaymentsInput {
  id: ID
  invoices: InvoiceCreateManyWithoutSalemanInput
  quotations: QuotationCreateManyWithoutSalemanInput
}

input SalemanCreateWithoutQuotationsInput {
  id: ID
  payments: PaymentCreateManyWithoutSalemanInput
  invoices: InvoiceCreateManyWithoutSalemanInput
}

type SalemanEdge {
  node: Saleman!
  cursor: String!
}

enum SalemanOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SalemanPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SalemanSubscriptionPayload {
  mutation: MutationType!
  node: Saleman
  updatedFields: [String!]
  previousValues: SalemanPreviousValues
}

input SalemanSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SalemanWhereInput
  AND: [SalemanSubscriptionWhereInput!]
  OR: [SalemanSubscriptionWhereInput!]
  NOT: [SalemanSubscriptionWhereInput!]
}

input SalemanUpdateInput {
  payments: PaymentUpdateManyWithoutSalemanInput
  invoices: InvoiceUpdateManyWithoutSalemanInput
  quotations: QuotationUpdateManyWithoutSalemanInput
}

input SalemanUpdateOneRequiredWithoutInvoicesInput {
  create: SalemanCreateWithoutInvoicesInput
  update: SalemanUpdateWithoutInvoicesDataInput
  upsert: SalemanUpsertWithoutInvoicesInput
  connect: SalemanWhereUniqueInput
}

input SalemanUpdateOneRequiredWithoutPaymentsInput {
  create: SalemanCreateWithoutPaymentsInput
  update: SalemanUpdateWithoutPaymentsDataInput
  upsert: SalemanUpsertWithoutPaymentsInput
  connect: SalemanWhereUniqueInput
}

input SalemanUpdateOneRequiredWithoutQuotationsInput {
  create: SalemanCreateWithoutQuotationsInput
  update: SalemanUpdateWithoutQuotationsDataInput
  upsert: SalemanUpsertWithoutQuotationsInput
  connect: SalemanWhereUniqueInput
}

input SalemanUpdateWithoutInvoicesDataInput {
  payments: PaymentUpdateManyWithoutSalemanInput
  quotations: QuotationUpdateManyWithoutSalemanInput
}

input SalemanUpdateWithoutPaymentsDataInput {
  invoices: InvoiceUpdateManyWithoutSalemanInput
  quotations: QuotationUpdateManyWithoutSalemanInput
}

input SalemanUpdateWithoutQuotationsDataInput {
  payments: PaymentUpdateManyWithoutSalemanInput
  invoices: InvoiceUpdateManyWithoutSalemanInput
}

input SalemanUpsertWithoutInvoicesInput {
  update: SalemanUpdateWithoutInvoicesDataInput!
  create: SalemanCreateWithoutInvoicesInput!
}

input SalemanUpsertWithoutPaymentsInput {
  update: SalemanUpdateWithoutPaymentsDataInput!
  create: SalemanCreateWithoutPaymentsInput!
}

input SalemanUpsertWithoutQuotationsInput {
  update: SalemanUpdateWithoutQuotationsDataInput!
  create: SalemanCreateWithoutQuotationsInput!
}

input SalemanWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  payments_every: PaymentWhereInput
  payments_some: PaymentWhereInput
  payments_none: PaymentWhereInput
  invoices_every: InvoiceWhereInput
  invoices_some: InvoiceWhereInput
  invoices_none: InvoiceWhereInput
  quotations_every: QuotationWhereInput
  quotations_some: QuotationWhereInput
  quotations_none: QuotationWhereInput
  AND: [SalemanWhereInput!]
  OR: [SalemanWhereInput!]
  NOT: [SalemanWhereInput!]
}

input SalemanWhereUniqueInput {
  id: ID
}

type Shipping {
  id: ID!
  docId: String!
  dueDate: DateTime!
  status: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  invoce: Invoice!
  address: Address!
  quotation: Quotation!
}

type ShippingConnection {
  pageInfo: PageInfo!
  edges: [ShippingEdge]!
  aggregate: AggregateShipping!
}

input ShippingCreateInput {
  id: ID
  docId: String!
  dueDate: DateTime!
  status: String!
  invoce: InvoiceCreateOneInput!
  address: AddressCreateOneWithoutShippingInput!
  quotation: QuotationCreateOneWithoutShippingInput!
}

input ShippingCreateManyWithoutAddressInput {
  create: [ShippingCreateWithoutAddressInput!]
  connect: [ShippingWhereUniqueInput!]
}

input ShippingCreateOneWithoutQuotationInput {
  create: ShippingCreateWithoutQuotationInput
  connect: ShippingWhereUniqueInput
}

input ShippingCreateWithoutAddressInput {
  id: ID
  docId: String!
  dueDate: DateTime!
  status: String!
  invoce: InvoiceCreateOneInput!
  quotation: QuotationCreateOneWithoutShippingInput!
}

input ShippingCreateWithoutQuotationInput {
  id: ID
  docId: String!
  dueDate: DateTime!
  status: String!
  invoce: InvoiceCreateOneInput!
  address: AddressCreateOneWithoutShippingInput!
}

type ShippingEdge {
  node: Shipping!
  cursor: String!
}

enum ShippingOrderByInput {
  id_ASC
  id_DESC
  docId_ASC
  docId_DESC
  dueDate_ASC
  dueDate_DESC
  status_ASC
  status_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ShippingPreviousValues {
  id: ID!
  docId: String!
  dueDate: DateTime!
  status: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ShippingScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  docId: String
  docId_not: String
  docId_in: [String!]
  docId_not_in: [String!]
  docId_lt: String
  docId_lte: String
  docId_gt: String
  docId_gte: String
  docId_contains: String
  docId_not_contains: String
  docId_starts_with: String
  docId_not_starts_with: String
  docId_ends_with: String
  docId_not_ends_with: String
  dueDate: DateTime
  dueDate_not: DateTime
  dueDate_in: [DateTime!]
  dueDate_not_in: [DateTime!]
  dueDate_lt: DateTime
  dueDate_lte: DateTime
  dueDate_gt: DateTime
  dueDate_gte: DateTime
  status: String
  status_not: String
  status_in: [String!]
  status_not_in: [String!]
  status_lt: String
  status_lte: String
  status_gt: String
  status_gte: String
  status_contains: String
  status_not_contains: String
  status_starts_with: String
  status_not_starts_with: String
  status_ends_with: String
  status_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ShippingScalarWhereInput!]
  OR: [ShippingScalarWhereInput!]
  NOT: [ShippingScalarWhereInput!]
}

type ShippingSubscriptionPayload {
  mutation: MutationType!
  node: Shipping
  updatedFields: [String!]
  previousValues: ShippingPreviousValues
}

input ShippingSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ShippingWhereInput
  AND: [ShippingSubscriptionWhereInput!]
  OR: [ShippingSubscriptionWhereInput!]
  NOT: [ShippingSubscriptionWhereInput!]
}

input ShippingUpdateInput {
  docId: String
  dueDate: DateTime
  status: String
  invoce: InvoiceUpdateOneRequiredInput
  address: AddressUpdateOneRequiredWithoutShippingInput
  quotation: QuotationUpdateOneRequiredWithoutShippingInput
}

input ShippingUpdateManyDataInput {
  docId: String
  dueDate: DateTime
  status: String
}

input ShippingUpdateManyMutationInput {
  docId: String
  dueDate: DateTime
  status: String
}

input ShippingUpdateManyWithoutAddressInput {
  create: [ShippingCreateWithoutAddressInput!]
  delete: [ShippingWhereUniqueInput!]
  connect: [ShippingWhereUniqueInput!]
  set: [ShippingWhereUniqueInput!]
  disconnect: [ShippingWhereUniqueInput!]
  update: [ShippingUpdateWithWhereUniqueWithoutAddressInput!]
  upsert: [ShippingUpsertWithWhereUniqueWithoutAddressInput!]
  deleteMany: [ShippingScalarWhereInput!]
  updateMany: [ShippingUpdateManyWithWhereNestedInput!]
}

input ShippingUpdateManyWithWhereNestedInput {
  where: ShippingScalarWhereInput!
  data: ShippingUpdateManyDataInput!
}

input ShippingUpdateOneWithoutQuotationInput {
  create: ShippingCreateWithoutQuotationInput
  update: ShippingUpdateWithoutQuotationDataInput
  upsert: ShippingUpsertWithoutQuotationInput
  delete: Boolean
  disconnect: Boolean
  connect: ShippingWhereUniqueInput
}

input ShippingUpdateWithoutAddressDataInput {
  docId: String
  dueDate: DateTime
  status: String
  invoce: InvoiceUpdateOneRequiredInput
  quotation: QuotationUpdateOneRequiredWithoutShippingInput
}

input ShippingUpdateWithoutQuotationDataInput {
  docId: String
  dueDate: DateTime
  status: String
  invoce: InvoiceUpdateOneRequiredInput
  address: AddressUpdateOneRequiredWithoutShippingInput
}

input ShippingUpdateWithWhereUniqueWithoutAddressInput {
  where: ShippingWhereUniqueInput!
  data: ShippingUpdateWithoutAddressDataInput!
}

input ShippingUpsertWithoutQuotationInput {
  update: ShippingUpdateWithoutQuotationDataInput!
  create: ShippingCreateWithoutQuotationInput!
}

input ShippingUpsertWithWhereUniqueWithoutAddressInput {
  where: ShippingWhereUniqueInput!
  update: ShippingUpdateWithoutAddressDataInput!
  create: ShippingCreateWithoutAddressInput!
}

input ShippingWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  docId: String
  docId_not: String
  docId_in: [String!]
  docId_not_in: [String!]
  docId_lt: String
  docId_lte: String
  docId_gt: String
  docId_gte: String
  docId_contains: String
  docId_not_contains: String
  docId_starts_with: String
  docId_not_starts_with: String
  docId_ends_with: String
  docId_not_ends_with: String
  dueDate: DateTime
  dueDate_not: DateTime
  dueDate_in: [DateTime!]
  dueDate_not_in: [DateTime!]
  dueDate_lt: DateTime
  dueDate_lte: DateTime
  dueDate_gt: DateTime
  dueDate_gte: DateTime
  status: String
  status_not: String
  status_in: [String!]
  status_not_in: [String!]
  status_lt: String
  status_lte: String
  status_gt: String
  status_gte: String
  status_contains: String
  status_not_contains: String
  status_starts_with: String
  status_not_starts_with: String
  status_ends_with: String
  status_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  invoce: InvoiceWhereInput
  address: AddressWhereInput
  quotation: QuotationWhereInput
  AND: [ShippingWhereInput!]
  OR: [ShippingWhereInput!]
  NOT: [ShippingWhereInput!]
}

input ShippingWhereUniqueInput {
  id: ID
}

type ShoppingCart {
  id: ID!
  total_cost: Float!
  createdAt: DateTime!
  updatedAt: DateTime!
  productItems(where: ProductItemWhereInput, orderBy: ProductItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductItem!]
  customer: User!
}

type ShoppingCartConnection {
  pageInfo: PageInfo!
  edges: [ShoppingCartEdge]!
  aggregate: AggregateShoppingCart!
}

input ShoppingCartCreateInput {
  id: ID
  total_cost: Float!
  productItems: ProductItemCreateManyWithoutShoppingCartInput
  customer: UserCreateOneWithoutShoppingCartInput!
}

input ShoppingCartCreateOneWithoutCustomerInput {
  create: ShoppingCartCreateWithoutCustomerInput
  connect: ShoppingCartWhereUniqueInput
}

input ShoppingCartCreateOneWithoutProductItemsInput {
  create: ShoppingCartCreateWithoutProductItemsInput
  connect: ShoppingCartWhereUniqueInput
}

input ShoppingCartCreateWithoutCustomerInput {
  id: ID
  total_cost: Float!
  productItems: ProductItemCreateManyWithoutShoppingCartInput
}

input ShoppingCartCreateWithoutProductItemsInput {
  id: ID
  total_cost: Float!
  customer: UserCreateOneWithoutShoppingCartInput!
}

type ShoppingCartEdge {
  node: ShoppingCart!
  cursor: String!
}

enum ShoppingCartOrderByInput {
  id_ASC
  id_DESC
  total_cost_ASC
  total_cost_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ShoppingCartPreviousValues {
  id: ID!
  total_cost: Float!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ShoppingCartSubscriptionPayload {
  mutation: MutationType!
  node: ShoppingCart
  updatedFields: [String!]
  previousValues: ShoppingCartPreviousValues
}

input ShoppingCartSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ShoppingCartWhereInput
  AND: [ShoppingCartSubscriptionWhereInput!]
  OR: [ShoppingCartSubscriptionWhereInput!]
  NOT: [ShoppingCartSubscriptionWhereInput!]
}

input ShoppingCartUpdateInput {
  total_cost: Float
  productItems: ProductItemUpdateManyWithoutShoppingCartInput
  customer: UserUpdateOneRequiredWithoutShoppingCartInput
}

input ShoppingCartUpdateManyMutationInput {
  total_cost: Float
}

input ShoppingCartUpdateOneRequiredWithoutCustomerInput {
  create: ShoppingCartCreateWithoutCustomerInput
  update: ShoppingCartUpdateWithoutCustomerDataInput
  upsert: ShoppingCartUpsertWithoutCustomerInput
  connect: ShoppingCartWhereUniqueInput
}

input ShoppingCartUpdateOneWithoutProductItemsInput {
  create: ShoppingCartCreateWithoutProductItemsInput
  update: ShoppingCartUpdateWithoutProductItemsDataInput
  upsert: ShoppingCartUpsertWithoutProductItemsInput
  delete: Boolean
  disconnect: Boolean
  connect: ShoppingCartWhereUniqueInput
}

input ShoppingCartUpdateWithoutCustomerDataInput {
  total_cost: Float
  productItems: ProductItemUpdateManyWithoutShoppingCartInput
}

input ShoppingCartUpdateWithoutProductItemsDataInput {
  total_cost: Float
  customer: UserUpdateOneRequiredWithoutShoppingCartInput
}

input ShoppingCartUpsertWithoutCustomerInput {
  update: ShoppingCartUpdateWithoutCustomerDataInput!
  create: ShoppingCartCreateWithoutCustomerInput!
}

input ShoppingCartUpsertWithoutProductItemsInput {
  update: ShoppingCartUpdateWithoutProductItemsDataInput!
  create: ShoppingCartCreateWithoutProductItemsInput!
}

input ShoppingCartWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  total_cost: Float
  total_cost_not: Float
  total_cost_in: [Float!]
  total_cost_not_in: [Float!]
  total_cost_lt: Float
  total_cost_lte: Float
  total_cost_gt: Float
  total_cost_gte: Float
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  productItems_every: ProductItemWhereInput
  productItems_some: ProductItemWhereInput
  productItems_none: ProductItemWhereInput
  customer: UserWhereInput
  AND: [ShoppingCartWhereInput!]
  OR: [ShoppingCartWhereInput!]
  NOT: [ShoppingCartWhereInput!]
}

input ShoppingCartWhereUniqueInput {
  id: ID
}

type Subscription {
  address(where: AddressSubscriptionWhereInput): AddressSubscriptionPayload
  category(where: CategorySubscriptionWhereInput): CategorySubscriptionPayload
  image(where: ImageSubscriptionWhereInput): ImageSubscriptionPayload
  invoice(where: InvoiceSubscriptionWhereInput): InvoiceSubscriptionPayload
  payment(where: PaymentSubscriptionWhereInput): PaymentSubscriptionPayload
  productItem(where: ProductItemSubscriptionWhereInput): ProductItemSubscriptionPayload
  quotation(where: QuotationSubscriptionWhereInput): QuotationSubscriptionPayload
  saleman(where: SalemanSubscriptionWhereInput): SalemanSubscriptionPayload
  shipping(where: ShippingSubscriptionWhereInput): ShippingSubscriptionPayload
  shoppingCart(where: ShoppingCartSubscriptionWhereInput): ShoppingCartSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  type: String
  name: String!
  email: String!
  password: String!
  phone: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  shoppingCart: ShoppingCart!
  quotations(where: QuotationWhereInput, orderBy: QuotationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Quotation!]
  payments(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Payment!]
  addresses(where: AddressWhereInput, orderBy: AddressOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Address!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  type: String
  name: String!
  email: String!
  password: String!
  phone: String!
  shoppingCart: ShoppingCartCreateOneWithoutCustomerInput!
  quotations: QuotationCreateManyWithoutCustomerInput
  payments: PaymentCreateManyWithoutCustomerInput
  addresses: AddressCreateManyWithoutCustomerInput
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutAddressesInput {
  create: UserCreateWithoutAddressesInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutPaymentsInput {
  create: UserCreateWithoutPaymentsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutQuotationsInput {
  create: UserCreateWithoutQuotationsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutShoppingCartInput {
  create: UserCreateWithoutShoppingCartInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutAddressesInput {
  id: ID
  type: String
  name: String!
  email: String!
  password: String!
  phone: String!
  shoppingCart: ShoppingCartCreateOneWithoutCustomerInput!
  quotations: QuotationCreateManyWithoutCustomerInput
  payments: PaymentCreateManyWithoutCustomerInput
}

input UserCreateWithoutPaymentsInput {
  id: ID
  type: String
  name: String!
  email: String!
  password: String!
  phone: String!
  shoppingCart: ShoppingCartCreateOneWithoutCustomerInput!
  quotations: QuotationCreateManyWithoutCustomerInput
  addresses: AddressCreateManyWithoutCustomerInput
}

input UserCreateWithoutQuotationsInput {
  id: ID
  type: String
  name: String!
  email: String!
  password: String!
  phone: String!
  shoppingCart: ShoppingCartCreateOneWithoutCustomerInput!
  payments: PaymentCreateManyWithoutCustomerInput
  addresses: AddressCreateManyWithoutCustomerInput
}

input UserCreateWithoutShoppingCartInput {
  id: ID
  type: String
  name: String!
  email: String!
  password: String!
  phone: String!
  quotations: QuotationCreateManyWithoutCustomerInput
  payments: PaymentCreateManyWithoutCustomerInput
  addresses: AddressCreateManyWithoutCustomerInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  phone_ASC
  phone_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  type: String
  name: String!
  email: String!
  password: String!
  phone: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  type: String
  name: String
  email: String
  password: String
  phone: String
  shoppingCart: ShoppingCartUpdateOneRequiredWithoutCustomerInput
  quotations: QuotationUpdateManyWithoutCustomerInput
  payments: PaymentUpdateManyWithoutCustomerInput
  addresses: AddressUpdateManyWithoutCustomerInput
}

input UserUpdateInput {
  type: String
  name: String
  email: String
  password: String
  phone: String
  shoppingCart: ShoppingCartUpdateOneRequiredWithoutCustomerInput
  quotations: QuotationUpdateManyWithoutCustomerInput
  payments: PaymentUpdateManyWithoutCustomerInput
  addresses: AddressUpdateManyWithoutCustomerInput
}

input UserUpdateManyMutationInput {
  type: String
  name: String
  email: String
  password: String
  phone: String
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutAddressesInput {
  create: UserCreateWithoutAddressesInput
  update: UserUpdateWithoutAddressesDataInput
  upsert: UserUpsertWithoutAddressesInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutPaymentsInput {
  create: UserCreateWithoutPaymentsInput
  update: UserUpdateWithoutPaymentsDataInput
  upsert: UserUpsertWithoutPaymentsInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutQuotationsInput {
  create: UserCreateWithoutQuotationsInput
  update: UserUpdateWithoutQuotationsDataInput
  upsert: UserUpsertWithoutQuotationsInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutShoppingCartInput {
  create: UserCreateWithoutShoppingCartInput
  update: UserUpdateWithoutShoppingCartDataInput
  upsert: UserUpsertWithoutShoppingCartInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutAddressesDataInput {
  type: String
  name: String
  email: String
  password: String
  phone: String
  shoppingCart: ShoppingCartUpdateOneRequiredWithoutCustomerInput
  quotations: QuotationUpdateManyWithoutCustomerInput
  payments: PaymentUpdateManyWithoutCustomerInput
}

input UserUpdateWithoutPaymentsDataInput {
  type: String
  name: String
  email: String
  password: String
  phone: String
  shoppingCart: ShoppingCartUpdateOneRequiredWithoutCustomerInput
  quotations: QuotationUpdateManyWithoutCustomerInput
  addresses: AddressUpdateManyWithoutCustomerInput
}

input UserUpdateWithoutQuotationsDataInput {
  type: String
  name: String
  email: String
  password: String
  phone: String
  shoppingCart: ShoppingCartUpdateOneRequiredWithoutCustomerInput
  payments: PaymentUpdateManyWithoutCustomerInput
  addresses: AddressUpdateManyWithoutCustomerInput
}

input UserUpdateWithoutShoppingCartDataInput {
  type: String
  name: String
  email: String
  password: String
  phone: String
  quotations: QuotationUpdateManyWithoutCustomerInput
  payments: PaymentUpdateManyWithoutCustomerInput
  addresses: AddressUpdateManyWithoutCustomerInput
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutAddressesInput {
  update: UserUpdateWithoutAddressesDataInput!
  create: UserCreateWithoutAddressesInput!
}

input UserUpsertWithoutPaymentsInput {
  update: UserUpdateWithoutPaymentsDataInput!
  create: UserCreateWithoutPaymentsInput!
}

input UserUpsertWithoutQuotationsInput {
  update: UserUpdateWithoutQuotationsDataInput!
  create: UserCreateWithoutQuotationsInput!
}

input UserUpsertWithoutShoppingCartInput {
  update: UserUpdateWithoutShoppingCartDataInput!
  create: UserCreateWithoutShoppingCartInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  shoppingCart: ShoppingCartWhereInput
  quotations_every: QuotationWhereInput
  quotations_some: QuotationWhereInput
  quotations_none: QuotationWhereInput
  payments_every: PaymentWhereInput
  payments_some: PaymentWhereInput
  payments_none: PaymentWhereInput
  addresses_every: AddressWhereInput
  addresses_some: AddressWhereInput
  addresses_none: AddressWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
