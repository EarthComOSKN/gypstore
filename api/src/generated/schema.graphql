### This file was autogenerated by GraphQL Nexus
### Do not make changes to this file directly


type Address {
  Address: String!
  createdAt: DateTime!
  customer: User!
  id: ID!
  invoices(after: String, before: String, first: Int, last: Int, orderBy: InvoiceOrderByInput, skip: Int, where: InvoiceWhereInput): [Invoice!]
  name: String!
  shipping(after: String, before: String, first: Int, last: Int, orderBy: ShippingOrderByInput, skip: Int, where: ShippingWhereInput): [Shipping!]
  updatedAt: DateTime!
}

type AddressConnection {
  aggregate: AggregateAddress!
  edges: [AddressEdge!]!
  pageInfo: PageInfo!
}

input AddressCreateInput {
  Address: String!
  customer: UserCreateOneWithoutAddressesInput!
  id: ID
  invoices: InvoiceCreateManyWithoutAddressInput
  name: String!
  shipping: ShippingCreateManyWithoutAddressInput
}

input AddressCreateManyWithoutCustomerInput {
  connect: [AddressWhereUniqueInput!]
  create: [AddressCreateWithoutCustomerInput!]
}

input AddressCreateOneWithoutInvoicesInput {
  connect: AddressWhereUniqueInput
  create: AddressCreateWithoutInvoicesInput
}

input AddressCreateOneWithoutShippingInput {
  connect: AddressWhereUniqueInput
  create: AddressCreateWithoutShippingInput
}

input AddressCreateWithoutCustomerInput {
  Address: String!
  id: ID
  invoices: InvoiceCreateManyWithoutAddressInput
  name: String!
  shipping: ShippingCreateManyWithoutAddressInput
}

input AddressCreateWithoutInvoicesInput {
  Address: String!
  customer: UserCreateOneWithoutAddressesInput!
  id: ID
  name: String!
  shipping: ShippingCreateManyWithoutAddressInput
}

input AddressCreateWithoutShippingInput {
  Address: String!
  customer: UserCreateOneWithoutAddressesInput!
  id: ID
  invoices: InvoiceCreateManyWithoutAddressInput
  name: String!
}

type AddressEdge {
  cursor: String!
  node: Address!
}

enum AddressOrderByInput {
  Address_ASC
  Address_DESC
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input AddressScalarWhereInput {
  Address: String
  Address_contains: String
  Address_ends_with: String
  Address_gt: String
  Address_gte: String
  Address_in: [String!]
  Address_lt: String
  Address_lte: String
  Address_not: String
  Address_not_contains: String
  Address_not_ends_with: String
  Address_not_in: [String!]
  Address_not_starts_with: String
  Address_starts_with: String
  AND: [AddressScalarWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [AddressScalarWhereInput!]
  OR: [AddressScalarWhereInput!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input AddressUpdateInput {
  Address: String
  customer: UserUpdateOneRequiredWithoutAddressesInput
  invoices: InvoiceUpdateManyWithoutAddressInput
  name: String
  shipping: ShippingUpdateManyWithoutAddressInput
}

input AddressUpdateManyDataInput {
  Address: String
  name: String
}

input AddressUpdateManyMutationInput {
  Address: String
  name: String
}

input AddressUpdateManyWithoutCustomerInput {
  connect: [AddressWhereUniqueInput!]
  create: [AddressCreateWithoutCustomerInput!]
  delete: [AddressWhereUniqueInput!]
  deleteMany: [AddressScalarWhereInput!]
  disconnect: [AddressWhereUniqueInput!]
  set: [AddressWhereUniqueInput!]
  update: [AddressUpdateWithWhereUniqueWithoutCustomerInput!]
  updateMany: [AddressUpdateManyWithWhereNestedInput!]
  upsert: [AddressUpsertWithWhereUniqueWithoutCustomerInput!]
}

input AddressUpdateManyWithWhereNestedInput {
  data: AddressUpdateManyDataInput!
  where: AddressScalarWhereInput!
}

input AddressUpdateOneRequiredWithoutShippingInput {
  connect: AddressWhereUniqueInput
  create: AddressCreateWithoutShippingInput
  update: AddressUpdateWithoutShippingDataInput
  upsert: AddressUpsertWithoutShippingInput
}

input AddressUpdateOneWithoutInvoicesInput {
  connect: AddressWhereUniqueInput
  create: AddressCreateWithoutInvoicesInput
  delete: Boolean
  disconnect: Boolean
  update: AddressUpdateWithoutInvoicesDataInput
  upsert: AddressUpsertWithoutInvoicesInput
}

input AddressUpdateWithoutCustomerDataInput {
  Address: String
  invoices: InvoiceUpdateManyWithoutAddressInput
  name: String
  shipping: ShippingUpdateManyWithoutAddressInput
}

input AddressUpdateWithoutInvoicesDataInput {
  Address: String
  customer: UserUpdateOneRequiredWithoutAddressesInput
  name: String
  shipping: ShippingUpdateManyWithoutAddressInput
}

input AddressUpdateWithoutShippingDataInput {
  Address: String
  customer: UserUpdateOneRequiredWithoutAddressesInput
  invoices: InvoiceUpdateManyWithoutAddressInput
  name: String
}

input AddressUpdateWithWhereUniqueWithoutCustomerInput {
  data: AddressUpdateWithoutCustomerDataInput!
  where: AddressWhereUniqueInput!
}

input AddressUpsertWithoutInvoicesInput {
  create: AddressCreateWithoutInvoicesInput!
  update: AddressUpdateWithoutInvoicesDataInput!
}

input AddressUpsertWithoutShippingInput {
  create: AddressCreateWithoutShippingInput!
  update: AddressUpdateWithoutShippingDataInput!
}

input AddressUpsertWithWhereUniqueWithoutCustomerInput {
  create: AddressCreateWithoutCustomerInput!
  update: AddressUpdateWithoutCustomerDataInput!
  where: AddressWhereUniqueInput!
}

input AddressWhereInput {
  Address: String
  Address_contains: String
  Address_ends_with: String
  Address_gt: String
  Address_gte: String
  Address_in: [String!]
  Address_lt: String
  Address_lte: String
  Address_not: String
  Address_not_contains: String
  Address_not_ends_with: String
  Address_not_in: [String!]
  Address_not_starts_with: String
  Address_starts_with: String
  AND: [AddressWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  customer: UserWhereInput
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  invoices_every: InvoiceWhereInput
  invoices_none: InvoiceWhereInput
  invoices_some: InvoiceWhereInput
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [AddressWhereInput!]
  OR: [AddressWhereInput!]
  shipping_every: ShippingWhereInput
  shipping_none: ShippingWhereInput
  shipping_some: ShippingWhereInput
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input AddressWhereUniqueInput {
  id: ID
}

type AggregateAddress {
  count: Int!
}

type AggregateCategory {
  count: Int!
}

type AggregateInvoice {
  count: Int!
}

type AggregatePayment {
  count: Int!
}

type AggregateProductItem {
  count: Int!
}

type AggregateQuotation {
  count: Int!
}

type AggregateQuotationItem {
  count: Int!
}

type AggregateSalesman {
  count: Int!
}

type AggregateShipping {
  count: Int!
}

type AggregateShoppingCart {
  count: Int!
}

type AggregateShoppingCartItem {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Category {
  category: Category
  createdAt: DateTime!
  id: ID!
  name: String!
  productItem(after: String, before: String, first: Int, last: Int, orderBy: ProductItemOrderByInput, skip: Int, where: ProductItemWhereInput): [ProductItem!]
  updatedAt: DateTime!
}

type CategoryConnection {
  aggregate: AggregateCategory!
  edges: [CategoryEdge!]!
  pageInfo: PageInfo!
}

input CategoryCreateInput {
  category: CategoryCreateOneInput
  id: ID
  name: String!
  productItem: ProductItemCreateManyWithoutCategoryInput
}

input CategoryCreateOneInput {
  connect: CategoryWhereUniqueInput
  create: CategoryCreateInput
}

input CategoryCreateOneWithoutProductItemInput {
  connect: CategoryWhereUniqueInput
  create: CategoryCreateWithoutProductItemInput
}

input CategoryCreateWithoutProductItemInput {
  category: CategoryCreateOneInput
  id: ID
  name: String!
}

type CategoryEdge {
  cursor: String!
  node: Category!
}

enum CategoryOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input CategoryUpdateDataInput {
  category: CategoryUpdateOneInput
  name: String
  productItem: ProductItemUpdateManyWithoutCategoryInput
}

input CategoryUpdateInput {
  category: CategoryUpdateOneInput
  name: String
  productItem: ProductItemUpdateManyWithoutCategoryInput
}

input CategoryUpdateManyMutationInput {
  name: String
}

input CategoryUpdateOneInput {
  connect: CategoryWhereUniqueInput
  create: CategoryCreateInput
  delete: Boolean
  disconnect: Boolean
  update: CategoryUpdateDataInput
  upsert: CategoryUpsertNestedInput
}

input CategoryUpdateOneRequiredWithoutProductItemInput {
  connect: CategoryWhereUniqueInput
  create: CategoryCreateWithoutProductItemInput
  update: CategoryUpdateWithoutProductItemDataInput
  upsert: CategoryUpsertWithoutProductItemInput
}

input CategoryUpdateWithoutProductItemDataInput {
  category: CategoryUpdateOneInput
  name: String
}

input CategoryUpsertNestedInput {
  create: CategoryCreateInput!
  update: CategoryUpdateDataInput!
}

input CategoryUpsertWithoutProductItemInput {
  create: CategoryCreateWithoutProductItemInput!
  update: CategoryUpdateWithoutProductItemDataInput!
}

input CategoryWhereInput {
  AND: [CategoryWhereInput!]
  category: CategoryWhereInput
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  productItem_every: ProductItemWhereInput
  productItem_none: ProductItemWhereInput
  productItem_some: ProductItemWhereInput
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input CategoryWhereUniqueInput {
  id: ID
}

scalar DateTime

type Invoice {
  address: Address
  createdAt: DateTime!
  creditTerm: String!
  docId: String!
  id: ID!
  payment: Payment
  quotation: Quotation!
  salesman: Salesman!
  updatedAt: DateTime!
  user: User!
}

type InvoiceConnection {
  aggregate: AggregateInvoice!
  edges: [InvoiceEdge!]!
  pageInfo: PageInfo!
}

input InvoiceCreateInput {
  address: AddressCreateOneWithoutInvoicesInput
  creditTerm: String!
  docId: String!
  id: ID
  payment: PaymentCreateOneWithoutInvoiceInput
  quotation: QuotationCreateOneInput!
  salesman: SalesmanCreateOneWithoutInvoicesInput!
  user: UserCreateOneInput!
}

input InvoiceCreateManyWithoutAddressInput {
  connect: [InvoiceWhereUniqueInput!]
  create: [InvoiceCreateWithoutAddressInput!]
}

input InvoiceCreateManyWithoutSalesmanInput {
  connect: [InvoiceWhereUniqueInput!]
  create: [InvoiceCreateWithoutSalesmanInput!]
}

input InvoiceCreateOneInput {
  connect: InvoiceWhereUniqueInput
  create: InvoiceCreateInput
}

input InvoiceCreateOneWithoutPaymentInput {
  connect: InvoiceWhereUniqueInput
  create: InvoiceCreateWithoutPaymentInput
}

input InvoiceCreateWithoutAddressInput {
  creditTerm: String!
  docId: String!
  id: ID
  payment: PaymentCreateOneWithoutInvoiceInput
  quotation: QuotationCreateOneInput!
  salesman: SalesmanCreateOneWithoutInvoicesInput!
  user: UserCreateOneInput!
}

input InvoiceCreateWithoutPaymentInput {
  address: AddressCreateOneWithoutInvoicesInput
  creditTerm: String!
  docId: String!
  id: ID
  quotation: QuotationCreateOneInput!
  salesman: SalesmanCreateOneWithoutInvoicesInput!
  user: UserCreateOneInput!
}

input InvoiceCreateWithoutSalesmanInput {
  address: AddressCreateOneWithoutInvoicesInput
  creditTerm: String!
  docId: String!
  id: ID
  payment: PaymentCreateOneWithoutInvoiceInput
  quotation: QuotationCreateOneInput!
  user: UserCreateOneInput!
}

type InvoiceEdge {
  cursor: String!
  node: Invoice!
}

enum InvoiceOrderByInput {
  createdAt_ASC
  createdAt_DESC
  creditTerm_ASC
  creditTerm_DESC
  docId_ASC
  docId_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input InvoiceScalarWhereInput {
  AND: [InvoiceScalarWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  creditTerm: String
  creditTerm_contains: String
  creditTerm_ends_with: String
  creditTerm_gt: String
  creditTerm_gte: String
  creditTerm_in: [String!]
  creditTerm_lt: String
  creditTerm_lte: String
  creditTerm_not: String
  creditTerm_not_contains: String
  creditTerm_not_ends_with: String
  creditTerm_not_in: [String!]
  creditTerm_not_starts_with: String
  creditTerm_starts_with: String
  docId: String
  docId_contains: String
  docId_ends_with: String
  docId_gt: String
  docId_gte: String
  docId_in: [String!]
  docId_lt: String
  docId_lte: String
  docId_not: String
  docId_not_contains: String
  docId_not_ends_with: String
  docId_not_in: [String!]
  docId_not_starts_with: String
  docId_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [InvoiceScalarWhereInput!]
  OR: [InvoiceScalarWhereInput!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input InvoiceUpdateDataInput {
  address: AddressUpdateOneWithoutInvoicesInput
  creditTerm: String
  docId: String
  payment: PaymentUpdateOneWithoutInvoiceInput
  quotation: QuotationUpdateOneRequiredInput
  salesman: SalesmanUpdateOneRequiredWithoutInvoicesInput
  user: UserUpdateOneRequiredInput
}

input InvoiceUpdateInput {
  address: AddressUpdateOneWithoutInvoicesInput
  creditTerm: String
  docId: String
  payment: PaymentUpdateOneWithoutInvoiceInput
  quotation: QuotationUpdateOneRequiredInput
  salesman: SalesmanUpdateOneRequiredWithoutInvoicesInput
  user: UserUpdateOneRequiredInput
}

input InvoiceUpdateManyDataInput {
  creditTerm: String
  docId: String
}

input InvoiceUpdateManyMutationInput {
  creditTerm: String
  docId: String
}

input InvoiceUpdateManyWithoutAddressInput {
  connect: [InvoiceWhereUniqueInput!]
  create: [InvoiceCreateWithoutAddressInput!]
  delete: [InvoiceWhereUniqueInput!]
  deleteMany: [InvoiceScalarWhereInput!]
  disconnect: [InvoiceWhereUniqueInput!]
  set: [InvoiceWhereUniqueInput!]
  update: [InvoiceUpdateWithWhereUniqueWithoutAddressInput!]
  updateMany: [InvoiceUpdateManyWithWhereNestedInput!]
  upsert: [InvoiceUpsertWithWhereUniqueWithoutAddressInput!]
}

input InvoiceUpdateManyWithoutSalesmanInput {
  connect: [InvoiceWhereUniqueInput!]
  create: [InvoiceCreateWithoutSalesmanInput!]
  delete: [InvoiceWhereUniqueInput!]
  deleteMany: [InvoiceScalarWhereInput!]
  disconnect: [InvoiceWhereUniqueInput!]
  set: [InvoiceWhereUniqueInput!]
  update: [InvoiceUpdateWithWhereUniqueWithoutSalesmanInput!]
  updateMany: [InvoiceUpdateManyWithWhereNestedInput!]
  upsert: [InvoiceUpsertWithWhereUniqueWithoutSalesmanInput!]
}

input InvoiceUpdateManyWithWhereNestedInput {
  data: InvoiceUpdateManyDataInput!
  where: InvoiceScalarWhereInput!
}

input InvoiceUpdateOneRequiredInput {
  connect: InvoiceWhereUniqueInput
  create: InvoiceCreateInput
  update: InvoiceUpdateDataInput
  upsert: InvoiceUpsertNestedInput
}

input InvoiceUpdateOneWithoutPaymentInput {
  connect: InvoiceWhereUniqueInput
  create: InvoiceCreateWithoutPaymentInput
  delete: Boolean
  disconnect: Boolean
  update: InvoiceUpdateWithoutPaymentDataInput
  upsert: InvoiceUpsertWithoutPaymentInput
}

input InvoiceUpdateWithoutAddressDataInput {
  creditTerm: String
  docId: String
  payment: PaymentUpdateOneWithoutInvoiceInput
  quotation: QuotationUpdateOneRequiredInput
  salesman: SalesmanUpdateOneRequiredWithoutInvoicesInput
  user: UserUpdateOneRequiredInput
}

input InvoiceUpdateWithoutPaymentDataInput {
  address: AddressUpdateOneWithoutInvoicesInput
  creditTerm: String
  docId: String
  quotation: QuotationUpdateOneRequiredInput
  salesman: SalesmanUpdateOneRequiredWithoutInvoicesInput
  user: UserUpdateOneRequiredInput
}

input InvoiceUpdateWithoutSalesmanDataInput {
  address: AddressUpdateOneWithoutInvoicesInput
  creditTerm: String
  docId: String
  payment: PaymentUpdateOneWithoutInvoiceInput
  quotation: QuotationUpdateOneRequiredInput
  user: UserUpdateOneRequiredInput
}

input InvoiceUpdateWithWhereUniqueWithoutAddressInput {
  data: InvoiceUpdateWithoutAddressDataInput!
  where: InvoiceWhereUniqueInput!
}

input InvoiceUpdateWithWhereUniqueWithoutSalesmanInput {
  data: InvoiceUpdateWithoutSalesmanDataInput!
  where: InvoiceWhereUniqueInput!
}

input InvoiceUpsertNestedInput {
  create: InvoiceCreateInput!
  update: InvoiceUpdateDataInput!
}

input InvoiceUpsertWithoutPaymentInput {
  create: InvoiceCreateWithoutPaymentInput!
  update: InvoiceUpdateWithoutPaymentDataInput!
}

input InvoiceUpsertWithWhereUniqueWithoutAddressInput {
  create: InvoiceCreateWithoutAddressInput!
  update: InvoiceUpdateWithoutAddressDataInput!
  where: InvoiceWhereUniqueInput!
}

input InvoiceUpsertWithWhereUniqueWithoutSalesmanInput {
  create: InvoiceCreateWithoutSalesmanInput!
  update: InvoiceUpdateWithoutSalesmanDataInput!
  where: InvoiceWhereUniqueInput!
}

input InvoiceWhereInput {
  address: AddressWhereInput
  AND: [InvoiceWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  creditTerm: String
  creditTerm_contains: String
  creditTerm_ends_with: String
  creditTerm_gt: String
  creditTerm_gte: String
  creditTerm_in: [String!]
  creditTerm_lt: String
  creditTerm_lte: String
  creditTerm_not: String
  creditTerm_not_contains: String
  creditTerm_not_ends_with: String
  creditTerm_not_in: [String!]
  creditTerm_not_starts_with: String
  creditTerm_starts_with: String
  docId: String
  docId_contains: String
  docId_ends_with: String
  docId_gt: String
  docId_gte: String
  docId_in: [String!]
  docId_lt: String
  docId_lte: String
  docId_not: String
  docId_not_contains: String
  docId_not_ends_with: String
  docId_not_in: [String!]
  docId_not_starts_with: String
  docId_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [InvoiceWhereInput!]
  OR: [InvoiceWhereInput!]
  payment: PaymentWhereInput
  quotation: QuotationWhereInput
  salesman: SalesmanWhereInput
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
  user: UserWhereInput
}

input InvoiceWhereUniqueInput {
  id: ID
}

scalar Long

type Me {
  token: String!
  user: User!
}

type Mutation {
  createAddress(data: AddressCreateInput!): Address!
  createCategory(data: CategoryCreateInput!): Category!
  createInvoice(data: InvoiceCreateInput!): Invoice!
  createPayment(data: PaymentCreateInput!): Payment!
  createProductItem(data: ProductItemCreateInput!): ProductItem!
  createQuotation(data: QuotationCreateInput!): Quotation!
  createQuotationItem(data: QuotationItemCreateInput!): QuotationItem!
  createSalesman(data: SalesmanCreateInput!): Salesman!
  createShipping(data: ShippingCreateInput!): Shipping!
  createShoppingCart(data: ShoppingCartCreateInput!): ShoppingCart!
  createShoppingCartItem(data: ShoppingCartItemCreateInput!): ShoppingCartItem!
  createUser(data: UserCreateInput!): User!
  deleteAddress(where: AddressWhereUniqueInput!): Address
  deleteCategory(where: CategoryWhereUniqueInput!): Category
  deleteInvoice(where: InvoiceWhereUniqueInput!): Invoice
  deleteManyAddresses(where: AddressWhereInput): BatchPayload!
  deleteManyCategories(where: CategoryWhereInput): BatchPayload!
  deleteManyInvoices(where: InvoiceWhereInput): BatchPayload!
  deleteManyPayments(where: PaymentWhereInput): BatchPayload!
  deleteManyProductItems(where: ProductItemWhereInput): BatchPayload!
  deleteManyQuotationItems(where: QuotationItemWhereInput): BatchPayload!
  deleteManyQuotations(where: QuotationWhereInput): BatchPayload!
  deleteManySalesmen(where: SalesmanWhereInput): BatchPayload!
  deleteManyShippings(where: ShippingWhereInput): BatchPayload!
  deleteManyShoppingCartItems(where: ShoppingCartItemWhereInput): BatchPayload!
  deleteManyShoppingCarts(where: ShoppingCartWhereInput): BatchPayload!
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  deletePayment(where: PaymentWhereUniqueInput!): Payment
  deleteProductItem(where: ProductItemWhereUniqueInput!): ProductItem
  deleteQuotation(where: QuotationWhereUniqueInput!): Quotation
  deleteQuotationItem(where: QuotationItemWhereUniqueInput!): QuotationItem
  deleteSalesman(where: SalesmanWhereUniqueInput!): Salesman
  deleteShipping(where: ShippingWhereUniqueInput!): Shipping
  deleteShoppingCart(where: ShoppingCartWhereUniqueInput!): ShoppingCart
  deleteShoppingCartItem(where: ShoppingCartItemWhereUniqueInput!): ShoppingCartItem
  deleteUser(where: UserWhereUniqueInput!): User
  login(email: String, password: String): Me
  register(data: UserCreateInput): Me
  updateAddress(data: AddressUpdateInput!, where: AddressWhereUniqueInput!): Address
  updateCategory(data: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category
  updateInvoice(data: InvoiceUpdateInput!, where: InvoiceWhereUniqueInput!): Invoice
  updateManyAddresses(data: AddressUpdateManyMutationInput!, where: AddressWhereInput): BatchPayload!
  updateManyCategories(data: CategoryUpdateManyMutationInput!, where: CategoryWhereInput): BatchPayload!
  updateManyInvoices(data: InvoiceUpdateManyMutationInput!, where: InvoiceWhereInput): BatchPayload!
  updateManyPayments(data: PaymentUpdateManyMutationInput!, where: PaymentWhereInput): BatchPayload!
  updateManyProductItems(data: ProductItemUpdateManyMutationInput!, where: ProductItemWhereInput): BatchPayload!
  updateManyQuotationItems(data: QuotationItemUpdateManyMutationInput!, where: QuotationItemWhereInput): BatchPayload!
  updateManyQuotations(data: QuotationUpdateManyMutationInput!, where: QuotationWhereInput): BatchPayload!
  updateManySalesmen(data: SalesmanUpdateManyMutationInput!, where: SalesmanWhereInput): BatchPayload!
  updateManyShippings(data: ShippingUpdateManyMutationInput!, where: ShippingWhereInput): BatchPayload!
  updateManyShoppingCartItems(data: ShoppingCartItemUpdateManyMutationInput!, where: ShoppingCartItemWhereInput): BatchPayload!
  updateManyShoppingCarts(data: ShoppingCartUpdateManyMutationInput!, where: ShoppingCartWhereInput): BatchPayload!
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  updatePayment(data: PaymentUpdateInput!, where: PaymentWhereUniqueInput!): Payment
  updateProductItem(data: ProductItemUpdateInput!, where: ProductItemWhereUniqueInput!): ProductItem
  updateQuotation(data: QuotationUpdateInput!, where: QuotationWhereUniqueInput!): Quotation
  updateQuotationItem(data: QuotationItemUpdateInput!, where: QuotationItemWhereUniqueInput!): QuotationItem
  updateSalesman(data: SalesmanUpdateInput!, where: SalesmanWhereUniqueInput!): Salesman
  updateShipping(data: ShippingUpdateInput!, where: ShippingWhereUniqueInput!): Shipping
  updateShoppingCart(data: ShoppingCartUpdateInput!, where: ShoppingCartWhereUniqueInput!): ShoppingCart
  updateShoppingCartItem(data: ShoppingCartItemUpdateInput!, where: ShoppingCartItemWhereUniqueInput!): ShoppingCartItem
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertAddress(create: AddressCreateInput!, update: AddressUpdateInput!, where: AddressWhereUniqueInput!): Address!
  upsertCategory(create: CategoryCreateInput!, update: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category!
  upsertInvoice(create: InvoiceCreateInput!, update: InvoiceUpdateInput!, where: InvoiceWhereUniqueInput!): Invoice!
  upsertPayment(create: PaymentCreateInput!, update: PaymentUpdateInput!, where: PaymentWhereUniqueInput!): Payment!
  upsertProductItem(create: ProductItemCreateInput!, update: ProductItemUpdateInput!, where: ProductItemWhereUniqueInput!): ProductItem!
  upsertQuotation(create: QuotationCreateInput!, update: QuotationUpdateInput!, where: QuotationWhereUniqueInput!): Quotation!
  upsertQuotationItem(create: QuotationItemCreateInput!, update: QuotationItemUpdateInput!, where: QuotationItemWhereUniqueInput!): QuotationItem!
  upsertSalesman(create: SalesmanCreateInput!, update: SalesmanUpdateInput!, where: SalesmanWhereUniqueInput!): Salesman!
  upsertShipping(create: ShippingCreateInput!, update: ShippingUpdateInput!, where: ShippingWhereUniqueInput!): Shipping!
  upsertShoppingCart(create: ShoppingCartCreateInput!, update: ShoppingCartUpdateInput!, where: ShoppingCartWhereUniqueInput!): ShoppingCart!
  upsertShoppingCartItem(create: ShoppingCartItemCreateInput!, update: ShoppingCartItemUpdateInput!, where: ShoppingCartItemWhereUniqueInput!): ShoppingCartItem!
  upsertUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Payment {
  amount: String!
  createdAt: DateTime!
  customer: User!
  docId: String!
  id: ID!
  Invoice: Invoice
  quotation: Quotation!
  salesman: Salesman!
  updatedAt: DateTime!
}

type PaymentConnection {
  aggregate: AggregatePayment!
  edges: [PaymentEdge!]!
  pageInfo: PageInfo!
}

input PaymentCreateInput {
  amount: String!
  customer: UserCreateOneWithoutPaymentsInput!
  docId: String!
  id: ID
  Invoice: InvoiceCreateOneWithoutPaymentInput
  quotation: QuotationCreateOneWithoutPaymentInput!
  salesman: SalesmanCreateOneWithoutPaymentsInput!
}

input PaymentCreateManyWithoutCustomerInput {
  connect: [PaymentWhereUniqueInput!]
  create: [PaymentCreateWithoutCustomerInput!]
}

input PaymentCreateManyWithoutSalesmanInput {
  connect: [PaymentWhereUniqueInput!]
  create: [PaymentCreateWithoutSalesmanInput!]
}

input PaymentCreateOneWithoutInvoiceInput {
  connect: PaymentWhereUniqueInput
  create: PaymentCreateWithoutInvoiceInput
}

input PaymentCreateOneWithoutQuotationInput {
  connect: PaymentWhereUniqueInput
  create: PaymentCreateWithoutQuotationInput
}

input PaymentCreateWithoutCustomerInput {
  amount: String!
  docId: String!
  id: ID
  Invoice: InvoiceCreateOneWithoutPaymentInput
  quotation: QuotationCreateOneWithoutPaymentInput!
  salesman: SalesmanCreateOneWithoutPaymentsInput!
}

input PaymentCreateWithoutInvoiceInput {
  amount: String!
  customer: UserCreateOneWithoutPaymentsInput!
  docId: String!
  id: ID
  quotation: QuotationCreateOneWithoutPaymentInput!
  salesman: SalesmanCreateOneWithoutPaymentsInput!
}

input PaymentCreateWithoutQuotationInput {
  amount: String!
  customer: UserCreateOneWithoutPaymentsInput!
  docId: String!
  id: ID
  Invoice: InvoiceCreateOneWithoutPaymentInput
  salesman: SalesmanCreateOneWithoutPaymentsInput!
}

input PaymentCreateWithoutSalesmanInput {
  amount: String!
  customer: UserCreateOneWithoutPaymentsInput!
  docId: String!
  id: ID
  Invoice: InvoiceCreateOneWithoutPaymentInput
  quotation: QuotationCreateOneWithoutPaymentInput!
}

type PaymentEdge {
  cursor: String!
  node: Payment!
}

enum PaymentOrderByInput {
  amount_ASC
  amount_DESC
  createdAt_ASC
  createdAt_DESC
  docId_ASC
  docId_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input PaymentScalarWhereInput {
  amount: String
  amount_contains: String
  amount_ends_with: String
  amount_gt: String
  amount_gte: String
  amount_in: [String!]
  amount_lt: String
  amount_lte: String
  amount_not: String
  amount_not_contains: String
  amount_not_ends_with: String
  amount_not_in: [String!]
  amount_not_starts_with: String
  amount_starts_with: String
  AND: [PaymentScalarWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  docId: String
  docId_contains: String
  docId_ends_with: String
  docId_gt: String
  docId_gte: String
  docId_in: [String!]
  docId_lt: String
  docId_lte: String
  docId_not: String
  docId_not_contains: String
  docId_not_ends_with: String
  docId_not_in: [String!]
  docId_not_starts_with: String
  docId_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [PaymentScalarWhereInput!]
  OR: [PaymentScalarWhereInput!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input PaymentUpdateInput {
  amount: String
  customer: UserUpdateOneRequiredWithoutPaymentsInput
  docId: String
  Invoice: InvoiceUpdateOneWithoutPaymentInput
  quotation: QuotationUpdateOneRequiredWithoutPaymentInput
  salesman: SalesmanUpdateOneRequiredWithoutPaymentsInput
}

input PaymentUpdateManyDataInput {
  amount: String
  docId: String
}

input PaymentUpdateManyMutationInput {
  amount: String
  docId: String
}

input PaymentUpdateManyWithoutCustomerInput {
  connect: [PaymentWhereUniqueInput!]
  create: [PaymentCreateWithoutCustomerInput!]
  delete: [PaymentWhereUniqueInput!]
  deleteMany: [PaymentScalarWhereInput!]
  disconnect: [PaymentWhereUniqueInput!]
  set: [PaymentWhereUniqueInput!]
  update: [PaymentUpdateWithWhereUniqueWithoutCustomerInput!]
  updateMany: [PaymentUpdateManyWithWhereNestedInput!]
  upsert: [PaymentUpsertWithWhereUniqueWithoutCustomerInput!]
}

input PaymentUpdateManyWithoutSalesmanInput {
  connect: [PaymentWhereUniqueInput!]
  create: [PaymentCreateWithoutSalesmanInput!]
  delete: [PaymentWhereUniqueInput!]
  deleteMany: [PaymentScalarWhereInput!]
  disconnect: [PaymentWhereUniqueInput!]
  set: [PaymentWhereUniqueInput!]
  update: [PaymentUpdateWithWhereUniqueWithoutSalesmanInput!]
  updateMany: [PaymentUpdateManyWithWhereNestedInput!]
  upsert: [PaymentUpsertWithWhereUniqueWithoutSalesmanInput!]
}

input PaymentUpdateManyWithWhereNestedInput {
  data: PaymentUpdateManyDataInput!
  where: PaymentScalarWhereInput!
}

input PaymentUpdateOneWithoutInvoiceInput {
  connect: PaymentWhereUniqueInput
  create: PaymentCreateWithoutInvoiceInput
  delete: Boolean
  disconnect: Boolean
  update: PaymentUpdateWithoutInvoiceDataInput
  upsert: PaymentUpsertWithoutInvoiceInput
}

input PaymentUpdateOneWithoutQuotationInput {
  connect: PaymentWhereUniqueInput
  create: PaymentCreateWithoutQuotationInput
  delete: Boolean
  disconnect: Boolean
  update: PaymentUpdateWithoutQuotationDataInput
  upsert: PaymentUpsertWithoutQuotationInput
}

input PaymentUpdateWithoutCustomerDataInput {
  amount: String
  docId: String
  Invoice: InvoiceUpdateOneWithoutPaymentInput
  quotation: QuotationUpdateOneRequiredWithoutPaymentInput
  salesman: SalesmanUpdateOneRequiredWithoutPaymentsInput
}

input PaymentUpdateWithoutInvoiceDataInput {
  amount: String
  customer: UserUpdateOneRequiredWithoutPaymentsInput
  docId: String
  quotation: QuotationUpdateOneRequiredWithoutPaymentInput
  salesman: SalesmanUpdateOneRequiredWithoutPaymentsInput
}

input PaymentUpdateWithoutQuotationDataInput {
  amount: String
  customer: UserUpdateOneRequiredWithoutPaymentsInput
  docId: String
  Invoice: InvoiceUpdateOneWithoutPaymentInput
  salesman: SalesmanUpdateOneRequiredWithoutPaymentsInput
}

input PaymentUpdateWithoutSalesmanDataInput {
  amount: String
  customer: UserUpdateOneRequiredWithoutPaymentsInput
  docId: String
  Invoice: InvoiceUpdateOneWithoutPaymentInput
  quotation: QuotationUpdateOneRequiredWithoutPaymentInput
}

input PaymentUpdateWithWhereUniqueWithoutCustomerInput {
  data: PaymentUpdateWithoutCustomerDataInput!
  where: PaymentWhereUniqueInput!
}

input PaymentUpdateWithWhereUniqueWithoutSalesmanInput {
  data: PaymentUpdateWithoutSalesmanDataInput!
  where: PaymentWhereUniqueInput!
}

input PaymentUpsertWithoutInvoiceInput {
  create: PaymentCreateWithoutInvoiceInput!
  update: PaymentUpdateWithoutInvoiceDataInput!
}

input PaymentUpsertWithoutQuotationInput {
  create: PaymentCreateWithoutQuotationInput!
  update: PaymentUpdateWithoutQuotationDataInput!
}

input PaymentUpsertWithWhereUniqueWithoutCustomerInput {
  create: PaymentCreateWithoutCustomerInput!
  update: PaymentUpdateWithoutCustomerDataInput!
  where: PaymentWhereUniqueInput!
}

input PaymentUpsertWithWhereUniqueWithoutSalesmanInput {
  create: PaymentCreateWithoutSalesmanInput!
  update: PaymentUpdateWithoutSalesmanDataInput!
  where: PaymentWhereUniqueInput!
}

input PaymentWhereInput {
  amount: String
  amount_contains: String
  amount_ends_with: String
  amount_gt: String
  amount_gte: String
  amount_in: [String!]
  amount_lt: String
  amount_lte: String
  amount_not: String
  amount_not_contains: String
  amount_not_ends_with: String
  amount_not_in: [String!]
  amount_not_starts_with: String
  amount_starts_with: String
  AND: [PaymentWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  customer: UserWhereInput
  docId: String
  docId_contains: String
  docId_ends_with: String
  docId_gt: String
  docId_gte: String
  docId_in: [String!]
  docId_lt: String
  docId_lte: String
  docId_not: String
  docId_not_contains: String
  docId_not_ends_with: String
  docId_not_in: [String!]
  docId_not_starts_with: String
  docId_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  Invoice: InvoiceWhereInput
  NOT: [PaymentWhereInput!]
  OR: [PaymentWhereInput!]
  quotation: QuotationWhereInput
  salesman: SalesmanWhereInput
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input PaymentWhereUniqueInput {
  id: ID
}

type ProductItem {
  amount: Int!
  brand: String!
  category: Category!
  createdAt: DateTime!
  description: String
  id: ID!
  image: String
  isPublished: Boolean!
  MenuDetail: String!
  name: String!
  price: String!
  quotation: Quotation
  relatedProduct(after: String, before: String, first: Int, last: Int, orderBy: ProductItemOrderByInput, skip: Int, where: ProductItemWhereInput): [ProductItem!]
  salePrice: String!
  shoppingCart: ShoppingCart
  TermDetail: String!
  unitType: String!
  updatedAt: DateTime!
}

type ProductItemConnection {
  aggregate: AggregateProductItem!
  edges: [ProductItemEdge!]!
  pageInfo: PageInfo!
}

input ProductItemCreateInput {
  amount: Int!
  brand: String!
  category: CategoryCreateOneWithoutProductItemInput!
  description: String
  id: ID
  image: String
  isPublished: Boolean
  MenuDetail: String!
  name: String!
  price: String!
  quotation: QuotationCreateOneInput
  relatedProduct: ProductItemCreateManyInput
  salePrice: String!
  shoppingCart: ShoppingCartCreateOneInput
  TermDetail: String!
  unitType: String!
}

input ProductItemCreateManyInput {
  connect: [ProductItemWhereUniqueInput!]
  create: [ProductItemCreateInput!]
}

input ProductItemCreateManyWithoutCategoryInput {
  connect: [ProductItemWhereUniqueInput!]
  create: [ProductItemCreateWithoutCategoryInput!]
}

input ProductItemCreateOneInput {
  connect: ProductItemWhereUniqueInput
  create: ProductItemCreateInput
}

input ProductItemCreateWithoutCategoryInput {
  amount: Int!
  brand: String!
  description: String
  id: ID
  image: String
  isPublished: Boolean
  MenuDetail: String!
  name: String!
  price: String!
  quotation: QuotationCreateOneInput
  relatedProduct: ProductItemCreateManyInput
  salePrice: String!
  shoppingCart: ShoppingCartCreateOneInput
  TermDetail: String!
  unitType: String!
}

type ProductItemEdge {
  cursor: String!
  node: ProductItem!
}

enum ProductItemOrderByInput {
  amount_ASC
  amount_DESC
  brand_ASC
  brand_DESC
  createdAt_ASC
  createdAt_DESC
  description_ASC
  description_DESC
  id_ASC
  id_DESC
  image_ASC
  image_DESC
  isPublished_ASC
  isPublished_DESC
  MenuDetail_ASC
  MenuDetail_DESC
  name_ASC
  name_DESC
  price_ASC
  price_DESC
  salePrice_ASC
  salePrice_DESC
  TermDetail_ASC
  TermDetail_DESC
  unitType_ASC
  unitType_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input ProductItemScalarWhereInput {
  amount: Int
  amount_gt: Int
  amount_gte: Int
  amount_in: [Int!]
  amount_lt: Int
  amount_lte: Int
  amount_not: Int
  amount_not_in: [Int!]
  AND: [ProductItemScalarWhereInput!]
  brand: String
  brand_contains: String
  brand_ends_with: String
  brand_gt: String
  brand_gte: String
  brand_in: [String!]
  brand_lt: String
  brand_lte: String
  brand_not: String
  brand_not_contains: String
  brand_not_ends_with: String
  brand_not_in: [String!]
  brand_not_starts_with: String
  brand_starts_with: String
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  description: String
  description_contains: String
  description_ends_with: String
  description_gt: String
  description_gte: String
  description_in: [String!]
  description_lt: String
  description_lte: String
  description_not: String
  description_not_contains: String
  description_not_ends_with: String
  description_not_in: [String!]
  description_not_starts_with: String
  description_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  image: String
  image_contains: String
  image_ends_with: String
  image_gt: String
  image_gte: String
  image_in: [String!]
  image_lt: String
  image_lte: String
  image_not: String
  image_not_contains: String
  image_not_ends_with: String
  image_not_in: [String!]
  image_not_starts_with: String
  image_starts_with: String
  isPublished: Boolean
  isPublished_not: Boolean
  MenuDetail: String
  MenuDetail_contains: String
  MenuDetail_ends_with: String
  MenuDetail_gt: String
  MenuDetail_gte: String
  MenuDetail_in: [String!]
  MenuDetail_lt: String
  MenuDetail_lte: String
  MenuDetail_not: String
  MenuDetail_not_contains: String
  MenuDetail_not_ends_with: String
  MenuDetail_not_in: [String!]
  MenuDetail_not_starts_with: String
  MenuDetail_starts_with: String
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [ProductItemScalarWhereInput!]
  OR: [ProductItemScalarWhereInput!]
  price: String
  price_contains: String
  price_ends_with: String
  price_gt: String
  price_gte: String
  price_in: [String!]
  price_lt: String
  price_lte: String
  price_not: String
  price_not_contains: String
  price_not_ends_with: String
  price_not_in: [String!]
  price_not_starts_with: String
  price_starts_with: String
  salePrice: String
  salePrice_contains: String
  salePrice_ends_with: String
  salePrice_gt: String
  salePrice_gte: String
  salePrice_in: [String!]
  salePrice_lt: String
  salePrice_lte: String
  salePrice_not: String
  salePrice_not_contains: String
  salePrice_not_ends_with: String
  salePrice_not_in: [String!]
  salePrice_not_starts_with: String
  salePrice_starts_with: String
  TermDetail: String
  TermDetail_contains: String
  TermDetail_ends_with: String
  TermDetail_gt: String
  TermDetail_gte: String
  TermDetail_in: [String!]
  TermDetail_lt: String
  TermDetail_lte: String
  TermDetail_not: String
  TermDetail_not_contains: String
  TermDetail_not_ends_with: String
  TermDetail_not_in: [String!]
  TermDetail_not_starts_with: String
  TermDetail_starts_with: String
  unitType: String
  unitType_contains: String
  unitType_ends_with: String
  unitType_gt: String
  unitType_gte: String
  unitType_in: [String!]
  unitType_lt: String
  unitType_lte: String
  unitType_not: String
  unitType_not_contains: String
  unitType_not_ends_with: String
  unitType_not_in: [String!]
  unitType_not_starts_with: String
  unitType_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input ProductItemUpdateDataInput {
  amount: Int
  brand: String
  category: CategoryUpdateOneRequiredWithoutProductItemInput
  description: String
  image: String
  isPublished: Boolean
  MenuDetail: String
  name: String
  price: String
  quotation: QuotationUpdateOneInput
  relatedProduct: ProductItemUpdateManyInput
  salePrice: String
  shoppingCart: ShoppingCartUpdateOneInput
  TermDetail: String
  unitType: String
}

input ProductItemUpdateInput {
  amount: Int
  brand: String
  category: CategoryUpdateOneRequiredWithoutProductItemInput
  description: String
  image: String
  isPublished: Boolean
  MenuDetail: String
  name: String
  price: String
  quotation: QuotationUpdateOneInput
  relatedProduct: ProductItemUpdateManyInput
  salePrice: String
  shoppingCart: ShoppingCartUpdateOneInput
  TermDetail: String
  unitType: String
}

input ProductItemUpdateManyDataInput {
  amount: Int
  brand: String
  description: String
  image: String
  isPublished: Boolean
  MenuDetail: String
  name: String
  price: String
  salePrice: String
  TermDetail: String
  unitType: String
}

input ProductItemUpdateManyInput {
  connect: [ProductItemWhereUniqueInput!]
  create: [ProductItemCreateInput!]
  delete: [ProductItemWhereUniqueInput!]
  deleteMany: [ProductItemScalarWhereInput!]
  disconnect: [ProductItemWhereUniqueInput!]
  set: [ProductItemWhereUniqueInput!]
  update: [ProductItemUpdateWithWhereUniqueNestedInput!]
  updateMany: [ProductItemUpdateManyWithWhereNestedInput!]
  upsert: [ProductItemUpsertWithWhereUniqueNestedInput!]
}

input ProductItemUpdateManyMutationInput {
  amount: Int
  brand: String
  description: String
  image: String
  isPublished: Boolean
  MenuDetail: String
  name: String
  price: String
  salePrice: String
  TermDetail: String
  unitType: String
}

input ProductItemUpdateManyWithoutCategoryInput {
  connect: [ProductItemWhereUniqueInput!]
  create: [ProductItemCreateWithoutCategoryInput!]
  delete: [ProductItemWhereUniqueInput!]
  deleteMany: [ProductItemScalarWhereInput!]
  disconnect: [ProductItemWhereUniqueInput!]
  set: [ProductItemWhereUniqueInput!]
  update: [ProductItemUpdateWithWhereUniqueWithoutCategoryInput!]
  updateMany: [ProductItemUpdateManyWithWhereNestedInput!]
  upsert: [ProductItemUpsertWithWhereUniqueWithoutCategoryInput!]
}

input ProductItemUpdateManyWithWhereNestedInput {
  data: ProductItemUpdateManyDataInput!
  where: ProductItemScalarWhereInput!
}

input ProductItemUpdateOneRequiredInput {
  connect: ProductItemWhereUniqueInput
  create: ProductItemCreateInput
  update: ProductItemUpdateDataInput
  upsert: ProductItemUpsertNestedInput
}

input ProductItemUpdateWithoutCategoryDataInput {
  amount: Int
  brand: String
  description: String
  image: String
  isPublished: Boolean
  MenuDetail: String
  name: String
  price: String
  quotation: QuotationUpdateOneInput
  relatedProduct: ProductItemUpdateManyInput
  salePrice: String
  shoppingCart: ShoppingCartUpdateOneInput
  TermDetail: String
  unitType: String
}

input ProductItemUpdateWithWhereUniqueNestedInput {
  data: ProductItemUpdateDataInput!
  where: ProductItemWhereUniqueInput!
}

input ProductItemUpdateWithWhereUniqueWithoutCategoryInput {
  data: ProductItemUpdateWithoutCategoryDataInput!
  where: ProductItemWhereUniqueInput!
}

input ProductItemUpsertNestedInput {
  create: ProductItemCreateInput!
  update: ProductItemUpdateDataInput!
}

input ProductItemUpsertWithWhereUniqueNestedInput {
  create: ProductItemCreateInput!
  update: ProductItemUpdateDataInput!
  where: ProductItemWhereUniqueInput!
}

input ProductItemUpsertWithWhereUniqueWithoutCategoryInput {
  create: ProductItemCreateWithoutCategoryInput!
  update: ProductItemUpdateWithoutCategoryDataInput!
  where: ProductItemWhereUniqueInput!
}

input ProductItemWhereInput {
  amount: Int
  amount_gt: Int
  amount_gte: Int
  amount_in: [Int!]
  amount_lt: Int
  amount_lte: Int
  amount_not: Int
  amount_not_in: [Int!]
  AND: [ProductItemWhereInput!]
  brand: String
  brand_contains: String
  brand_ends_with: String
  brand_gt: String
  brand_gte: String
  brand_in: [String!]
  brand_lt: String
  brand_lte: String
  brand_not: String
  brand_not_contains: String
  brand_not_ends_with: String
  brand_not_in: [String!]
  brand_not_starts_with: String
  brand_starts_with: String
  category: CategoryWhereInput
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  description: String
  description_contains: String
  description_ends_with: String
  description_gt: String
  description_gte: String
  description_in: [String!]
  description_lt: String
  description_lte: String
  description_not: String
  description_not_contains: String
  description_not_ends_with: String
  description_not_in: [String!]
  description_not_starts_with: String
  description_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  image: String
  image_contains: String
  image_ends_with: String
  image_gt: String
  image_gte: String
  image_in: [String!]
  image_lt: String
  image_lte: String
  image_not: String
  image_not_contains: String
  image_not_ends_with: String
  image_not_in: [String!]
  image_not_starts_with: String
  image_starts_with: String
  isPublished: Boolean
  isPublished_not: Boolean
  MenuDetail: String
  MenuDetail_contains: String
  MenuDetail_ends_with: String
  MenuDetail_gt: String
  MenuDetail_gte: String
  MenuDetail_in: [String!]
  MenuDetail_lt: String
  MenuDetail_lte: String
  MenuDetail_not: String
  MenuDetail_not_contains: String
  MenuDetail_not_ends_with: String
  MenuDetail_not_in: [String!]
  MenuDetail_not_starts_with: String
  MenuDetail_starts_with: String
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [ProductItemWhereInput!]
  OR: [ProductItemWhereInput!]
  price: String
  price_contains: String
  price_ends_with: String
  price_gt: String
  price_gte: String
  price_in: [String!]
  price_lt: String
  price_lte: String
  price_not: String
  price_not_contains: String
  price_not_ends_with: String
  price_not_in: [String!]
  price_not_starts_with: String
  price_starts_with: String
  quotation: QuotationWhereInput
  relatedProduct_every: ProductItemWhereInput
  relatedProduct_none: ProductItemWhereInput
  relatedProduct_some: ProductItemWhereInput
  salePrice: String
  salePrice_contains: String
  salePrice_ends_with: String
  salePrice_gt: String
  salePrice_gte: String
  salePrice_in: [String!]
  salePrice_lt: String
  salePrice_lte: String
  salePrice_not: String
  salePrice_not_contains: String
  salePrice_not_ends_with: String
  salePrice_not_in: [String!]
  salePrice_not_starts_with: String
  salePrice_starts_with: String
  shoppingCart: ShoppingCartWhereInput
  TermDetail: String
  TermDetail_contains: String
  TermDetail_ends_with: String
  TermDetail_gt: String
  TermDetail_gte: String
  TermDetail_in: [String!]
  TermDetail_lt: String
  TermDetail_lte: String
  TermDetail_not: String
  TermDetail_not_contains: String
  TermDetail_not_ends_with: String
  TermDetail_not_in: [String!]
  TermDetail_not_starts_with: String
  TermDetail_starts_with: String
  unitType: String
  unitType_contains: String
  unitType_ends_with: String
  unitType_gt: String
  unitType_gte: String
  unitType_in: [String!]
  unitType_lt: String
  unitType_lte: String
  unitType_not: String
  unitType_not_contains: String
  unitType_not_ends_with: String
  unitType_not_in: [String!]
  unitType_not_starts_with: String
  unitType_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input ProductItemWhereUniqueInput {
  id: ID
}

type Query {
  address(where: AddressWhereUniqueInput!): Address
  addresses(after: String, before: String, first: Int, last: Int, orderBy: AddressOrderByInput, skip: Int, where: AddressWhereInput): [Address!]!
  addressesConnection(after: String, before: String, first: Int, last: Int, orderBy: AddressOrderByInput, skip: Int, where: AddressWhereInput): AddressConnection!
  categories(after: String, before: String, first: Int, last: Int, orderBy: CategoryOrderByInput, skip: Int, where: CategoryWhereInput): [Category!]!
  categoriesConnection(after: String, before: String, first: Int, last: Int, orderBy: CategoryOrderByInput, skip: Int, where: CategoryWhereInput): CategoryConnection!
  category(where: CategoryWhereUniqueInput!): Category
  invoice(where: InvoiceWhereUniqueInput!): Invoice
  invoices(after: String, before: String, first: Int, last: Int, orderBy: InvoiceOrderByInput, skip: Int, where: InvoiceWhereInput): [Invoice!]!
  invoicesConnection(after: String, before: String, first: Int, last: Int, orderBy: InvoiceOrderByInput, skip: Int, where: InvoiceWhereInput): InvoiceConnection!
  me: User
  payment(where: PaymentWhereUniqueInput!): Payment
  payments(after: String, before: String, first: Int, last: Int, orderBy: PaymentOrderByInput, skip: Int, where: PaymentWhereInput): [Payment!]!
  paymentsConnection(after: String, before: String, first: Int, last: Int, orderBy: PaymentOrderByInput, skip: Int, where: PaymentWhereInput): PaymentConnection!
  productItem(where: ProductItemWhereUniqueInput!): ProductItem
  productItems(after: String, before: String, first: Int, last: Int, orderBy: ProductItemOrderByInput, skip: Int, where: ProductItemWhereInput): [ProductItem!]!
  productItemsConnection(after: String, before: String, first: Int, last: Int, orderBy: ProductItemOrderByInput, skip: Int, where: ProductItemWhereInput): ProductItemConnection!
  quotation(where: QuotationWhereUniqueInput!): Quotation
  quotationItem(where: QuotationItemWhereUniqueInput!): QuotationItem
  quotationItems(after: String, before: String, first: Int, last: Int, orderBy: QuotationItemOrderByInput, skip: Int, where: QuotationItemWhereInput): [QuotationItem!]!
  quotationItemsConnection(after: String, before: String, first: Int, last: Int, orderBy: QuotationItemOrderByInput, skip: Int, where: QuotationItemWhereInput): QuotationItemConnection!
  quotations(after: String, before: String, first: Int, last: Int, orderBy: QuotationOrderByInput, skip: Int, where: QuotationWhereInput): [Quotation!]!
  quotationsConnection(after: String, before: String, first: Int, last: Int, orderBy: QuotationOrderByInput, skip: Int, where: QuotationWhereInput): QuotationConnection!
  salesman(where: SalesmanWhereUniqueInput!): Salesman
  salesmen(after: String, before: String, first: Int, last: Int, orderBy: SalesmanOrderByInput, skip: Int, where: SalesmanWhereInput): [Salesman!]!
  salesmenConnection(after: String, before: String, first: Int, last: Int, orderBy: SalesmanOrderByInput, skip: Int, where: SalesmanWhereInput): SalesmanConnection!
  shipping(where: ShippingWhereUniqueInput!): Shipping
  shippings(after: String, before: String, first: Int, last: Int, orderBy: ShippingOrderByInput, skip: Int, where: ShippingWhereInput): [Shipping!]!
  shippingsConnection(after: String, before: String, first: Int, last: Int, orderBy: ShippingOrderByInput, skip: Int, where: ShippingWhereInput): ShippingConnection!
  shoppingCart(where: ShoppingCartWhereUniqueInput!): ShoppingCart
  shoppingCartItem(where: ShoppingCartItemWhereUniqueInput!): ShoppingCartItem
  shoppingCartItems(after: String, before: String, first: Int, last: Int, orderBy: ShoppingCartItemOrderByInput, skip: Int, where: ShoppingCartItemWhereInput): [ShoppingCartItem!]!
  shoppingCartItemsConnection(after: String, before: String, first: Int, last: Int, orderBy: ShoppingCartItemOrderByInput, skip: Int, where: ShoppingCartItemWhereInput): ShoppingCartItemConnection!
  shoppingCarts(after: String, before: String, first: Int, last: Int, orderBy: ShoppingCartOrderByInput, skip: Int, where: ShoppingCartWhereInput): [ShoppingCart!]!
  shoppingCartsConnection(after: String, before: String, first: Int, last: Int, orderBy: ShoppingCartOrderByInput, skip: Int, where: ShoppingCartWhereInput): ShoppingCartConnection!
  user(where: UserWhereUniqueInput!): User
  users(after: String, before: String, first: Int, last: Int, orderBy: UserOrderByInput, skip: Int, where: UserWhereInput): [User!]!
  usersConnection(after: String, before: String, first: Int, last: Int, orderBy: UserOrderByInput, skip: Int, where: UserWhereInput): UserConnection!
}

type Quotation {
  createdAt: DateTime!
  customer: User!
  docId: String
  id: ID!
  payment: Payment
  quotationItem(after: String, before: String, first: Int, last: Int, orderBy: QuotationItemOrderByInput, skip: Int, where: QuotationItemWhereInput): [QuotationItem!]
  salesman: Salesman
  shipping: Shipping
  updatedAt: DateTime!
}

type QuotationConnection {
  aggregate: AggregateQuotation!
  edges: [QuotationEdge!]!
  pageInfo: PageInfo!
}

input QuotationCreateInput {
  customer: UserCreateOneWithoutQuotationsInput!
  docId: String
  id: ID
  payment: PaymentCreateOneWithoutQuotationInput
  quotationItem: QuotationItemCreateManyWithoutQuotationInput
  salesman: SalesmanCreateOneWithoutQuotationsInput
  shipping: ShippingCreateOneWithoutQuotationInput
}

input QuotationCreateManyWithoutCustomerInput {
  connect: [QuotationWhereUniqueInput!]
  create: [QuotationCreateWithoutCustomerInput!]
}

input QuotationCreateManyWithoutSalesmanInput {
  connect: [QuotationWhereUniqueInput!]
  create: [QuotationCreateWithoutSalesmanInput!]
}

input QuotationCreateOneInput {
  connect: QuotationWhereUniqueInput
  create: QuotationCreateInput
}

input QuotationCreateOneWithoutPaymentInput {
  connect: QuotationWhereUniqueInput
  create: QuotationCreateWithoutPaymentInput
}

input QuotationCreateOneWithoutQuotationItemInput {
  connect: QuotationWhereUniqueInput
  create: QuotationCreateWithoutQuotationItemInput
}

input QuotationCreateOneWithoutShippingInput {
  connect: QuotationWhereUniqueInput
  create: QuotationCreateWithoutShippingInput
}

input QuotationCreateWithoutCustomerInput {
  docId: String
  id: ID
  payment: PaymentCreateOneWithoutQuotationInput
  quotationItem: QuotationItemCreateManyWithoutQuotationInput
  salesman: SalesmanCreateOneWithoutQuotationsInput
  shipping: ShippingCreateOneWithoutQuotationInput
}

input QuotationCreateWithoutPaymentInput {
  customer: UserCreateOneWithoutQuotationsInput!
  docId: String
  id: ID
  quotationItem: QuotationItemCreateManyWithoutQuotationInput
  salesman: SalesmanCreateOneWithoutQuotationsInput
  shipping: ShippingCreateOneWithoutQuotationInput
}

input QuotationCreateWithoutQuotationItemInput {
  customer: UserCreateOneWithoutQuotationsInput!
  docId: String
  id: ID
  payment: PaymentCreateOneWithoutQuotationInput
  salesman: SalesmanCreateOneWithoutQuotationsInput
  shipping: ShippingCreateOneWithoutQuotationInput
}

input QuotationCreateWithoutSalesmanInput {
  customer: UserCreateOneWithoutQuotationsInput!
  docId: String
  id: ID
  payment: PaymentCreateOneWithoutQuotationInput
  quotationItem: QuotationItemCreateManyWithoutQuotationInput
  shipping: ShippingCreateOneWithoutQuotationInput
}

input QuotationCreateWithoutShippingInput {
  customer: UserCreateOneWithoutQuotationsInput!
  docId: String
  id: ID
  payment: PaymentCreateOneWithoutQuotationInput
  quotationItem: QuotationItemCreateManyWithoutQuotationInput
  salesman: SalesmanCreateOneWithoutQuotationsInput
}

type QuotationEdge {
  cursor: String!
  node: Quotation!
}

type QuotationItem {
  amount: Int!
  id: ID!
  key: String!
  product: ProductItem!
  quotation: Quotation!
  realPrice: Float!
}

type QuotationItemConnection {
  aggregate: AggregateQuotationItem!
  edges: [QuotationItemEdge!]!
  pageInfo: PageInfo!
}

input QuotationItemCreateInput {
  amount: Int!
  id: ID
  key: String!
  product: ProductItemCreateOneInput!
  quotation: QuotationCreateOneWithoutQuotationItemInput!
  realPrice: Float!
}

input QuotationItemCreateManyWithoutQuotationInput {
  connect: [QuotationItemWhereUniqueInput!]
  create: [QuotationItemCreateWithoutQuotationInput!]
}

input QuotationItemCreateWithoutQuotationInput {
  amount: Int!
  id: ID
  key: String!
  product: ProductItemCreateOneInput!
  realPrice: Float!
}

type QuotationItemEdge {
  cursor: String!
  node: QuotationItem!
}

enum QuotationItemOrderByInput {
  amount_ASC
  amount_DESC
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  key_ASC
  key_DESC
  realPrice_ASC
  realPrice_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input QuotationItemScalarWhereInput {
  amount: Int
  amount_gt: Int
  amount_gte: Int
  amount_in: [Int!]
  amount_lt: Int
  amount_lte: Int
  amount_not: Int
  amount_not_in: [Int!]
  AND: [QuotationItemScalarWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  key: String
  key_contains: String
  key_ends_with: String
  key_gt: String
  key_gte: String
  key_in: [String!]
  key_lt: String
  key_lte: String
  key_not: String
  key_not_contains: String
  key_not_ends_with: String
  key_not_in: [String!]
  key_not_starts_with: String
  key_starts_with: String
  NOT: [QuotationItemScalarWhereInput!]
  OR: [QuotationItemScalarWhereInput!]
  realPrice: Float
  realPrice_gt: Float
  realPrice_gte: Float
  realPrice_in: [Float!]
  realPrice_lt: Float
  realPrice_lte: Float
  realPrice_not: Float
  realPrice_not_in: [Float!]
}

input QuotationItemUpdateInput {
  amount: Int
  key: String
  product: ProductItemUpdateOneRequiredInput
  quotation: QuotationUpdateOneRequiredWithoutQuotationItemInput
  realPrice: Float
}

input QuotationItemUpdateManyDataInput {
  amount: Int
  key: String
  realPrice: Float
}

input QuotationItemUpdateManyMutationInput {
  amount: Int
  key: String
  realPrice: Float
}

input QuotationItemUpdateManyWithoutQuotationInput {
  connect: [QuotationItemWhereUniqueInput!]
  create: [QuotationItemCreateWithoutQuotationInput!]
  delete: [QuotationItemWhereUniqueInput!]
  deleteMany: [QuotationItemScalarWhereInput!]
  disconnect: [QuotationItemWhereUniqueInput!]
  set: [QuotationItemWhereUniqueInput!]
  update: [QuotationItemUpdateWithWhereUniqueWithoutQuotationInput!]
  updateMany: [QuotationItemUpdateManyWithWhereNestedInput!]
  upsert: [QuotationItemUpsertWithWhereUniqueWithoutQuotationInput!]
}

input QuotationItemUpdateManyWithWhereNestedInput {
  data: QuotationItemUpdateManyDataInput!
  where: QuotationItemScalarWhereInput!
}

input QuotationItemUpdateWithoutQuotationDataInput {
  amount: Int
  key: String
  product: ProductItemUpdateOneRequiredInput
  realPrice: Float
}

input QuotationItemUpdateWithWhereUniqueWithoutQuotationInput {
  data: QuotationItemUpdateWithoutQuotationDataInput!
  where: QuotationItemWhereUniqueInput!
}

input QuotationItemUpsertWithWhereUniqueWithoutQuotationInput {
  create: QuotationItemCreateWithoutQuotationInput!
  update: QuotationItemUpdateWithoutQuotationDataInput!
  where: QuotationItemWhereUniqueInput!
}

input QuotationItemWhereInput {
  amount: Int
  amount_gt: Int
  amount_gte: Int
  amount_in: [Int!]
  amount_lt: Int
  amount_lte: Int
  amount_not: Int
  amount_not_in: [Int!]
  AND: [QuotationItemWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  key: String
  key_contains: String
  key_ends_with: String
  key_gt: String
  key_gte: String
  key_in: [String!]
  key_lt: String
  key_lte: String
  key_not: String
  key_not_contains: String
  key_not_ends_with: String
  key_not_in: [String!]
  key_not_starts_with: String
  key_starts_with: String
  NOT: [QuotationItemWhereInput!]
  OR: [QuotationItemWhereInput!]
  product: ProductItemWhereInput
  quotation: QuotationWhereInput
  realPrice: Float
  realPrice_gt: Float
  realPrice_gte: Float
  realPrice_in: [Float!]
  realPrice_lt: Float
  realPrice_lte: Float
  realPrice_not: Float
  realPrice_not_in: [Float!]
}

input QuotationItemWhereUniqueInput {
  id: ID
  key: String
}

enum QuotationOrderByInput {
  createdAt_ASC
  createdAt_DESC
  docId_ASC
  docId_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input QuotationScalarWhereInput {
  AND: [QuotationScalarWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  docId: String
  docId_contains: String
  docId_ends_with: String
  docId_gt: String
  docId_gte: String
  docId_in: [String!]
  docId_lt: String
  docId_lte: String
  docId_not: String
  docId_not_contains: String
  docId_not_ends_with: String
  docId_not_in: [String!]
  docId_not_starts_with: String
  docId_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [QuotationScalarWhereInput!]
  OR: [QuotationScalarWhereInput!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input QuotationUpdateDataInput {
  customer: UserUpdateOneRequiredWithoutQuotationsInput
  docId: String
  payment: PaymentUpdateOneWithoutQuotationInput
  quotationItem: QuotationItemUpdateManyWithoutQuotationInput
  salesman: SalesmanUpdateOneWithoutQuotationsInput
  shipping: ShippingUpdateOneWithoutQuotationInput
}

input QuotationUpdateInput {
  customer: UserUpdateOneRequiredWithoutQuotationsInput
  docId: String
  payment: PaymentUpdateOneWithoutQuotationInput
  quotationItem: QuotationItemUpdateManyWithoutQuotationInput
  salesman: SalesmanUpdateOneWithoutQuotationsInput
  shipping: ShippingUpdateOneWithoutQuotationInput
}

input QuotationUpdateManyDataInput {
  docId: String
}

input QuotationUpdateManyMutationInput {
  docId: String
}

input QuotationUpdateManyWithoutCustomerInput {
  connect: [QuotationWhereUniqueInput!]
  create: [QuotationCreateWithoutCustomerInput!]
  delete: [QuotationWhereUniqueInput!]
  deleteMany: [QuotationScalarWhereInput!]
  disconnect: [QuotationWhereUniqueInput!]
  set: [QuotationWhereUniqueInput!]
  update: [QuotationUpdateWithWhereUniqueWithoutCustomerInput!]
  updateMany: [QuotationUpdateManyWithWhereNestedInput!]
  upsert: [QuotationUpsertWithWhereUniqueWithoutCustomerInput!]
}

input QuotationUpdateManyWithoutSalesmanInput {
  connect: [QuotationWhereUniqueInput!]
  create: [QuotationCreateWithoutSalesmanInput!]
  delete: [QuotationWhereUniqueInput!]
  deleteMany: [QuotationScalarWhereInput!]
  disconnect: [QuotationWhereUniqueInput!]
  set: [QuotationWhereUniqueInput!]
  update: [QuotationUpdateWithWhereUniqueWithoutSalesmanInput!]
  updateMany: [QuotationUpdateManyWithWhereNestedInput!]
  upsert: [QuotationUpsertWithWhereUniqueWithoutSalesmanInput!]
}

input QuotationUpdateManyWithWhereNestedInput {
  data: QuotationUpdateManyDataInput!
  where: QuotationScalarWhereInput!
}

input QuotationUpdateOneInput {
  connect: QuotationWhereUniqueInput
  create: QuotationCreateInput
  delete: Boolean
  disconnect: Boolean
  update: QuotationUpdateDataInput
  upsert: QuotationUpsertNestedInput
}

input QuotationUpdateOneRequiredInput {
  connect: QuotationWhereUniqueInput
  create: QuotationCreateInput
  update: QuotationUpdateDataInput
  upsert: QuotationUpsertNestedInput
}

input QuotationUpdateOneRequiredWithoutPaymentInput {
  connect: QuotationWhereUniqueInput
  create: QuotationCreateWithoutPaymentInput
  update: QuotationUpdateWithoutPaymentDataInput
  upsert: QuotationUpsertWithoutPaymentInput
}

input QuotationUpdateOneRequiredWithoutQuotationItemInput {
  connect: QuotationWhereUniqueInput
  create: QuotationCreateWithoutQuotationItemInput
  update: QuotationUpdateWithoutQuotationItemDataInput
  upsert: QuotationUpsertWithoutQuotationItemInput
}

input QuotationUpdateOneRequiredWithoutShippingInput {
  connect: QuotationWhereUniqueInput
  create: QuotationCreateWithoutShippingInput
  update: QuotationUpdateWithoutShippingDataInput
  upsert: QuotationUpsertWithoutShippingInput
}

input QuotationUpdateWithoutCustomerDataInput {
  docId: String
  payment: PaymentUpdateOneWithoutQuotationInput
  quotationItem: QuotationItemUpdateManyWithoutQuotationInput
  salesman: SalesmanUpdateOneWithoutQuotationsInput
  shipping: ShippingUpdateOneWithoutQuotationInput
}

input QuotationUpdateWithoutPaymentDataInput {
  customer: UserUpdateOneRequiredWithoutQuotationsInput
  docId: String
  quotationItem: QuotationItemUpdateManyWithoutQuotationInput
  salesman: SalesmanUpdateOneWithoutQuotationsInput
  shipping: ShippingUpdateOneWithoutQuotationInput
}

input QuotationUpdateWithoutQuotationItemDataInput {
  customer: UserUpdateOneRequiredWithoutQuotationsInput
  docId: String
  payment: PaymentUpdateOneWithoutQuotationInput
  salesman: SalesmanUpdateOneWithoutQuotationsInput
  shipping: ShippingUpdateOneWithoutQuotationInput
}

input QuotationUpdateWithoutSalesmanDataInput {
  customer: UserUpdateOneRequiredWithoutQuotationsInput
  docId: String
  payment: PaymentUpdateOneWithoutQuotationInput
  quotationItem: QuotationItemUpdateManyWithoutQuotationInput
  shipping: ShippingUpdateOneWithoutQuotationInput
}

input QuotationUpdateWithoutShippingDataInput {
  customer: UserUpdateOneRequiredWithoutQuotationsInput
  docId: String
  payment: PaymentUpdateOneWithoutQuotationInput
  quotationItem: QuotationItemUpdateManyWithoutQuotationInput
  salesman: SalesmanUpdateOneWithoutQuotationsInput
}

input QuotationUpdateWithWhereUniqueWithoutCustomerInput {
  data: QuotationUpdateWithoutCustomerDataInput!
  where: QuotationWhereUniqueInput!
}

input QuotationUpdateWithWhereUniqueWithoutSalesmanInput {
  data: QuotationUpdateWithoutSalesmanDataInput!
  where: QuotationWhereUniqueInput!
}

input QuotationUpsertNestedInput {
  create: QuotationCreateInput!
  update: QuotationUpdateDataInput!
}

input QuotationUpsertWithoutPaymentInput {
  create: QuotationCreateWithoutPaymentInput!
  update: QuotationUpdateWithoutPaymentDataInput!
}

input QuotationUpsertWithoutQuotationItemInput {
  create: QuotationCreateWithoutQuotationItemInput!
  update: QuotationUpdateWithoutQuotationItemDataInput!
}

input QuotationUpsertWithoutShippingInput {
  create: QuotationCreateWithoutShippingInput!
  update: QuotationUpdateWithoutShippingDataInput!
}

input QuotationUpsertWithWhereUniqueWithoutCustomerInput {
  create: QuotationCreateWithoutCustomerInput!
  update: QuotationUpdateWithoutCustomerDataInput!
  where: QuotationWhereUniqueInput!
}

input QuotationUpsertWithWhereUniqueWithoutSalesmanInput {
  create: QuotationCreateWithoutSalesmanInput!
  update: QuotationUpdateWithoutSalesmanDataInput!
  where: QuotationWhereUniqueInput!
}

input QuotationWhereInput {
  AND: [QuotationWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  customer: UserWhereInput
  docId: String
  docId_contains: String
  docId_ends_with: String
  docId_gt: String
  docId_gte: String
  docId_in: [String!]
  docId_lt: String
  docId_lte: String
  docId_not: String
  docId_not_contains: String
  docId_not_ends_with: String
  docId_not_in: [String!]
  docId_not_starts_with: String
  docId_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [QuotationWhereInput!]
  OR: [QuotationWhereInput!]
  payment: PaymentWhereInput
  quotationItem_every: QuotationItemWhereInput
  quotationItem_none: QuotationItemWhereInput
  quotationItem_some: QuotationItemWhereInput
  salesman: SalesmanWhereInput
  shipping: ShippingWhereInput
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input QuotationWhereUniqueInput {
  id: ID
}

type Salesman {
  createdAt: DateTime!
  email: String!
  id: ID!
  invoices(after: String, before: String, first: Int, last: Int, orderBy: InvoiceOrderByInput, skip: Int, where: InvoiceWhereInput): [Invoice!]
  name: String!
  payments(after: String, before: String, first: Int, last: Int, orderBy: PaymentOrderByInput, skip: Int, where: PaymentWhereInput): [Payment!]
  phone: String!
  quotations(after: String, before: String, first: Int, last: Int, orderBy: QuotationOrderByInput, skip: Int, where: QuotationWhereInput): [Quotation!]
  updatedAt: DateTime!
}

type SalesmanConnection {
  aggregate: AggregateSalesman!
  edges: [SalesmanEdge!]!
  pageInfo: PageInfo!
}

input SalesmanCreateInput {
  email: String!
  id: ID
  invoices: InvoiceCreateManyWithoutSalesmanInput
  name: String!
  payments: PaymentCreateManyWithoutSalesmanInput
  phone: String!
  quotations: QuotationCreateManyWithoutSalesmanInput
}

input SalesmanCreateOneWithoutInvoicesInput {
  connect: SalesmanWhereUniqueInput
  create: SalesmanCreateWithoutInvoicesInput
}

input SalesmanCreateOneWithoutPaymentsInput {
  connect: SalesmanWhereUniqueInput
  create: SalesmanCreateWithoutPaymentsInput
}

input SalesmanCreateOneWithoutQuotationsInput {
  connect: SalesmanWhereUniqueInput
  create: SalesmanCreateWithoutQuotationsInput
}

input SalesmanCreateWithoutInvoicesInput {
  email: String!
  id: ID
  name: String!
  payments: PaymentCreateManyWithoutSalesmanInput
  phone: String!
  quotations: QuotationCreateManyWithoutSalesmanInput
}

input SalesmanCreateWithoutPaymentsInput {
  email: String!
  id: ID
  invoices: InvoiceCreateManyWithoutSalesmanInput
  name: String!
  phone: String!
  quotations: QuotationCreateManyWithoutSalesmanInput
}

input SalesmanCreateWithoutQuotationsInput {
  email: String!
  id: ID
  invoices: InvoiceCreateManyWithoutSalesmanInput
  name: String!
  payments: PaymentCreateManyWithoutSalesmanInput
  phone: String!
}

type SalesmanEdge {
  cursor: String!
  node: Salesman!
}

enum SalesmanOrderByInput {
  createdAt_ASC
  createdAt_DESC
  email_ASC
  email_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  phone_ASC
  phone_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input SalesmanUpdateInput {
  email: String
  invoices: InvoiceUpdateManyWithoutSalesmanInput
  name: String
  payments: PaymentUpdateManyWithoutSalesmanInput
  phone: String
  quotations: QuotationUpdateManyWithoutSalesmanInput
}

input SalesmanUpdateManyMutationInput {
  email: String
  name: String
  phone: String
}

input SalesmanUpdateOneRequiredWithoutInvoicesInput {
  connect: SalesmanWhereUniqueInput
  create: SalesmanCreateWithoutInvoicesInput
  update: SalesmanUpdateWithoutInvoicesDataInput
  upsert: SalesmanUpsertWithoutInvoicesInput
}

input SalesmanUpdateOneRequiredWithoutPaymentsInput {
  connect: SalesmanWhereUniqueInput
  create: SalesmanCreateWithoutPaymentsInput
  update: SalesmanUpdateWithoutPaymentsDataInput
  upsert: SalesmanUpsertWithoutPaymentsInput
}

input SalesmanUpdateOneWithoutQuotationsInput {
  connect: SalesmanWhereUniqueInput
  create: SalesmanCreateWithoutQuotationsInput
  delete: Boolean
  disconnect: Boolean
  update: SalesmanUpdateWithoutQuotationsDataInput
  upsert: SalesmanUpsertWithoutQuotationsInput
}

input SalesmanUpdateWithoutInvoicesDataInput {
  email: String
  name: String
  payments: PaymentUpdateManyWithoutSalesmanInput
  phone: String
  quotations: QuotationUpdateManyWithoutSalesmanInput
}

input SalesmanUpdateWithoutPaymentsDataInput {
  email: String
  invoices: InvoiceUpdateManyWithoutSalesmanInput
  name: String
  phone: String
  quotations: QuotationUpdateManyWithoutSalesmanInput
}

input SalesmanUpdateWithoutQuotationsDataInput {
  email: String
  invoices: InvoiceUpdateManyWithoutSalesmanInput
  name: String
  payments: PaymentUpdateManyWithoutSalesmanInput
  phone: String
}

input SalesmanUpsertWithoutInvoicesInput {
  create: SalesmanCreateWithoutInvoicesInput!
  update: SalesmanUpdateWithoutInvoicesDataInput!
}

input SalesmanUpsertWithoutPaymentsInput {
  create: SalesmanCreateWithoutPaymentsInput!
  update: SalesmanUpdateWithoutPaymentsDataInput!
}

input SalesmanUpsertWithoutQuotationsInput {
  create: SalesmanCreateWithoutQuotationsInput!
  update: SalesmanUpdateWithoutQuotationsDataInput!
}

input SalesmanWhereInput {
  AND: [SalesmanWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  email: String
  email_contains: String
  email_ends_with: String
  email_gt: String
  email_gte: String
  email_in: [String!]
  email_lt: String
  email_lte: String
  email_not: String
  email_not_contains: String
  email_not_ends_with: String
  email_not_in: [String!]
  email_not_starts_with: String
  email_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  invoices_every: InvoiceWhereInput
  invoices_none: InvoiceWhereInput
  invoices_some: InvoiceWhereInput
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [SalesmanWhereInput!]
  OR: [SalesmanWhereInput!]
  payments_every: PaymentWhereInput
  payments_none: PaymentWhereInput
  payments_some: PaymentWhereInput
  phone: String
  phone_contains: String
  phone_ends_with: String
  phone_gt: String
  phone_gte: String
  phone_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_not: String
  phone_not_contains: String
  phone_not_ends_with: String
  phone_not_in: [String!]
  phone_not_starts_with: String
  phone_starts_with: String
  quotations_every: QuotationWhereInput
  quotations_none: QuotationWhereInput
  quotations_some: QuotationWhereInput
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input SalesmanWhereUniqueInput {
  id: ID
}

type Shipping {
  address: Address!
  createdAt: DateTime!
  docId: String!
  dueDate: DateTime!
  id: ID!
  invoce: Invoice!
  quotation: Quotation!
  status: String!
  updatedAt: DateTime!
}

type ShippingConnection {
  aggregate: AggregateShipping!
  edges: [ShippingEdge!]!
  pageInfo: PageInfo!
}

input ShippingCreateInput {
  address: AddressCreateOneWithoutShippingInput!
  docId: String!
  dueDate: DateTime!
  id: ID
  invoce: InvoiceCreateOneInput!
  quotation: QuotationCreateOneWithoutShippingInput!
  status: String!
}

input ShippingCreateManyWithoutAddressInput {
  connect: [ShippingWhereUniqueInput!]
  create: [ShippingCreateWithoutAddressInput!]
}

input ShippingCreateOneWithoutQuotationInput {
  connect: ShippingWhereUniqueInput
  create: ShippingCreateWithoutQuotationInput
}

input ShippingCreateWithoutAddressInput {
  docId: String!
  dueDate: DateTime!
  id: ID
  invoce: InvoiceCreateOneInput!
  quotation: QuotationCreateOneWithoutShippingInput!
  status: String!
}

input ShippingCreateWithoutQuotationInput {
  address: AddressCreateOneWithoutShippingInput!
  docId: String!
  dueDate: DateTime!
  id: ID
  invoce: InvoiceCreateOneInput!
  status: String!
}

type ShippingEdge {
  cursor: String!
  node: Shipping!
}

enum ShippingOrderByInput {
  createdAt_ASC
  createdAt_DESC
  docId_ASC
  docId_DESC
  dueDate_ASC
  dueDate_DESC
  id_ASC
  id_DESC
  status_ASC
  status_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input ShippingScalarWhereInput {
  AND: [ShippingScalarWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  docId: String
  docId_contains: String
  docId_ends_with: String
  docId_gt: String
  docId_gte: String
  docId_in: [String!]
  docId_lt: String
  docId_lte: String
  docId_not: String
  docId_not_contains: String
  docId_not_ends_with: String
  docId_not_in: [String!]
  docId_not_starts_with: String
  docId_starts_with: String
  dueDate: DateTime
  dueDate_gt: DateTime
  dueDate_gte: DateTime
  dueDate_in: [DateTime!]
  dueDate_lt: DateTime
  dueDate_lte: DateTime
  dueDate_not: DateTime
  dueDate_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [ShippingScalarWhereInput!]
  OR: [ShippingScalarWhereInput!]
  status: String
  status_contains: String
  status_ends_with: String
  status_gt: String
  status_gte: String
  status_in: [String!]
  status_lt: String
  status_lte: String
  status_not: String
  status_not_contains: String
  status_not_ends_with: String
  status_not_in: [String!]
  status_not_starts_with: String
  status_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input ShippingUpdateInput {
  address: AddressUpdateOneRequiredWithoutShippingInput
  docId: String
  dueDate: DateTime
  invoce: InvoiceUpdateOneRequiredInput
  quotation: QuotationUpdateOneRequiredWithoutShippingInput
  status: String
}

input ShippingUpdateManyDataInput {
  docId: String
  dueDate: DateTime
  status: String
}

input ShippingUpdateManyMutationInput {
  docId: String
  dueDate: DateTime
  status: String
}

input ShippingUpdateManyWithoutAddressInput {
  connect: [ShippingWhereUniqueInput!]
  create: [ShippingCreateWithoutAddressInput!]
  delete: [ShippingWhereUniqueInput!]
  deleteMany: [ShippingScalarWhereInput!]
  disconnect: [ShippingWhereUniqueInput!]
  set: [ShippingWhereUniqueInput!]
  update: [ShippingUpdateWithWhereUniqueWithoutAddressInput!]
  updateMany: [ShippingUpdateManyWithWhereNestedInput!]
  upsert: [ShippingUpsertWithWhereUniqueWithoutAddressInput!]
}

input ShippingUpdateManyWithWhereNestedInput {
  data: ShippingUpdateManyDataInput!
  where: ShippingScalarWhereInput!
}

input ShippingUpdateOneWithoutQuotationInput {
  connect: ShippingWhereUniqueInput
  create: ShippingCreateWithoutQuotationInput
  delete: Boolean
  disconnect: Boolean
  update: ShippingUpdateWithoutQuotationDataInput
  upsert: ShippingUpsertWithoutQuotationInput
}

input ShippingUpdateWithoutAddressDataInput {
  docId: String
  dueDate: DateTime
  invoce: InvoiceUpdateOneRequiredInput
  quotation: QuotationUpdateOneRequiredWithoutShippingInput
  status: String
}

input ShippingUpdateWithoutQuotationDataInput {
  address: AddressUpdateOneRequiredWithoutShippingInput
  docId: String
  dueDate: DateTime
  invoce: InvoiceUpdateOneRequiredInput
  status: String
}

input ShippingUpdateWithWhereUniqueWithoutAddressInput {
  data: ShippingUpdateWithoutAddressDataInput!
  where: ShippingWhereUniqueInput!
}

input ShippingUpsertWithoutQuotationInput {
  create: ShippingCreateWithoutQuotationInput!
  update: ShippingUpdateWithoutQuotationDataInput!
}

input ShippingUpsertWithWhereUniqueWithoutAddressInput {
  create: ShippingCreateWithoutAddressInput!
  update: ShippingUpdateWithoutAddressDataInput!
  where: ShippingWhereUniqueInput!
}

input ShippingWhereInput {
  address: AddressWhereInput
  AND: [ShippingWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  docId: String
  docId_contains: String
  docId_ends_with: String
  docId_gt: String
  docId_gte: String
  docId_in: [String!]
  docId_lt: String
  docId_lte: String
  docId_not: String
  docId_not_contains: String
  docId_not_ends_with: String
  docId_not_in: [String!]
  docId_not_starts_with: String
  docId_starts_with: String
  dueDate: DateTime
  dueDate_gt: DateTime
  dueDate_gte: DateTime
  dueDate_in: [DateTime!]
  dueDate_lt: DateTime
  dueDate_lte: DateTime
  dueDate_not: DateTime
  dueDate_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  invoce: InvoiceWhereInput
  NOT: [ShippingWhereInput!]
  OR: [ShippingWhereInput!]
  quotation: QuotationWhereInput
  status: String
  status_contains: String
  status_ends_with: String
  status_gt: String
  status_gte: String
  status_in: [String!]
  status_lt: String
  status_lte: String
  status_not: String
  status_not_contains: String
  status_not_ends_with: String
  status_not_in: [String!]
  status_not_starts_with: String
  status_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input ShippingWhereUniqueInput {
  id: ID
}

type ShoppingCart {
  createdAt: DateTime!
  customer: User!
  id: ID!
  productItems(after: String, before: String, first: Int, last: Int, orderBy: ShoppingCartItemOrderByInput, skip: Int, where: ShoppingCartItemWhereInput): [ShoppingCartItem!]
  total_cost: Float!
  updatedAt: DateTime!
}

type ShoppingCartConnection {
  aggregate: AggregateShoppingCart!
  edges: [ShoppingCartEdge!]!
  pageInfo: PageInfo!
}

input ShoppingCartCreateInput {
  customer: UserCreateOneWithoutShoppingCartInput!
  id: ID
  productItems: ShoppingCartItemCreateManyWithoutShoppingCartInput
  total_cost: Float!
}

input ShoppingCartCreateOneInput {
  connect: ShoppingCartWhereUniqueInput
  create: ShoppingCartCreateInput
}

input ShoppingCartCreateOneWithoutCustomerInput {
  connect: ShoppingCartWhereUniqueInput
  create: ShoppingCartCreateWithoutCustomerInput
}

input ShoppingCartCreateOneWithoutProductItemsInput {
  connect: ShoppingCartWhereUniqueInput
  create: ShoppingCartCreateWithoutProductItemsInput
}

input ShoppingCartCreateWithoutCustomerInput {
  id: ID
  productItems: ShoppingCartItemCreateManyWithoutShoppingCartInput
  total_cost: Float!
}

input ShoppingCartCreateWithoutProductItemsInput {
  customer: UserCreateOneWithoutShoppingCartInput!
  id: ID
  total_cost: Float!
}

type ShoppingCartEdge {
  cursor: String!
  node: ShoppingCart!
}

type ShoppingCartItem {
  amount: Int!
  id: ID!
  key: String!
  product: ProductItem!
  ShoppingCart: ShoppingCart
}

type ShoppingCartItemConnection {
  aggregate: AggregateShoppingCartItem!
  edges: [ShoppingCartItemEdge!]!
  pageInfo: PageInfo!
}

input ShoppingCartItemCreateInput {
  amount: Int!
  id: ID
  key: String!
  product: ProductItemCreateOneInput!
  ShoppingCart: ShoppingCartCreateOneWithoutProductItemsInput
}

input ShoppingCartItemCreateManyWithoutShoppingCartInput {
  connect: [ShoppingCartItemWhereUniqueInput!]
  create: [ShoppingCartItemCreateWithoutShoppingCartInput!]
}

input ShoppingCartItemCreateWithoutShoppingCartInput {
  amount: Int!
  id: ID
  key: String!
  product: ProductItemCreateOneInput!
}

type ShoppingCartItemEdge {
  cursor: String!
  node: ShoppingCartItem!
}

enum ShoppingCartItemOrderByInput {
  amount_ASC
  amount_DESC
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  key_ASC
  key_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input ShoppingCartItemScalarWhereInput {
  amount: Int
  amount_gt: Int
  amount_gte: Int
  amount_in: [Int!]
  amount_lt: Int
  amount_lte: Int
  amount_not: Int
  amount_not_in: [Int!]
  AND: [ShoppingCartItemScalarWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  key: String
  key_contains: String
  key_ends_with: String
  key_gt: String
  key_gte: String
  key_in: [String!]
  key_lt: String
  key_lte: String
  key_not: String
  key_not_contains: String
  key_not_ends_with: String
  key_not_in: [String!]
  key_not_starts_with: String
  key_starts_with: String
  NOT: [ShoppingCartItemScalarWhereInput!]
  OR: [ShoppingCartItemScalarWhereInput!]
}

input ShoppingCartItemUpdateInput {
  amount: Int
  key: String
  product: ProductItemUpdateOneRequiredInput
  ShoppingCart: ShoppingCartUpdateOneWithoutProductItemsInput
}

input ShoppingCartItemUpdateManyDataInput {
  amount: Int
  key: String
}

input ShoppingCartItemUpdateManyMutationInput {
  amount: Int
  key: String
}

input ShoppingCartItemUpdateManyWithoutShoppingCartInput {
  connect: [ShoppingCartItemWhereUniqueInput!]
  create: [ShoppingCartItemCreateWithoutShoppingCartInput!]
  delete: [ShoppingCartItemWhereUniqueInput!]
  deleteMany: [ShoppingCartItemScalarWhereInput!]
  disconnect: [ShoppingCartItemWhereUniqueInput!]
  set: [ShoppingCartItemWhereUniqueInput!]
  update: [ShoppingCartItemUpdateWithWhereUniqueWithoutShoppingCartInput!]
  updateMany: [ShoppingCartItemUpdateManyWithWhereNestedInput!]
  upsert: [ShoppingCartItemUpsertWithWhereUniqueWithoutShoppingCartInput!]
}

input ShoppingCartItemUpdateManyWithWhereNestedInput {
  data: ShoppingCartItemUpdateManyDataInput!
  where: ShoppingCartItemScalarWhereInput!
}

input ShoppingCartItemUpdateWithoutShoppingCartDataInput {
  amount: Int
  key: String
  product: ProductItemUpdateOneRequiredInput
}

input ShoppingCartItemUpdateWithWhereUniqueWithoutShoppingCartInput {
  data: ShoppingCartItemUpdateWithoutShoppingCartDataInput!
  where: ShoppingCartItemWhereUniqueInput!
}

input ShoppingCartItemUpsertWithWhereUniqueWithoutShoppingCartInput {
  create: ShoppingCartItemCreateWithoutShoppingCartInput!
  update: ShoppingCartItemUpdateWithoutShoppingCartDataInput!
  where: ShoppingCartItemWhereUniqueInput!
}

input ShoppingCartItemWhereInput {
  amount: Int
  amount_gt: Int
  amount_gte: Int
  amount_in: [Int!]
  amount_lt: Int
  amount_lte: Int
  amount_not: Int
  amount_not_in: [Int!]
  AND: [ShoppingCartItemWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  key: String
  key_contains: String
  key_ends_with: String
  key_gt: String
  key_gte: String
  key_in: [String!]
  key_lt: String
  key_lte: String
  key_not: String
  key_not_contains: String
  key_not_ends_with: String
  key_not_in: [String!]
  key_not_starts_with: String
  key_starts_with: String
  NOT: [ShoppingCartItemWhereInput!]
  OR: [ShoppingCartItemWhereInput!]
  product: ProductItemWhereInput
  ShoppingCart: ShoppingCartWhereInput
}

input ShoppingCartItemWhereUniqueInput {
  id: ID
  key: String
}

enum ShoppingCartOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  total_cost_ASC
  total_cost_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input ShoppingCartUpdateDataInput {
  customer: UserUpdateOneRequiredWithoutShoppingCartInput
  productItems: ShoppingCartItemUpdateManyWithoutShoppingCartInput
  total_cost: Float
}

input ShoppingCartUpdateInput {
  customer: UserUpdateOneRequiredWithoutShoppingCartInput
  productItems: ShoppingCartItemUpdateManyWithoutShoppingCartInput
  total_cost: Float
}

input ShoppingCartUpdateManyMutationInput {
  total_cost: Float
}

input ShoppingCartUpdateOneInput {
  connect: ShoppingCartWhereUniqueInput
  create: ShoppingCartCreateInput
  delete: Boolean
  disconnect: Boolean
  update: ShoppingCartUpdateDataInput
  upsert: ShoppingCartUpsertNestedInput
}

input ShoppingCartUpdateOneRequiredWithoutCustomerInput {
  connect: ShoppingCartWhereUniqueInput
  create: ShoppingCartCreateWithoutCustomerInput
  update: ShoppingCartUpdateWithoutCustomerDataInput
  upsert: ShoppingCartUpsertWithoutCustomerInput
}

input ShoppingCartUpdateOneWithoutProductItemsInput {
  connect: ShoppingCartWhereUniqueInput
  create: ShoppingCartCreateWithoutProductItemsInput
  delete: Boolean
  disconnect: Boolean
  update: ShoppingCartUpdateWithoutProductItemsDataInput
  upsert: ShoppingCartUpsertWithoutProductItemsInput
}

input ShoppingCartUpdateWithoutCustomerDataInput {
  productItems: ShoppingCartItemUpdateManyWithoutShoppingCartInput
  total_cost: Float
}

input ShoppingCartUpdateWithoutProductItemsDataInput {
  customer: UserUpdateOneRequiredWithoutShoppingCartInput
  total_cost: Float
}

input ShoppingCartUpsertNestedInput {
  create: ShoppingCartCreateInput!
  update: ShoppingCartUpdateDataInput!
}

input ShoppingCartUpsertWithoutCustomerInput {
  create: ShoppingCartCreateWithoutCustomerInput!
  update: ShoppingCartUpdateWithoutCustomerDataInput!
}

input ShoppingCartUpsertWithoutProductItemsInput {
  create: ShoppingCartCreateWithoutProductItemsInput!
  update: ShoppingCartUpdateWithoutProductItemsDataInput!
}

input ShoppingCartWhereInput {
  AND: [ShoppingCartWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  customer: UserWhereInput
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [ShoppingCartWhereInput!]
  OR: [ShoppingCartWhereInput!]
  productItems_every: ShoppingCartItemWhereInput
  productItems_none: ShoppingCartItemWhereInput
  productItems_some: ShoppingCartItemWhereInput
  total_cost: Float
  total_cost_gt: Float
  total_cost_gte: Float
  total_cost_in: [Float!]
  total_cost_lt: Float
  total_cost_lte: Float
  total_cost_not: Float
  total_cost_not_in: [Float!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input ShoppingCartWhereUniqueInput {
  id: ID
}

type User {
  activated: Boolean!
  addresses(after: String, before: String, first: Int, last: Int, orderBy: AddressOrderByInput, skip: Int, where: AddressWhereInput): [Address!]
  avatar: String
  createdAt: DateTime!
  email: String!
  id: ID!
  name: String!
  password: String!
  payments(after: String, before: String, first: Int, last: Int, orderBy: PaymentOrderByInput, skip: Int, where: PaymentWhereInput): [Payment!]
  phone: String!
  quotations(after: String, before: String, first: Int, last: Int, orderBy: QuotationOrderByInput, skip: Int, where: QuotationWhereInput): [Quotation!]
  runningId: Int
  shoppingCart: ShoppingCart!
  type: String
  updatedAt: DateTime!
}

type UserConnection {
  aggregate: AggregateUser!
  edges: [UserEdge!]!
  pageInfo: PageInfo!
}

input UserCreateInput {
  activated: Boolean
  addresses: AddressCreateManyWithoutCustomerInput
  avatar: String
  email: String!
  id: ID
  name: String!
  password: String!
  payments: PaymentCreateManyWithoutCustomerInput
  phone: String!
  quotations: QuotationCreateManyWithoutCustomerInput
  runningId: Int
  shoppingCart: ShoppingCartCreateOneWithoutCustomerInput!
  type: String
}

input UserCreateOneInput {
  connect: UserWhereUniqueInput
  create: UserCreateInput
}

input UserCreateOneWithoutAddressesInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutAddressesInput
}

input UserCreateOneWithoutPaymentsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutPaymentsInput
}

input UserCreateOneWithoutQuotationsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutQuotationsInput
}

input UserCreateOneWithoutShoppingCartInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutShoppingCartInput
}

input UserCreateWithoutAddressesInput {
  activated: Boolean
  avatar: String
  email: String!
  id: ID
  name: String!
  password: String!
  payments: PaymentCreateManyWithoutCustomerInput
  phone: String!
  quotations: QuotationCreateManyWithoutCustomerInput
  runningId: Int
  shoppingCart: ShoppingCartCreateOneWithoutCustomerInput!
  type: String
}

input UserCreateWithoutPaymentsInput {
  activated: Boolean
  addresses: AddressCreateManyWithoutCustomerInput
  avatar: String
  email: String!
  id: ID
  name: String!
  password: String!
  phone: String!
  quotations: QuotationCreateManyWithoutCustomerInput
  runningId: Int
  shoppingCart: ShoppingCartCreateOneWithoutCustomerInput!
  type: String
}

input UserCreateWithoutQuotationsInput {
  activated: Boolean
  addresses: AddressCreateManyWithoutCustomerInput
  avatar: String
  email: String!
  id: ID
  name: String!
  password: String!
  payments: PaymentCreateManyWithoutCustomerInput
  phone: String!
  runningId: Int
  shoppingCart: ShoppingCartCreateOneWithoutCustomerInput!
  type: String
}

input UserCreateWithoutShoppingCartInput {
  activated: Boolean
  addresses: AddressCreateManyWithoutCustomerInput
  avatar: String
  email: String!
  id: ID
  name: String!
  password: String!
  payments: PaymentCreateManyWithoutCustomerInput
  phone: String!
  quotations: QuotationCreateManyWithoutCustomerInput
  runningId: Int
  type: String
}

type UserEdge {
  cursor: String!
  node: User!
}

enum UserOrderByInput {
  activated_ASC
  activated_DESC
  avatar_ASC
  avatar_DESC
  createdAt_ASC
  createdAt_DESC
  email_ASC
  email_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  password_ASC
  password_DESC
  phone_ASC
  phone_DESC
  runningId_ASC
  runningId_DESC
  type_ASC
  type_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input UserUpdateDataInput {
  activated: Boolean
  addresses: AddressUpdateManyWithoutCustomerInput
  avatar: String
  email: String
  name: String
  password: String
  payments: PaymentUpdateManyWithoutCustomerInput
  phone: String
  quotations: QuotationUpdateManyWithoutCustomerInput
  runningId: Int
  shoppingCart: ShoppingCartUpdateOneRequiredWithoutCustomerInput
  type: String
}

input UserUpdateInput {
  activated: Boolean
  addresses: AddressUpdateManyWithoutCustomerInput
  avatar: String
  email: String
  name: String
  password: String
  payments: PaymentUpdateManyWithoutCustomerInput
  phone: String
  quotations: QuotationUpdateManyWithoutCustomerInput
  runningId: Int
  shoppingCart: ShoppingCartUpdateOneRequiredWithoutCustomerInput
  type: String
}

input UserUpdateManyMutationInput {
  activated: Boolean
  avatar: String
  email: String
  name: String
  password: String
  phone: String
  runningId: Int
  type: String
}

input UserUpdateOneRequiredInput {
  connect: UserWhereUniqueInput
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
}

input UserUpdateOneRequiredWithoutAddressesInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutAddressesInput
  update: UserUpdateWithoutAddressesDataInput
  upsert: UserUpsertWithoutAddressesInput
}

input UserUpdateOneRequiredWithoutPaymentsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutPaymentsInput
  update: UserUpdateWithoutPaymentsDataInput
  upsert: UserUpsertWithoutPaymentsInput
}

input UserUpdateOneRequiredWithoutQuotationsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutQuotationsInput
  update: UserUpdateWithoutQuotationsDataInput
  upsert: UserUpsertWithoutQuotationsInput
}

input UserUpdateOneRequiredWithoutShoppingCartInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutShoppingCartInput
  update: UserUpdateWithoutShoppingCartDataInput
  upsert: UserUpsertWithoutShoppingCartInput
}

input UserUpdateWithoutAddressesDataInput {
  activated: Boolean
  avatar: String
  email: String
  name: String
  password: String
  payments: PaymentUpdateManyWithoutCustomerInput
  phone: String
  quotations: QuotationUpdateManyWithoutCustomerInput
  runningId: Int
  shoppingCart: ShoppingCartUpdateOneRequiredWithoutCustomerInput
  type: String
}

input UserUpdateWithoutPaymentsDataInput {
  activated: Boolean
  addresses: AddressUpdateManyWithoutCustomerInput
  avatar: String
  email: String
  name: String
  password: String
  phone: String
  quotations: QuotationUpdateManyWithoutCustomerInput
  runningId: Int
  shoppingCart: ShoppingCartUpdateOneRequiredWithoutCustomerInput
  type: String
}

input UserUpdateWithoutQuotationsDataInput {
  activated: Boolean
  addresses: AddressUpdateManyWithoutCustomerInput
  avatar: String
  email: String
  name: String
  password: String
  payments: PaymentUpdateManyWithoutCustomerInput
  phone: String
  runningId: Int
  shoppingCart: ShoppingCartUpdateOneRequiredWithoutCustomerInput
  type: String
}

input UserUpdateWithoutShoppingCartDataInput {
  activated: Boolean
  addresses: AddressUpdateManyWithoutCustomerInput
  avatar: String
  email: String
  name: String
  password: String
  payments: PaymentUpdateManyWithoutCustomerInput
  phone: String
  quotations: QuotationUpdateManyWithoutCustomerInput
  runningId: Int
  type: String
}

input UserUpsertNestedInput {
  create: UserCreateInput!
  update: UserUpdateDataInput!
}

input UserUpsertWithoutAddressesInput {
  create: UserCreateWithoutAddressesInput!
  update: UserUpdateWithoutAddressesDataInput!
}

input UserUpsertWithoutPaymentsInput {
  create: UserCreateWithoutPaymentsInput!
  update: UserUpdateWithoutPaymentsDataInput!
}

input UserUpsertWithoutQuotationsInput {
  create: UserCreateWithoutQuotationsInput!
  update: UserUpdateWithoutQuotationsDataInput!
}

input UserUpsertWithoutShoppingCartInput {
  create: UserCreateWithoutShoppingCartInput!
  update: UserUpdateWithoutShoppingCartDataInput!
}

input UserWhereInput {
  activated: Boolean
  activated_not: Boolean
  addresses_every: AddressWhereInput
  addresses_none: AddressWhereInput
  addresses_some: AddressWhereInput
  AND: [UserWhereInput!]
  avatar: String
  avatar_contains: String
  avatar_ends_with: String
  avatar_gt: String
  avatar_gte: String
  avatar_in: [String!]
  avatar_lt: String
  avatar_lte: String
  avatar_not: String
  avatar_not_contains: String
  avatar_not_ends_with: String
  avatar_not_in: [String!]
  avatar_not_starts_with: String
  avatar_starts_with: String
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  email: String
  email_contains: String
  email_ends_with: String
  email_gt: String
  email_gte: String
  email_in: [String!]
  email_lt: String
  email_lte: String
  email_not: String
  email_not_contains: String
  email_not_ends_with: String
  email_not_in: [String!]
  email_not_starts_with: String
  email_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: String
  password_contains: String
  password_ends_with: String
  password_gt: String
  password_gte: String
  password_in: [String!]
  password_lt: String
  password_lte: String
  password_not: String
  password_not_contains: String
  password_not_ends_with: String
  password_not_in: [String!]
  password_not_starts_with: String
  password_starts_with: String
  payments_every: PaymentWhereInput
  payments_none: PaymentWhereInput
  payments_some: PaymentWhereInput
  phone: String
  phone_contains: String
  phone_ends_with: String
  phone_gt: String
  phone_gte: String
  phone_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_not: String
  phone_not_contains: String
  phone_not_ends_with: String
  phone_not_in: [String!]
  phone_not_starts_with: String
  phone_starts_with: String
  quotations_every: QuotationWhereInput
  quotations_none: QuotationWhereInput
  quotations_some: QuotationWhereInput
  runningId: Int
  runningId_gt: Int
  runningId_gte: Int
  runningId_in: [Int!]
  runningId_lt: Int
  runningId_lte: Int
  runningId_not: Int
  runningId_not_in: [Int!]
  shoppingCart: ShoppingCartWhereInput
  type: String
  type_contains: String
  type_ends_with: String
  type_gt: String
  type_gte: String
  type_in: [String!]
  type_lt: String
  type_lte: String
  type_not: String
  type_not_contains: String
  type_not_ends_with: String
  type_not_in: [String!]
  type_not_starts_with: String
  type_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input UserWhereUniqueInput {
  email: String
  id: ID
}
