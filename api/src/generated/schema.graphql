### This file was autogenerated by GraphQL Nexus
### Do not make changes to this file directly


type Address {
  Address: String!
  createdAt: DateTime!
  customer: User!
  id: ID!
  invoices(after: String, before: String, first: Int, last: Int, orderBy: InvoiceOrderByInput, skip: Int, where: InvoiceWhereInput): [Invoice!]
  name: String!
  shipping(after: String, before: String, first: Int, last: Int, orderBy: ShippingOrderByInput, skip: Int, where: ShippingWhereInput): [Shipping!]
  updatedAt: DateTime!
}

type AddressConnection {
  aggregate: AggregateAddress!
  edges: [AddressEdge!]!
  pageInfo: PageInfo!
}

input AddressCreateInput {
  Address: String!
  customer: UserCreateOneWithoutAddressesInput!
  id: ID
  invoices: InvoiceCreateManyWithoutAddressInput
  name: String!
  shipping: ShippingCreateManyWithoutAddressInput
}

input AddressCreateManyWithoutCustomerInput {
  connect: [AddressWhereUniqueInput!]
  create: [AddressCreateWithoutCustomerInput!]
}

input AddressCreateOneWithoutInvoicesInput {
  connect: AddressWhereUniqueInput
  create: AddressCreateWithoutInvoicesInput
}

input AddressCreateOneWithoutShippingInput {
  connect: AddressWhereUniqueInput
  create: AddressCreateWithoutShippingInput
}

input AddressCreateWithoutCustomerInput {
  Address: String!
  id: ID
  invoices: InvoiceCreateManyWithoutAddressInput
  name: String!
  shipping: ShippingCreateManyWithoutAddressInput
}

input AddressCreateWithoutInvoicesInput {
  Address: String!
  customer: UserCreateOneWithoutAddressesInput!
  id: ID
  name: String!
  shipping: ShippingCreateManyWithoutAddressInput
}

input AddressCreateWithoutShippingInput {
  Address: String!
  customer: UserCreateOneWithoutAddressesInput!
  id: ID
  invoices: InvoiceCreateManyWithoutAddressInput
  name: String!
}

type AddressEdge {
  cursor: String!
  node: Address!
}

enum AddressOrderByInput {
  Address_ASC
  Address_DESC
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input AddressScalarWhereInput {
  Address: String
  Address_contains: String
  Address_ends_with: String
  Address_gt: String
  Address_gte: String
  Address_in: [String!]
  Address_lt: String
  Address_lte: String
  Address_not: String
  Address_not_contains: String
  Address_not_ends_with: String
  Address_not_in: [String!]
  Address_not_starts_with: String
  Address_starts_with: String
  AND: [AddressScalarWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [AddressScalarWhereInput!]
  OR: [AddressScalarWhereInput!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input AddressUpdateInput {
  Address: String
  customer: UserUpdateOneRequiredWithoutAddressesInput
  invoices: InvoiceUpdateManyWithoutAddressInput
  name: String
  shipping: ShippingUpdateManyWithoutAddressInput
}

input AddressUpdateManyDataInput {
  Address: String
  name: String
}

input AddressUpdateManyMutationInput {
  Address: String
  name: String
}

input AddressUpdateManyWithoutCustomerInput {
  connect: [AddressWhereUniqueInput!]
  create: [AddressCreateWithoutCustomerInput!]
  delete: [AddressWhereUniqueInput!]
  deleteMany: [AddressScalarWhereInput!]
  disconnect: [AddressWhereUniqueInput!]
  set: [AddressWhereUniqueInput!]
  update: [AddressUpdateWithWhereUniqueWithoutCustomerInput!]
  updateMany: [AddressUpdateManyWithWhereNestedInput!]
  upsert: [AddressUpsertWithWhereUniqueWithoutCustomerInput!]
}

input AddressUpdateManyWithWhereNestedInput {
  data: AddressUpdateManyDataInput!
  where: AddressScalarWhereInput!
}

input AddressUpdateOneRequiredWithoutShippingInput {
  connect: AddressWhereUniqueInput
  create: AddressCreateWithoutShippingInput
  update: AddressUpdateWithoutShippingDataInput
  upsert: AddressUpsertWithoutShippingInput
}

input AddressUpdateOneWithoutInvoicesInput {
  connect: AddressWhereUniqueInput
  create: AddressCreateWithoutInvoicesInput
  delete: Boolean
  disconnect: Boolean
  update: AddressUpdateWithoutInvoicesDataInput
  upsert: AddressUpsertWithoutInvoicesInput
}

input AddressUpdateWithoutCustomerDataInput {
  Address: String
  invoices: InvoiceUpdateManyWithoutAddressInput
  name: String
  shipping: ShippingUpdateManyWithoutAddressInput
}

input AddressUpdateWithoutInvoicesDataInput {
  Address: String
  customer: UserUpdateOneRequiredWithoutAddressesInput
  name: String
  shipping: ShippingUpdateManyWithoutAddressInput
}

input AddressUpdateWithoutShippingDataInput {
  Address: String
  customer: UserUpdateOneRequiredWithoutAddressesInput
  invoices: InvoiceUpdateManyWithoutAddressInput
  name: String
}

input AddressUpdateWithWhereUniqueWithoutCustomerInput {
  data: AddressUpdateWithoutCustomerDataInput!
  where: AddressWhereUniqueInput!
}

input AddressUpsertWithoutInvoicesInput {
  create: AddressCreateWithoutInvoicesInput!
  update: AddressUpdateWithoutInvoicesDataInput!
}

input AddressUpsertWithoutShippingInput {
  create: AddressCreateWithoutShippingInput!
  update: AddressUpdateWithoutShippingDataInput!
}

input AddressUpsertWithWhereUniqueWithoutCustomerInput {
  create: AddressCreateWithoutCustomerInput!
  update: AddressUpdateWithoutCustomerDataInput!
  where: AddressWhereUniqueInput!
}

input AddressWhereInput {
  Address: String
  Address_contains: String
  Address_ends_with: String
  Address_gt: String
  Address_gte: String
  Address_in: [String!]
  Address_lt: String
  Address_lte: String
  Address_not: String
  Address_not_contains: String
  Address_not_ends_with: String
  Address_not_in: [String!]
  Address_not_starts_with: String
  Address_starts_with: String
  AND: [AddressWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  customer: UserWhereInput
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  invoices_every: InvoiceWhereInput
  invoices_none: InvoiceWhereInput
  invoices_some: InvoiceWhereInput
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [AddressWhereInput!]
  OR: [AddressWhereInput!]
  shipping_every: ShippingWhereInput
  shipping_none: ShippingWhereInput
  shipping_some: ShippingWhereInput
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input AddressWhereUniqueInput {
  id: ID
}

type AggregateAddress {
  count: Int!
}

type AggregateCategory {
  count: Int!
}

type AggregateImage {
  count: Int!
}

type AggregateInvoice {
  count: Int!
}

type AggregatePayment {
  count: Int!
}

type AggregateProductItem {
  count: Int!
}

type AggregateQuotation {
  count: Int!
}

type AggregateSaleman {
  count: Int!
}

type AggregateShipping {
  count: Int!
}

type AggregateShoppingCart {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Category {
  category: Category
  createdAt: DateTime!
  id: ID!
  name: String!
  productItem(after: String, before: String, first: Int, last: Int, orderBy: ProductItemOrderByInput, skip: Int, where: ProductItemWhereInput): [ProductItem!]
  updatedAt: DateTime!
}

type CategoryConnection {
  aggregate: AggregateCategory!
  edges: [CategoryEdge!]!
  pageInfo: PageInfo!
}

input CategoryCreateInput {
  category: CategoryCreateOneInput
  id: ID
  name: String!
  productItem: ProductItemCreateManyWithoutCategoryInput
}

input CategoryCreateOneInput {
  connect: CategoryWhereUniqueInput
  create: CategoryCreateInput
}

input CategoryCreateOneWithoutProductItemInput {
  connect: CategoryWhereUniqueInput
  create: CategoryCreateWithoutProductItemInput
}

input CategoryCreateWithoutProductItemInput {
  category: CategoryCreateOneInput
  id: ID
  name: String!
}

type CategoryEdge {
  cursor: String!
  node: Category!
}

enum CategoryOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input CategoryUpdateDataInput {
  category: CategoryUpdateOneInput
  name: String
  productItem: ProductItemUpdateManyWithoutCategoryInput
}

input CategoryUpdateInput {
  category: CategoryUpdateOneInput
  name: String
  productItem: ProductItemUpdateManyWithoutCategoryInput
}

input CategoryUpdateManyMutationInput {
  name: String
}

input CategoryUpdateOneInput {
  connect: CategoryWhereUniqueInput
  create: CategoryCreateInput
  delete: Boolean
  disconnect: Boolean
  update: CategoryUpdateDataInput
  upsert: CategoryUpsertNestedInput
}

input CategoryUpdateOneRequiredWithoutProductItemInput {
  connect: CategoryWhereUniqueInput
  create: CategoryCreateWithoutProductItemInput
  update: CategoryUpdateWithoutProductItemDataInput
  upsert: CategoryUpsertWithoutProductItemInput
}

input CategoryUpdateWithoutProductItemDataInput {
  category: CategoryUpdateOneInput
  name: String
}

input CategoryUpsertNestedInput {
  create: CategoryCreateInput!
  update: CategoryUpdateDataInput!
}

input CategoryUpsertWithoutProductItemInput {
  create: CategoryCreateWithoutProductItemInput!
  update: CategoryUpdateWithoutProductItemDataInput!
}

input CategoryWhereInput {
  AND: [CategoryWhereInput!]
  category: CategoryWhereInput
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  productItem_every: ProductItemWhereInput
  productItem_none: ProductItemWhereInput
  productItem_some: ProductItemWhereInput
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input CategoryWhereUniqueInput {
  id: ID
}

scalar DateTime

type Image {
  description: String
  filename: String!
  id: ID!
}

type ImageConnection {
  aggregate: AggregateImage!
  edges: [ImageEdge!]!
  pageInfo: PageInfo!
}

input ImageCreateInput {
  description: String
  filename: String!
  id: ID
}

input ImageCreateOneInput {
  connect: ImageWhereUniqueInput
  create: ImageCreateInput
}

type ImageEdge {
  cursor: String!
  node: Image!
}

enum ImageOrderByInput {
  createdAt_ASC
  createdAt_DESC
  description_ASC
  description_DESC
  filename_ASC
  filename_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input ImageUpdateDataInput {
  description: String
  filename: String
}

input ImageUpdateInput {
  description: String
  filename: String
}

input ImageUpdateManyMutationInput {
  description: String
  filename: String
}

input ImageUpdateOneRequiredInput {
  connect: ImageWhereUniqueInput
  create: ImageCreateInput
  update: ImageUpdateDataInput
  upsert: ImageUpsertNestedInput
}

input ImageUpsertNestedInput {
  create: ImageCreateInput!
  update: ImageUpdateDataInput!
}

input ImageWhereInput {
  AND: [ImageWhereInput!]
  description: String
  description_contains: String
  description_ends_with: String
  description_gt: String
  description_gte: String
  description_in: [String!]
  description_lt: String
  description_lte: String
  description_not: String
  description_not_contains: String
  description_not_ends_with: String
  description_not_in: [String!]
  description_not_starts_with: String
  description_starts_with: String
  filename: String
  filename_contains: String
  filename_ends_with: String
  filename_gt: String
  filename_gte: String
  filename_in: [String!]
  filename_lt: String
  filename_lte: String
  filename_not: String
  filename_not_contains: String
  filename_not_ends_with: String
  filename_not_in: [String!]
  filename_not_starts_with: String
  filename_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [ImageWhereInput!]
  OR: [ImageWhereInput!]
}

input ImageWhereUniqueInput {
  id: ID
}

type Invoice {
  address: Address
  createdAt: DateTime!
  creditTerm: String!
  docId: String!
  id: ID!
  payment: Payment
  quotation: Quotation!
  saleman: Saleman!
  updatedAt: DateTime!
  user: User!
}

type InvoiceConnection {
  aggregate: AggregateInvoice!
  edges: [InvoiceEdge!]!
  pageInfo: PageInfo!
}

input InvoiceCreateInput {
  address: AddressCreateOneWithoutInvoicesInput
  creditTerm: String!
  docId: String!
  id: ID
  payment: PaymentCreateOneWithoutInvoiceInput
  quotation: QuotationCreateOneInput!
  saleman: SalemanCreateOneWithoutInvoicesInput!
  user: UserCreateOneInput!
}

input InvoiceCreateManyWithoutAddressInput {
  connect: [InvoiceWhereUniqueInput!]
  create: [InvoiceCreateWithoutAddressInput!]
}

input InvoiceCreateManyWithoutSalemanInput {
  connect: [InvoiceWhereUniqueInput!]
  create: [InvoiceCreateWithoutSalemanInput!]
}

input InvoiceCreateOneInput {
  connect: InvoiceWhereUniqueInput
  create: InvoiceCreateInput
}

input InvoiceCreateOneWithoutPaymentInput {
  connect: InvoiceWhereUniqueInput
  create: InvoiceCreateWithoutPaymentInput
}

input InvoiceCreateWithoutAddressInput {
  creditTerm: String!
  docId: String!
  id: ID
  payment: PaymentCreateOneWithoutInvoiceInput
  quotation: QuotationCreateOneInput!
  saleman: SalemanCreateOneWithoutInvoicesInput!
  user: UserCreateOneInput!
}

input InvoiceCreateWithoutPaymentInput {
  address: AddressCreateOneWithoutInvoicesInput
  creditTerm: String!
  docId: String!
  id: ID
  quotation: QuotationCreateOneInput!
  saleman: SalemanCreateOneWithoutInvoicesInput!
  user: UserCreateOneInput!
}

input InvoiceCreateWithoutSalemanInput {
  address: AddressCreateOneWithoutInvoicesInput
  creditTerm: String!
  docId: String!
  id: ID
  payment: PaymentCreateOneWithoutInvoiceInput
  quotation: QuotationCreateOneInput!
  user: UserCreateOneInput!
}

type InvoiceEdge {
  cursor: String!
  node: Invoice!
}

enum InvoiceOrderByInput {
  createdAt_ASC
  createdAt_DESC
  creditTerm_ASC
  creditTerm_DESC
  docId_ASC
  docId_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input InvoiceScalarWhereInput {
  AND: [InvoiceScalarWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  creditTerm: String
  creditTerm_contains: String
  creditTerm_ends_with: String
  creditTerm_gt: String
  creditTerm_gte: String
  creditTerm_in: [String!]
  creditTerm_lt: String
  creditTerm_lte: String
  creditTerm_not: String
  creditTerm_not_contains: String
  creditTerm_not_ends_with: String
  creditTerm_not_in: [String!]
  creditTerm_not_starts_with: String
  creditTerm_starts_with: String
  docId: String
  docId_contains: String
  docId_ends_with: String
  docId_gt: String
  docId_gte: String
  docId_in: [String!]
  docId_lt: String
  docId_lte: String
  docId_not: String
  docId_not_contains: String
  docId_not_ends_with: String
  docId_not_in: [String!]
  docId_not_starts_with: String
  docId_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [InvoiceScalarWhereInput!]
  OR: [InvoiceScalarWhereInput!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input InvoiceUpdateDataInput {
  address: AddressUpdateOneWithoutInvoicesInput
  creditTerm: String
  docId: String
  payment: PaymentUpdateOneWithoutInvoiceInput
  quotation: QuotationUpdateOneRequiredInput
  saleman: SalemanUpdateOneRequiredWithoutInvoicesInput
  user: UserUpdateOneRequiredInput
}

input InvoiceUpdateInput {
  address: AddressUpdateOneWithoutInvoicesInput
  creditTerm: String
  docId: String
  payment: PaymentUpdateOneWithoutInvoiceInput
  quotation: QuotationUpdateOneRequiredInput
  saleman: SalemanUpdateOneRequiredWithoutInvoicesInput
  user: UserUpdateOneRequiredInput
}

input InvoiceUpdateManyDataInput {
  creditTerm: String
  docId: String
}

input InvoiceUpdateManyMutationInput {
  creditTerm: String
  docId: String
}

input InvoiceUpdateManyWithoutAddressInput {
  connect: [InvoiceWhereUniqueInput!]
  create: [InvoiceCreateWithoutAddressInput!]
  delete: [InvoiceWhereUniqueInput!]
  deleteMany: [InvoiceScalarWhereInput!]
  disconnect: [InvoiceWhereUniqueInput!]
  set: [InvoiceWhereUniqueInput!]
  update: [InvoiceUpdateWithWhereUniqueWithoutAddressInput!]
  updateMany: [InvoiceUpdateManyWithWhereNestedInput!]
  upsert: [InvoiceUpsertWithWhereUniqueWithoutAddressInput!]
}

input InvoiceUpdateManyWithoutSalemanInput {
  connect: [InvoiceWhereUniqueInput!]
  create: [InvoiceCreateWithoutSalemanInput!]
  delete: [InvoiceWhereUniqueInput!]
  deleteMany: [InvoiceScalarWhereInput!]
  disconnect: [InvoiceWhereUniqueInput!]
  set: [InvoiceWhereUniqueInput!]
  update: [InvoiceUpdateWithWhereUniqueWithoutSalemanInput!]
  updateMany: [InvoiceUpdateManyWithWhereNestedInput!]
  upsert: [InvoiceUpsertWithWhereUniqueWithoutSalemanInput!]
}

input InvoiceUpdateManyWithWhereNestedInput {
  data: InvoiceUpdateManyDataInput!
  where: InvoiceScalarWhereInput!
}

input InvoiceUpdateOneRequiredInput {
  connect: InvoiceWhereUniqueInput
  create: InvoiceCreateInput
  update: InvoiceUpdateDataInput
  upsert: InvoiceUpsertNestedInput
}

input InvoiceUpdateOneWithoutPaymentInput {
  connect: InvoiceWhereUniqueInput
  create: InvoiceCreateWithoutPaymentInput
  delete: Boolean
  disconnect: Boolean
  update: InvoiceUpdateWithoutPaymentDataInput
  upsert: InvoiceUpsertWithoutPaymentInput
}

input InvoiceUpdateWithoutAddressDataInput {
  creditTerm: String
  docId: String
  payment: PaymentUpdateOneWithoutInvoiceInput
  quotation: QuotationUpdateOneRequiredInput
  saleman: SalemanUpdateOneRequiredWithoutInvoicesInput
  user: UserUpdateOneRequiredInput
}

input InvoiceUpdateWithoutPaymentDataInput {
  address: AddressUpdateOneWithoutInvoicesInput
  creditTerm: String
  docId: String
  quotation: QuotationUpdateOneRequiredInput
  saleman: SalemanUpdateOneRequiredWithoutInvoicesInput
  user: UserUpdateOneRequiredInput
}

input InvoiceUpdateWithoutSalemanDataInput {
  address: AddressUpdateOneWithoutInvoicesInput
  creditTerm: String
  docId: String
  payment: PaymentUpdateOneWithoutInvoiceInput
  quotation: QuotationUpdateOneRequiredInput
  user: UserUpdateOneRequiredInput
}

input InvoiceUpdateWithWhereUniqueWithoutAddressInput {
  data: InvoiceUpdateWithoutAddressDataInput!
  where: InvoiceWhereUniqueInput!
}

input InvoiceUpdateWithWhereUniqueWithoutSalemanInput {
  data: InvoiceUpdateWithoutSalemanDataInput!
  where: InvoiceWhereUniqueInput!
}

input InvoiceUpsertNestedInput {
  create: InvoiceCreateInput!
  update: InvoiceUpdateDataInput!
}

input InvoiceUpsertWithoutPaymentInput {
  create: InvoiceCreateWithoutPaymentInput!
  update: InvoiceUpdateWithoutPaymentDataInput!
}

input InvoiceUpsertWithWhereUniqueWithoutAddressInput {
  create: InvoiceCreateWithoutAddressInput!
  update: InvoiceUpdateWithoutAddressDataInput!
  where: InvoiceWhereUniqueInput!
}

input InvoiceUpsertWithWhereUniqueWithoutSalemanInput {
  create: InvoiceCreateWithoutSalemanInput!
  update: InvoiceUpdateWithoutSalemanDataInput!
  where: InvoiceWhereUniqueInput!
}

input InvoiceWhereInput {
  address: AddressWhereInput
  AND: [InvoiceWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  creditTerm: String
  creditTerm_contains: String
  creditTerm_ends_with: String
  creditTerm_gt: String
  creditTerm_gte: String
  creditTerm_in: [String!]
  creditTerm_lt: String
  creditTerm_lte: String
  creditTerm_not: String
  creditTerm_not_contains: String
  creditTerm_not_ends_with: String
  creditTerm_not_in: [String!]
  creditTerm_not_starts_with: String
  creditTerm_starts_with: String
  docId: String
  docId_contains: String
  docId_ends_with: String
  docId_gt: String
  docId_gte: String
  docId_in: [String!]
  docId_lt: String
  docId_lte: String
  docId_not: String
  docId_not_contains: String
  docId_not_ends_with: String
  docId_not_in: [String!]
  docId_not_starts_with: String
  docId_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [InvoiceWhereInput!]
  OR: [InvoiceWhereInput!]
  payment: PaymentWhereInput
  quotation: QuotationWhereInput
  saleman: SalemanWhereInput
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
  user: UserWhereInput
}

input InvoiceWhereUniqueInput {
  id: ID
}

scalar Long

type Me {
  token: String!
  user: User!
}

type Mutation {
  createAddress(data: AddressCreateInput!): Address!
  createCategory(data: CategoryCreateInput!): Category!
  createImage(data: ImageCreateInput!): Image!
  createInvoice(data: InvoiceCreateInput!): Invoice!
  createPayment(data: PaymentCreateInput!): Payment!
  createProductItem(data: ProductItemCreateInput!): ProductItem!
  createQuotation(data: QuotationCreateInput!): Quotation!
  createSaleman(data: SalemanCreateInput!): Saleman!
  createShipping(data: ShippingCreateInput!): Shipping!
  createShoppingCart(data: ShoppingCartCreateInput!): ShoppingCart!
  createUser(data: UserCreateInput!): User!
  deleteAddress(where: AddressWhereUniqueInput!): Address
  deleteCategory(where: CategoryWhereUniqueInput!): Category
  deleteImage(where: ImageWhereUniqueInput!): Image
  deleteInvoice(where: InvoiceWhereUniqueInput!): Invoice
  deleteManyAddresses(where: AddressWhereInput): BatchPayload!
  deleteManyCategories(where: CategoryWhereInput): BatchPayload!
  deleteManyImages(where: ImageWhereInput): BatchPayload!
  deleteManyInvoices(where: InvoiceWhereInput): BatchPayload!
  deleteManyPayments(where: PaymentWhereInput): BatchPayload!
  deleteManyProductItems(where: ProductItemWhereInput): BatchPayload!
  deleteManyQuotations(where: QuotationWhereInput): BatchPayload!
  deleteManySalemen(where: SalemanWhereInput): BatchPayload!
  deleteManyShippings(where: ShippingWhereInput): BatchPayload!
  deleteManyShoppingCarts(where: ShoppingCartWhereInput): BatchPayload!
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  deletePayment(where: PaymentWhereUniqueInput!): Payment
  deleteProductItem(where: ProductItemWhereUniqueInput!): ProductItem
  deleteQuotation(where: QuotationWhereUniqueInput!): Quotation
  deleteSaleman(where: SalemanWhereUniqueInput!): Saleman
  deleteShipping(where: ShippingWhereUniqueInput!): Shipping
  deleteShoppingCart(where: ShoppingCartWhereUniqueInput!): ShoppingCart
  deleteUser(where: UserWhereUniqueInput!): User
  login(email: String, password: String): Me
  register(data: UserCreateInput): Me
  updateAddress(data: AddressUpdateInput!, where: AddressWhereUniqueInput!): Address
  updateCategory(data: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category
  updateImage(data: ImageUpdateInput!, where: ImageWhereUniqueInput!): Image
  updateInvoice(data: InvoiceUpdateInput!, where: InvoiceWhereUniqueInput!): Invoice
  updateManyAddresses(data: AddressUpdateManyMutationInput!, where: AddressWhereInput): BatchPayload!
  updateManyCategories(data: CategoryUpdateManyMutationInput!, where: CategoryWhereInput): BatchPayload!
  updateManyImages(data: ImageUpdateManyMutationInput!, where: ImageWhereInput): BatchPayload!
  updateManyInvoices(data: InvoiceUpdateManyMutationInput!, where: InvoiceWhereInput): BatchPayload!
  updateManyPayments(data: PaymentUpdateManyMutationInput!, where: PaymentWhereInput): BatchPayload!
  updateManyProductItems(data: ProductItemUpdateManyMutationInput!, where: ProductItemWhereInput): BatchPayload!
  updateManyQuotations(data: QuotationUpdateManyMutationInput!, where: QuotationWhereInput): BatchPayload!
  updateManyShippings(data: ShippingUpdateManyMutationInput!, where: ShippingWhereInput): BatchPayload!
  updateManyShoppingCarts(data: ShoppingCartUpdateManyMutationInput!, where: ShoppingCartWhereInput): BatchPayload!
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  updatePayment(data: PaymentUpdateInput!, where: PaymentWhereUniqueInput!): Payment
  updateProductItem(data: ProductItemUpdateInput!, where: ProductItemWhereUniqueInput!): ProductItem
  updateQuotation(data: QuotationUpdateInput!, where: QuotationWhereUniqueInput!): Quotation
  updateSaleman(data: SalemanUpdateInput!, where: SalemanWhereUniqueInput!): Saleman
  updateShipping(data: ShippingUpdateInput!, where: ShippingWhereUniqueInput!): Shipping
  updateShoppingCart(data: ShoppingCartUpdateInput!, where: ShoppingCartWhereUniqueInput!): ShoppingCart
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertAddress(create: AddressCreateInput!, update: AddressUpdateInput!, where: AddressWhereUniqueInput!): Address!
  upsertCategory(create: CategoryCreateInput!, update: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category!
  upsertImage(create: ImageCreateInput!, update: ImageUpdateInput!, where: ImageWhereUniqueInput!): Image!
  upsertInvoice(create: InvoiceCreateInput!, update: InvoiceUpdateInput!, where: InvoiceWhereUniqueInput!): Invoice!
  upsertPayment(create: PaymentCreateInput!, update: PaymentUpdateInput!, where: PaymentWhereUniqueInput!): Payment!
  upsertProductItem(create: ProductItemCreateInput!, update: ProductItemUpdateInput!, where: ProductItemWhereUniqueInput!): ProductItem!
  upsertQuotation(create: QuotationCreateInput!, update: QuotationUpdateInput!, where: QuotationWhereUniqueInput!): Quotation!
  upsertSaleman(create: SalemanCreateInput!, update: SalemanUpdateInput!, where: SalemanWhereUniqueInput!): Saleman!
  upsertShipping(create: ShippingCreateInput!, update: ShippingUpdateInput!, where: ShippingWhereUniqueInput!): Shipping!
  upsertShoppingCart(create: ShoppingCartCreateInput!, update: ShoppingCartUpdateInput!, where: ShoppingCartWhereUniqueInput!): ShoppingCart!
  upsertUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Payment {
  amount: String!
  createdAt: DateTime!
  customer: User!
  docId: String!
  id: ID!
  Invoice: Invoice
  quotation: Quotation!
  saleman: Saleman!
  updatedAt: DateTime!
}

type PaymentConnection {
  aggregate: AggregatePayment!
  edges: [PaymentEdge!]!
  pageInfo: PageInfo!
}

input PaymentCreateInput {
  amount: String!
  customer: UserCreateOneWithoutPaymentsInput!
  docId: String!
  id: ID
  Invoice: InvoiceCreateOneWithoutPaymentInput
  quotation: QuotationCreateOneWithoutPaymentInput!
  saleman: SalemanCreateOneWithoutPaymentsInput!
}

input PaymentCreateManyWithoutCustomerInput {
  connect: [PaymentWhereUniqueInput!]
  create: [PaymentCreateWithoutCustomerInput!]
}

input PaymentCreateManyWithoutSalemanInput {
  connect: [PaymentWhereUniqueInput!]
  create: [PaymentCreateWithoutSalemanInput!]
}

input PaymentCreateOneWithoutInvoiceInput {
  connect: PaymentWhereUniqueInput
  create: PaymentCreateWithoutInvoiceInput
}

input PaymentCreateOneWithoutQuotationInput {
  connect: PaymentWhereUniqueInput
  create: PaymentCreateWithoutQuotationInput
}

input PaymentCreateWithoutCustomerInput {
  amount: String!
  docId: String!
  id: ID
  Invoice: InvoiceCreateOneWithoutPaymentInput
  quotation: QuotationCreateOneWithoutPaymentInput!
  saleman: SalemanCreateOneWithoutPaymentsInput!
}

input PaymentCreateWithoutInvoiceInput {
  amount: String!
  customer: UserCreateOneWithoutPaymentsInput!
  docId: String!
  id: ID
  quotation: QuotationCreateOneWithoutPaymentInput!
  saleman: SalemanCreateOneWithoutPaymentsInput!
}

input PaymentCreateWithoutQuotationInput {
  amount: String!
  customer: UserCreateOneWithoutPaymentsInput!
  docId: String!
  id: ID
  Invoice: InvoiceCreateOneWithoutPaymentInput
  saleman: SalemanCreateOneWithoutPaymentsInput!
}

input PaymentCreateWithoutSalemanInput {
  amount: String!
  customer: UserCreateOneWithoutPaymentsInput!
  docId: String!
  id: ID
  Invoice: InvoiceCreateOneWithoutPaymentInput
  quotation: QuotationCreateOneWithoutPaymentInput!
}

type PaymentEdge {
  cursor: String!
  node: Payment!
}

enum PaymentOrderByInput {
  amount_ASC
  amount_DESC
  createdAt_ASC
  createdAt_DESC
  docId_ASC
  docId_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input PaymentScalarWhereInput {
  amount: String
  amount_contains: String
  amount_ends_with: String
  amount_gt: String
  amount_gte: String
  amount_in: [String!]
  amount_lt: String
  amount_lte: String
  amount_not: String
  amount_not_contains: String
  amount_not_ends_with: String
  amount_not_in: [String!]
  amount_not_starts_with: String
  amount_starts_with: String
  AND: [PaymentScalarWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  docId: String
  docId_contains: String
  docId_ends_with: String
  docId_gt: String
  docId_gte: String
  docId_in: [String!]
  docId_lt: String
  docId_lte: String
  docId_not: String
  docId_not_contains: String
  docId_not_ends_with: String
  docId_not_in: [String!]
  docId_not_starts_with: String
  docId_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [PaymentScalarWhereInput!]
  OR: [PaymentScalarWhereInput!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input PaymentUpdateInput {
  amount: String
  customer: UserUpdateOneRequiredWithoutPaymentsInput
  docId: String
  Invoice: InvoiceUpdateOneWithoutPaymentInput
  quotation: QuotationUpdateOneRequiredWithoutPaymentInput
  saleman: SalemanUpdateOneRequiredWithoutPaymentsInput
}

input PaymentUpdateManyDataInput {
  amount: String
  docId: String
}

input PaymentUpdateManyMutationInput {
  amount: String
  docId: String
}

input PaymentUpdateManyWithoutCustomerInput {
  connect: [PaymentWhereUniqueInput!]
  create: [PaymentCreateWithoutCustomerInput!]
  delete: [PaymentWhereUniqueInput!]
  deleteMany: [PaymentScalarWhereInput!]
  disconnect: [PaymentWhereUniqueInput!]
  set: [PaymentWhereUniqueInput!]
  update: [PaymentUpdateWithWhereUniqueWithoutCustomerInput!]
  updateMany: [PaymentUpdateManyWithWhereNestedInput!]
  upsert: [PaymentUpsertWithWhereUniqueWithoutCustomerInput!]
}

input PaymentUpdateManyWithoutSalemanInput {
  connect: [PaymentWhereUniqueInput!]
  create: [PaymentCreateWithoutSalemanInput!]
  delete: [PaymentWhereUniqueInput!]
  deleteMany: [PaymentScalarWhereInput!]
  disconnect: [PaymentWhereUniqueInput!]
  set: [PaymentWhereUniqueInput!]
  update: [PaymentUpdateWithWhereUniqueWithoutSalemanInput!]
  updateMany: [PaymentUpdateManyWithWhereNestedInput!]
  upsert: [PaymentUpsertWithWhereUniqueWithoutSalemanInput!]
}

input PaymentUpdateManyWithWhereNestedInput {
  data: PaymentUpdateManyDataInput!
  where: PaymentScalarWhereInput!
}

input PaymentUpdateOneWithoutInvoiceInput {
  connect: PaymentWhereUniqueInput
  create: PaymentCreateWithoutInvoiceInput
  delete: Boolean
  disconnect: Boolean
  update: PaymentUpdateWithoutInvoiceDataInput
  upsert: PaymentUpsertWithoutInvoiceInput
}

input PaymentUpdateOneWithoutQuotationInput {
  connect: PaymentWhereUniqueInput
  create: PaymentCreateWithoutQuotationInput
  delete: Boolean
  disconnect: Boolean
  update: PaymentUpdateWithoutQuotationDataInput
  upsert: PaymentUpsertWithoutQuotationInput
}

input PaymentUpdateWithoutCustomerDataInput {
  amount: String
  docId: String
  Invoice: InvoiceUpdateOneWithoutPaymentInput
  quotation: QuotationUpdateOneRequiredWithoutPaymentInput
  saleman: SalemanUpdateOneRequiredWithoutPaymentsInput
}

input PaymentUpdateWithoutInvoiceDataInput {
  amount: String
  customer: UserUpdateOneRequiredWithoutPaymentsInput
  docId: String
  quotation: QuotationUpdateOneRequiredWithoutPaymentInput
  saleman: SalemanUpdateOneRequiredWithoutPaymentsInput
}

input PaymentUpdateWithoutQuotationDataInput {
  amount: String
  customer: UserUpdateOneRequiredWithoutPaymentsInput
  docId: String
  Invoice: InvoiceUpdateOneWithoutPaymentInput
  saleman: SalemanUpdateOneRequiredWithoutPaymentsInput
}

input PaymentUpdateWithoutSalemanDataInput {
  amount: String
  customer: UserUpdateOneRequiredWithoutPaymentsInput
  docId: String
  Invoice: InvoiceUpdateOneWithoutPaymentInput
  quotation: QuotationUpdateOneRequiredWithoutPaymentInput
}

input PaymentUpdateWithWhereUniqueWithoutCustomerInput {
  data: PaymentUpdateWithoutCustomerDataInput!
  where: PaymentWhereUniqueInput!
}

input PaymentUpdateWithWhereUniqueWithoutSalemanInput {
  data: PaymentUpdateWithoutSalemanDataInput!
  where: PaymentWhereUniqueInput!
}

input PaymentUpsertWithoutInvoiceInput {
  create: PaymentCreateWithoutInvoiceInput!
  update: PaymentUpdateWithoutInvoiceDataInput!
}

input PaymentUpsertWithoutQuotationInput {
  create: PaymentCreateWithoutQuotationInput!
  update: PaymentUpdateWithoutQuotationDataInput!
}

input PaymentUpsertWithWhereUniqueWithoutCustomerInput {
  create: PaymentCreateWithoutCustomerInput!
  update: PaymentUpdateWithoutCustomerDataInput!
  where: PaymentWhereUniqueInput!
}

input PaymentUpsertWithWhereUniqueWithoutSalemanInput {
  create: PaymentCreateWithoutSalemanInput!
  update: PaymentUpdateWithoutSalemanDataInput!
  where: PaymentWhereUniqueInput!
}

input PaymentWhereInput {
  amount: String
  amount_contains: String
  amount_ends_with: String
  amount_gt: String
  amount_gte: String
  amount_in: [String!]
  amount_lt: String
  amount_lte: String
  amount_not: String
  amount_not_contains: String
  amount_not_ends_with: String
  amount_not_in: [String!]
  amount_not_starts_with: String
  amount_starts_with: String
  AND: [PaymentWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  customer: UserWhereInput
  docId: String
  docId_contains: String
  docId_ends_with: String
  docId_gt: String
  docId_gte: String
  docId_in: [String!]
  docId_lt: String
  docId_lte: String
  docId_not: String
  docId_not_contains: String
  docId_not_ends_with: String
  docId_not_in: [String!]
  docId_not_starts_with: String
  docId_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  Invoice: InvoiceWhereInput
  NOT: [PaymentWhereInput!]
  OR: [PaymentWhereInput!]
  quotation: QuotationWhereInput
  saleman: SalemanWhereInput
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input PaymentWhereUniqueInput {
  id: ID
}

type ProductItem {
  amount: Int!
  brand: String!
  category: Category!
  createdAt: DateTime!
  description: String
  id: ID!
  image: Image!
  isPublished: Boolean!
  MenuDetail: String!
  name: String!
  price: String!
  quotation: Quotation
  relatedProduct(after: String, before: String, first: Int, last: Int, orderBy: ProductItemOrderByInput, skip: Int, where: ProductItemWhereInput): [ProductItem!]
  salePrice: String!
  shoppingCart: ShoppingCart
  TermDetail: String!
  unitType: String!
  updatedAt: DateTime!
}

type ProductItemConnection {
  aggregate: AggregateProductItem!
  edges: [ProductItemEdge!]!
  pageInfo: PageInfo!
}

input ProductItemCreateInput {
  amount: Int!
  brand: String!
  category: CategoryCreateOneWithoutProductItemInput!
  description: String
  id: ID
  image: ImageCreateOneInput!
  isPublished: Boolean
  MenuDetail: String!
  name: String!
  price: String!
  quotation: QuotationCreateOneWithoutProductItemsInput
  relatedProduct: ProductItemCreateManyInput
  salePrice: String!
  shoppingCart: ShoppingCartCreateOneWithoutProductItemsInput
  TermDetail: String!
  unitType: String!
}

input ProductItemCreateManyInput {
  connect: [ProductItemWhereUniqueInput!]
  create: [ProductItemCreateInput!]
}

input ProductItemCreateManyWithoutCategoryInput {
  connect: [ProductItemWhereUniqueInput!]
  create: [ProductItemCreateWithoutCategoryInput!]
}

input ProductItemCreateManyWithoutQuotationInput {
  connect: [ProductItemWhereUniqueInput!]
  create: [ProductItemCreateWithoutQuotationInput!]
}

input ProductItemCreateManyWithoutShoppingCartInput {
  connect: [ProductItemWhereUniqueInput!]
  create: [ProductItemCreateWithoutShoppingCartInput!]
}

input ProductItemCreateWithoutCategoryInput {
  amount: Int!
  brand: String!
  description: String
  id: ID
  image: ImageCreateOneInput!
  isPublished: Boolean
  MenuDetail: String!
  name: String!
  price: String!
  quotation: QuotationCreateOneWithoutProductItemsInput
  relatedProduct: ProductItemCreateManyInput
  salePrice: String!
  shoppingCart: ShoppingCartCreateOneWithoutProductItemsInput
  TermDetail: String!
  unitType: String!
}

input ProductItemCreateWithoutQuotationInput {
  amount: Int!
  brand: String!
  category: CategoryCreateOneWithoutProductItemInput!
  description: String
  id: ID
  image: ImageCreateOneInput!
  isPublished: Boolean
  MenuDetail: String!
  name: String!
  price: String!
  relatedProduct: ProductItemCreateManyInput
  salePrice: String!
  shoppingCart: ShoppingCartCreateOneWithoutProductItemsInput
  TermDetail: String!
  unitType: String!
}

input ProductItemCreateWithoutShoppingCartInput {
  amount: Int!
  brand: String!
  category: CategoryCreateOneWithoutProductItemInput!
  description: String
  id: ID
  image: ImageCreateOneInput!
  isPublished: Boolean
  MenuDetail: String!
  name: String!
  price: String!
  quotation: QuotationCreateOneWithoutProductItemsInput
  relatedProduct: ProductItemCreateManyInput
  salePrice: String!
  TermDetail: String!
  unitType: String!
}

type ProductItemEdge {
  cursor: String!
  node: ProductItem!
}

enum ProductItemOrderByInput {
  amount_ASC
  amount_DESC
  brand_ASC
  brand_DESC
  createdAt_ASC
  createdAt_DESC
  description_ASC
  description_DESC
  id_ASC
  id_DESC
  isPublished_ASC
  isPublished_DESC
  MenuDetail_ASC
  MenuDetail_DESC
  name_ASC
  name_DESC
  price_ASC
  price_DESC
  salePrice_ASC
  salePrice_DESC
  TermDetail_ASC
  TermDetail_DESC
  unitType_ASC
  unitType_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input ProductItemScalarWhereInput {
  amount: Int
  amount_gt: Int
  amount_gte: Int
  amount_in: [Int!]
  amount_lt: Int
  amount_lte: Int
  amount_not: Int
  amount_not_in: [Int!]
  AND: [ProductItemScalarWhereInput!]
  brand: String
  brand_contains: String
  brand_ends_with: String
  brand_gt: String
  brand_gte: String
  brand_in: [String!]
  brand_lt: String
  brand_lte: String
  brand_not: String
  brand_not_contains: String
  brand_not_ends_with: String
  brand_not_in: [String!]
  brand_not_starts_with: String
  brand_starts_with: String
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  description: String
  description_contains: String
  description_ends_with: String
  description_gt: String
  description_gte: String
  description_in: [String!]
  description_lt: String
  description_lte: String
  description_not: String
  description_not_contains: String
  description_not_ends_with: String
  description_not_in: [String!]
  description_not_starts_with: String
  description_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  isPublished: Boolean
  isPublished_not: Boolean
  MenuDetail: String
  MenuDetail_contains: String
  MenuDetail_ends_with: String
  MenuDetail_gt: String
  MenuDetail_gte: String
  MenuDetail_in: [String!]
  MenuDetail_lt: String
  MenuDetail_lte: String
  MenuDetail_not: String
  MenuDetail_not_contains: String
  MenuDetail_not_ends_with: String
  MenuDetail_not_in: [String!]
  MenuDetail_not_starts_with: String
  MenuDetail_starts_with: String
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [ProductItemScalarWhereInput!]
  OR: [ProductItemScalarWhereInput!]
  price: String
  price_contains: String
  price_ends_with: String
  price_gt: String
  price_gte: String
  price_in: [String!]
  price_lt: String
  price_lte: String
  price_not: String
  price_not_contains: String
  price_not_ends_with: String
  price_not_in: [String!]
  price_not_starts_with: String
  price_starts_with: String
  salePrice: String
  salePrice_contains: String
  salePrice_ends_with: String
  salePrice_gt: String
  salePrice_gte: String
  salePrice_in: [String!]
  salePrice_lt: String
  salePrice_lte: String
  salePrice_not: String
  salePrice_not_contains: String
  salePrice_not_ends_with: String
  salePrice_not_in: [String!]
  salePrice_not_starts_with: String
  salePrice_starts_with: String
  TermDetail: String
  TermDetail_contains: String
  TermDetail_ends_with: String
  TermDetail_gt: String
  TermDetail_gte: String
  TermDetail_in: [String!]
  TermDetail_lt: String
  TermDetail_lte: String
  TermDetail_not: String
  TermDetail_not_contains: String
  TermDetail_not_ends_with: String
  TermDetail_not_in: [String!]
  TermDetail_not_starts_with: String
  TermDetail_starts_with: String
  unitType: String
  unitType_contains: String
  unitType_ends_with: String
  unitType_gt: String
  unitType_gte: String
  unitType_in: [String!]
  unitType_lt: String
  unitType_lte: String
  unitType_not: String
  unitType_not_contains: String
  unitType_not_ends_with: String
  unitType_not_in: [String!]
  unitType_not_starts_with: String
  unitType_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input ProductItemUpdateDataInput {
  amount: Int
  brand: String
  category: CategoryUpdateOneRequiredWithoutProductItemInput
  description: String
  image: ImageUpdateOneRequiredInput
  isPublished: Boolean
  MenuDetail: String
  name: String
  price: String
  quotation: QuotationUpdateOneWithoutProductItemsInput
  relatedProduct: ProductItemUpdateManyInput
  salePrice: String
  shoppingCart: ShoppingCartUpdateOneWithoutProductItemsInput
  TermDetail: String
  unitType: String
}

input ProductItemUpdateInput {
  amount: Int
  brand: String
  category: CategoryUpdateOneRequiredWithoutProductItemInput
  description: String
  image: ImageUpdateOneRequiredInput
  isPublished: Boolean
  MenuDetail: String
  name: String
  price: String
  quotation: QuotationUpdateOneWithoutProductItemsInput
  relatedProduct: ProductItemUpdateManyInput
  salePrice: String
  shoppingCart: ShoppingCartUpdateOneWithoutProductItemsInput
  TermDetail: String
  unitType: String
}

input ProductItemUpdateManyDataInput {
  amount: Int
  brand: String
  description: String
  isPublished: Boolean
  MenuDetail: String
  name: String
  price: String
  salePrice: String
  TermDetail: String
  unitType: String
}

input ProductItemUpdateManyInput {
  connect: [ProductItemWhereUniqueInput!]
  create: [ProductItemCreateInput!]
  delete: [ProductItemWhereUniqueInput!]
  deleteMany: [ProductItemScalarWhereInput!]
  disconnect: [ProductItemWhereUniqueInput!]
  set: [ProductItemWhereUniqueInput!]
  update: [ProductItemUpdateWithWhereUniqueNestedInput!]
  updateMany: [ProductItemUpdateManyWithWhereNestedInput!]
  upsert: [ProductItemUpsertWithWhereUniqueNestedInput!]
}

input ProductItemUpdateManyMutationInput {
  amount: Int
  brand: String
  description: String
  isPublished: Boolean
  MenuDetail: String
  name: String
  price: String
  salePrice: String
  TermDetail: String
  unitType: String
}

input ProductItemUpdateManyWithoutCategoryInput {
  connect: [ProductItemWhereUniqueInput!]
  create: [ProductItemCreateWithoutCategoryInput!]
  delete: [ProductItemWhereUniqueInput!]
  deleteMany: [ProductItemScalarWhereInput!]
  disconnect: [ProductItemWhereUniqueInput!]
  set: [ProductItemWhereUniqueInput!]
  update: [ProductItemUpdateWithWhereUniqueWithoutCategoryInput!]
  updateMany: [ProductItemUpdateManyWithWhereNestedInput!]
  upsert: [ProductItemUpsertWithWhereUniqueWithoutCategoryInput!]
}

input ProductItemUpdateManyWithoutQuotationInput {
  connect: [ProductItemWhereUniqueInput!]
  create: [ProductItemCreateWithoutQuotationInput!]
  delete: [ProductItemWhereUniqueInput!]
  deleteMany: [ProductItemScalarWhereInput!]
  disconnect: [ProductItemWhereUniqueInput!]
  set: [ProductItemWhereUniqueInput!]
  update: [ProductItemUpdateWithWhereUniqueWithoutQuotationInput!]
  updateMany: [ProductItemUpdateManyWithWhereNestedInput!]
  upsert: [ProductItemUpsertWithWhereUniqueWithoutQuotationInput!]
}

input ProductItemUpdateManyWithoutShoppingCartInput {
  connect: [ProductItemWhereUniqueInput!]
  create: [ProductItemCreateWithoutShoppingCartInput!]
  delete: [ProductItemWhereUniqueInput!]
  deleteMany: [ProductItemScalarWhereInput!]
  disconnect: [ProductItemWhereUniqueInput!]
  set: [ProductItemWhereUniqueInput!]
  update: [ProductItemUpdateWithWhereUniqueWithoutShoppingCartInput!]
  updateMany: [ProductItemUpdateManyWithWhereNestedInput!]
  upsert: [ProductItemUpsertWithWhereUniqueWithoutShoppingCartInput!]
}

input ProductItemUpdateManyWithWhereNestedInput {
  data: ProductItemUpdateManyDataInput!
  where: ProductItemScalarWhereInput!
}

input ProductItemUpdateWithoutCategoryDataInput {
  amount: Int
  brand: String
  description: String
  image: ImageUpdateOneRequiredInput
  isPublished: Boolean
  MenuDetail: String
  name: String
  price: String
  quotation: QuotationUpdateOneWithoutProductItemsInput
  relatedProduct: ProductItemUpdateManyInput
  salePrice: String
  shoppingCart: ShoppingCartUpdateOneWithoutProductItemsInput
  TermDetail: String
  unitType: String
}

input ProductItemUpdateWithoutQuotationDataInput {
  amount: Int
  brand: String
  category: CategoryUpdateOneRequiredWithoutProductItemInput
  description: String
  image: ImageUpdateOneRequiredInput
  isPublished: Boolean
  MenuDetail: String
  name: String
  price: String
  relatedProduct: ProductItemUpdateManyInput
  salePrice: String
  shoppingCart: ShoppingCartUpdateOneWithoutProductItemsInput
  TermDetail: String
  unitType: String
}

input ProductItemUpdateWithoutShoppingCartDataInput {
  amount: Int
  brand: String
  category: CategoryUpdateOneRequiredWithoutProductItemInput
  description: String
  image: ImageUpdateOneRequiredInput
  isPublished: Boolean
  MenuDetail: String
  name: String
  price: String
  quotation: QuotationUpdateOneWithoutProductItemsInput
  relatedProduct: ProductItemUpdateManyInput
  salePrice: String
  TermDetail: String
  unitType: String
}

input ProductItemUpdateWithWhereUniqueNestedInput {
  data: ProductItemUpdateDataInput!
  where: ProductItemWhereUniqueInput!
}

input ProductItemUpdateWithWhereUniqueWithoutCategoryInput {
  data: ProductItemUpdateWithoutCategoryDataInput!
  where: ProductItemWhereUniqueInput!
}

input ProductItemUpdateWithWhereUniqueWithoutQuotationInput {
  data: ProductItemUpdateWithoutQuotationDataInput!
  where: ProductItemWhereUniqueInput!
}

input ProductItemUpdateWithWhereUniqueWithoutShoppingCartInput {
  data: ProductItemUpdateWithoutShoppingCartDataInput!
  where: ProductItemWhereUniqueInput!
}

input ProductItemUpsertWithWhereUniqueNestedInput {
  create: ProductItemCreateInput!
  update: ProductItemUpdateDataInput!
  where: ProductItemWhereUniqueInput!
}

input ProductItemUpsertWithWhereUniqueWithoutCategoryInput {
  create: ProductItemCreateWithoutCategoryInput!
  update: ProductItemUpdateWithoutCategoryDataInput!
  where: ProductItemWhereUniqueInput!
}

input ProductItemUpsertWithWhereUniqueWithoutQuotationInput {
  create: ProductItemCreateWithoutQuotationInput!
  update: ProductItemUpdateWithoutQuotationDataInput!
  where: ProductItemWhereUniqueInput!
}

input ProductItemUpsertWithWhereUniqueWithoutShoppingCartInput {
  create: ProductItemCreateWithoutShoppingCartInput!
  update: ProductItemUpdateWithoutShoppingCartDataInput!
  where: ProductItemWhereUniqueInput!
}

input ProductItemWhereInput {
  amount: Int
  amount_gt: Int
  amount_gte: Int
  amount_in: [Int!]
  amount_lt: Int
  amount_lte: Int
  amount_not: Int
  amount_not_in: [Int!]
  AND: [ProductItemWhereInput!]
  brand: String
  brand_contains: String
  brand_ends_with: String
  brand_gt: String
  brand_gte: String
  brand_in: [String!]
  brand_lt: String
  brand_lte: String
  brand_not: String
  brand_not_contains: String
  brand_not_ends_with: String
  brand_not_in: [String!]
  brand_not_starts_with: String
  brand_starts_with: String
  category: CategoryWhereInput
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  description: String
  description_contains: String
  description_ends_with: String
  description_gt: String
  description_gte: String
  description_in: [String!]
  description_lt: String
  description_lte: String
  description_not: String
  description_not_contains: String
  description_not_ends_with: String
  description_not_in: [String!]
  description_not_starts_with: String
  description_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  image: ImageWhereInput
  isPublished: Boolean
  isPublished_not: Boolean
  MenuDetail: String
  MenuDetail_contains: String
  MenuDetail_ends_with: String
  MenuDetail_gt: String
  MenuDetail_gte: String
  MenuDetail_in: [String!]
  MenuDetail_lt: String
  MenuDetail_lte: String
  MenuDetail_not: String
  MenuDetail_not_contains: String
  MenuDetail_not_ends_with: String
  MenuDetail_not_in: [String!]
  MenuDetail_not_starts_with: String
  MenuDetail_starts_with: String
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [ProductItemWhereInput!]
  OR: [ProductItemWhereInput!]
  price: String
  price_contains: String
  price_ends_with: String
  price_gt: String
  price_gte: String
  price_in: [String!]
  price_lt: String
  price_lte: String
  price_not: String
  price_not_contains: String
  price_not_ends_with: String
  price_not_in: [String!]
  price_not_starts_with: String
  price_starts_with: String
  quotation: QuotationWhereInput
  relatedProduct_every: ProductItemWhereInput
  relatedProduct_none: ProductItemWhereInput
  relatedProduct_some: ProductItemWhereInput
  salePrice: String
  salePrice_contains: String
  salePrice_ends_with: String
  salePrice_gt: String
  salePrice_gte: String
  salePrice_in: [String!]
  salePrice_lt: String
  salePrice_lte: String
  salePrice_not: String
  salePrice_not_contains: String
  salePrice_not_ends_with: String
  salePrice_not_in: [String!]
  salePrice_not_starts_with: String
  salePrice_starts_with: String
  shoppingCart: ShoppingCartWhereInput
  TermDetail: String
  TermDetail_contains: String
  TermDetail_ends_with: String
  TermDetail_gt: String
  TermDetail_gte: String
  TermDetail_in: [String!]
  TermDetail_lt: String
  TermDetail_lte: String
  TermDetail_not: String
  TermDetail_not_contains: String
  TermDetail_not_ends_with: String
  TermDetail_not_in: [String!]
  TermDetail_not_starts_with: String
  TermDetail_starts_with: String
  unitType: String
  unitType_contains: String
  unitType_ends_with: String
  unitType_gt: String
  unitType_gte: String
  unitType_in: [String!]
  unitType_lt: String
  unitType_lte: String
  unitType_not: String
  unitType_not_contains: String
  unitType_not_ends_with: String
  unitType_not_in: [String!]
  unitType_not_starts_with: String
  unitType_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input ProductItemWhereUniqueInput {
  id: ID
}

type Query {
  address(where: AddressWhereUniqueInput!): Address
  addresses(after: String, before: String, first: Int, last: Int, orderBy: AddressOrderByInput, skip: Int, where: AddressWhereInput): [Address!]!
  addressesConnection(after: String, before: String, first: Int, last: Int, orderBy: AddressOrderByInput, skip: Int, where: AddressWhereInput): AddressConnection!
  categories(after: String, before: String, first: Int, last: Int, orderBy: CategoryOrderByInput, skip: Int, where: CategoryWhereInput): [Category!]!
  categoriesConnection(after: String, before: String, first: Int, last: Int, orderBy: CategoryOrderByInput, skip: Int, where: CategoryWhereInput): CategoryConnection!
  category(where: CategoryWhereUniqueInput!): Category
  image(where: ImageWhereUniqueInput!): Image
  images(after: String, before: String, first: Int, last: Int, orderBy: ImageOrderByInput, skip: Int, where: ImageWhereInput): [Image!]!
  imagesConnection(after: String, before: String, first: Int, last: Int, orderBy: ImageOrderByInput, skip: Int, where: ImageWhereInput): ImageConnection!
  invoice(where: InvoiceWhereUniqueInput!): Invoice
  invoices(after: String, before: String, first: Int, last: Int, orderBy: InvoiceOrderByInput, skip: Int, where: InvoiceWhereInput): [Invoice!]!
  invoicesConnection(after: String, before: String, first: Int, last: Int, orderBy: InvoiceOrderByInput, skip: Int, where: InvoiceWhereInput): InvoiceConnection!
  payment(where: PaymentWhereUniqueInput!): Payment
  payments(after: String, before: String, first: Int, last: Int, orderBy: PaymentOrderByInput, skip: Int, where: PaymentWhereInput): [Payment!]!
  paymentsConnection(after: String, before: String, first: Int, last: Int, orderBy: PaymentOrderByInput, skip: Int, where: PaymentWhereInput): PaymentConnection!
  productItem(where: ProductItemWhereUniqueInput!): ProductItem
  productItems(after: String, before: String, first: Int, last: Int, orderBy: ProductItemOrderByInput, skip: Int, where: ProductItemWhereInput): [ProductItem!]!
  productItemsConnection(after: String, before: String, first: Int, last: Int, orderBy: ProductItemOrderByInput, skip: Int, where: ProductItemWhereInput): ProductItemConnection!
  quotation(where: QuotationWhereUniqueInput!): Quotation
  quotations(after: String, before: String, first: Int, last: Int, orderBy: QuotationOrderByInput, skip: Int, where: QuotationWhereInput): [Quotation!]!
  quotationsConnection(after: String, before: String, first: Int, last: Int, orderBy: QuotationOrderByInput, skip: Int, where: QuotationWhereInput): QuotationConnection!
  saleman(where: SalemanWhereUniqueInput!): Saleman
  salemen(after: String, before: String, first: Int, last: Int, orderBy: SalemanOrderByInput, skip: Int, where: SalemanWhereInput): [Saleman!]!
  salemenConnection(after: String, before: String, first: Int, last: Int, orderBy: SalemanOrderByInput, skip: Int, where: SalemanWhereInput): SalemanConnection!
  shipping(where: ShippingWhereUniqueInput!): Shipping
  shippings(after: String, before: String, first: Int, last: Int, orderBy: ShippingOrderByInput, skip: Int, where: ShippingWhereInput): [Shipping!]!
  shippingsConnection(after: String, before: String, first: Int, last: Int, orderBy: ShippingOrderByInput, skip: Int, where: ShippingWhereInput): ShippingConnection!
  shoppingCart(where: ShoppingCartWhereUniqueInput!): ShoppingCart
  shoppingCarts(after: String, before: String, first: Int, last: Int, orderBy: ShoppingCartOrderByInput, skip: Int, where: ShoppingCartWhereInput): [ShoppingCart!]!
  shoppingCartsConnection(after: String, before: String, first: Int, last: Int, orderBy: ShoppingCartOrderByInput, skip: Int, where: ShoppingCartWhereInput): ShoppingCartConnection!
  user(where: UserWhereUniqueInput!): User
  users(after: String, before: String, first: Int, last: Int, orderBy: UserOrderByInput, skip: Int, where: UserWhereInput): [User!]!
  usersConnection(after: String, before: String, first: Int, last: Int, orderBy: UserOrderByInput, skip: Int, where: UserWhereInput): UserConnection!
}

type Quotation {
  createdAt: DateTime!
  customer: User!
  docId: String!
  id: ID!
  payment: Payment
  productItems(after: String, before: String, first: Int, last: Int, orderBy: ProductItemOrderByInput, skip: Int, where: ProductItemWhereInput): [ProductItem!]
  saleman: Saleman!
  shipping: Shipping
  updatedAt: DateTime!
}

type QuotationConnection {
  aggregate: AggregateQuotation!
  edges: [QuotationEdge!]!
  pageInfo: PageInfo!
}

input QuotationCreateInput {
  customer: UserCreateOneWithoutQuotationsInput!
  docId: String!
  id: ID
  payment: PaymentCreateOneWithoutQuotationInput
  productItems: ProductItemCreateManyWithoutQuotationInput
  saleman: SalemanCreateOneWithoutQuotationsInput!
  shipping: ShippingCreateOneWithoutQuotationInput
}

input QuotationCreateManyWithoutCustomerInput {
  connect: [QuotationWhereUniqueInput!]
  create: [QuotationCreateWithoutCustomerInput!]
}

input QuotationCreateManyWithoutSalemanInput {
  connect: [QuotationWhereUniqueInput!]
  create: [QuotationCreateWithoutSalemanInput!]
}

input QuotationCreateOneInput {
  connect: QuotationWhereUniqueInput
  create: QuotationCreateInput
}

input QuotationCreateOneWithoutPaymentInput {
  connect: QuotationWhereUniqueInput
  create: QuotationCreateWithoutPaymentInput
}

input QuotationCreateOneWithoutProductItemsInput {
  connect: QuotationWhereUniqueInput
  create: QuotationCreateWithoutProductItemsInput
}

input QuotationCreateOneWithoutShippingInput {
  connect: QuotationWhereUniqueInput
  create: QuotationCreateWithoutShippingInput
}

input QuotationCreateWithoutCustomerInput {
  docId: String!
  id: ID
  payment: PaymentCreateOneWithoutQuotationInput
  productItems: ProductItemCreateManyWithoutQuotationInput
  saleman: SalemanCreateOneWithoutQuotationsInput!
  shipping: ShippingCreateOneWithoutQuotationInput
}

input QuotationCreateWithoutPaymentInput {
  customer: UserCreateOneWithoutQuotationsInput!
  docId: String!
  id: ID
  productItems: ProductItemCreateManyWithoutQuotationInput
  saleman: SalemanCreateOneWithoutQuotationsInput!
  shipping: ShippingCreateOneWithoutQuotationInput
}

input QuotationCreateWithoutProductItemsInput {
  customer: UserCreateOneWithoutQuotationsInput!
  docId: String!
  id: ID
  payment: PaymentCreateOneWithoutQuotationInput
  saleman: SalemanCreateOneWithoutQuotationsInput!
  shipping: ShippingCreateOneWithoutQuotationInput
}

input QuotationCreateWithoutSalemanInput {
  customer: UserCreateOneWithoutQuotationsInput!
  docId: String!
  id: ID
  payment: PaymentCreateOneWithoutQuotationInput
  productItems: ProductItemCreateManyWithoutQuotationInput
  shipping: ShippingCreateOneWithoutQuotationInput
}

input QuotationCreateWithoutShippingInput {
  customer: UserCreateOneWithoutQuotationsInput!
  docId: String!
  id: ID
  payment: PaymentCreateOneWithoutQuotationInput
  productItems: ProductItemCreateManyWithoutQuotationInput
  saleman: SalemanCreateOneWithoutQuotationsInput!
}

type QuotationEdge {
  cursor: String!
  node: Quotation!
}

enum QuotationOrderByInput {
  createdAt_ASC
  createdAt_DESC
  docId_ASC
  docId_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input QuotationScalarWhereInput {
  AND: [QuotationScalarWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  docId: String
  docId_contains: String
  docId_ends_with: String
  docId_gt: String
  docId_gte: String
  docId_in: [String!]
  docId_lt: String
  docId_lte: String
  docId_not: String
  docId_not_contains: String
  docId_not_ends_with: String
  docId_not_in: [String!]
  docId_not_starts_with: String
  docId_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [QuotationScalarWhereInput!]
  OR: [QuotationScalarWhereInput!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input QuotationUpdateDataInput {
  customer: UserUpdateOneRequiredWithoutQuotationsInput
  docId: String
  payment: PaymentUpdateOneWithoutQuotationInput
  productItems: ProductItemUpdateManyWithoutQuotationInput
  saleman: SalemanUpdateOneRequiredWithoutQuotationsInput
  shipping: ShippingUpdateOneWithoutQuotationInput
}

input QuotationUpdateInput {
  customer: UserUpdateOneRequiredWithoutQuotationsInput
  docId: String
  payment: PaymentUpdateOneWithoutQuotationInput
  productItems: ProductItemUpdateManyWithoutQuotationInput
  saleman: SalemanUpdateOneRequiredWithoutQuotationsInput
  shipping: ShippingUpdateOneWithoutQuotationInput
}

input QuotationUpdateManyDataInput {
  docId: String
}

input QuotationUpdateManyMutationInput {
  docId: String
}

input QuotationUpdateManyWithoutCustomerInput {
  connect: [QuotationWhereUniqueInput!]
  create: [QuotationCreateWithoutCustomerInput!]
  delete: [QuotationWhereUniqueInput!]
  deleteMany: [QuotationScalarWhereInput!]
  disconnect: [QuotationWhereUniqueInput!]
  set: [QuotationWhereUniqueInput!]
  update: [QuotationUpdateWithWhereUniqueWithoutCustomerInput!]
  updateMany: [QuotationUpdateManyWithWhereNestedInput!]
  upsert: [QuotationUpsertWithWhereUniqueWithoutCustomerInput!]
}

input QuotationUpdateManyWithoutSalemanInput {
  connect: [QuotationWhereUniqueInput!]
  create: [QuotationCreateWithoutSalemanInput!]
  delete: [QuotationWhereUniqueInput!]
  deleteMany: [QuotationScalarWhereInput!]
  disconnect: [QuotationWhereUniqueInput!]
  set: [QuotationWhereUniqueInput!]
  update: [QuotationUpdateWithWhereUniqueWithoutSalemanInput!]
  updateMany: [QuotationUpdateManyWithWhereNestedInput!]
  upsert: [QuotationUpsertWithWhereUniqueWithoutSalemanInput!]
}

input QuotationUpdateManyWithWhereNestedInput {
  data: QuotationUpdateManyDataInput!
  where: QuotationScalarWhereInput!
}

input QuotationUpdateOneRequiredInput {
  connect: QuotationWhereUniqueInput
  create: QuotationCreateInput
  update: QuotationUpdateDataInput
  upsert: QuotationUpsertNestedInput
}

input QuotationUpdateOneRequiredWithoutPaymentInput {
  connect: QuotationWhereUniqueInput
  create: QuotationCreateWithoutPaymentInput
  update: QuotationUpdateWithoutPaymentDataInput
  upsert: QuotationUpsertWithoutPaymentInput
}

input QuotationUpdateOneRequiredWithoutShippingInput {
  connect: QuotationWhereUniqueInput
  create: QuotationCreateWithoutShippingInput
  update: QuotationUpdateWithoutShippingDataInput
  upsert: QuotationUpsertWithoutShippingInput
}

input QuotationUpdateOneWithoutProductItemsInput {
  connect: QuotationWhereUniqueInput
  create: QuotationCreateWithoutProductItemsInput
  delete: Boolean
  disconnect: Boolean
  update: QuotationUpdateWithoutProductItemsDataInput
  upsert: QuotationUpsertWithoutProductItemsInput
}

input QuotationUpdateWithoutCustomerDataInput {
  docId: String
  payment: PaymentUpdateOneWithoutQuotationInput
  productItems: ProductItemUpdateManyWithoutQuotationInput
  saleman: SalemanUpdateOneRequiredWithoutQuotationsInput
  shipping: ShippingUpdateOneWithoutQuotationInput
}

input QuotationUpdateWithoutPaymentDataInput {
  customer: UserUpdateOneRequiredWithoutQuotationsInput
  docId: String
  productItems: ProductItemUpdateManyWithoutQuotationInput
  saleman: SalemanUpdateOneRequiredWithoutQuotationsInput
  shipping: ShippingUpdateOneWithoutQuotationInput
}

input QuotationUpdateWithoutProductItemsDataInput {
  customer: UserUpdateOneRequiredWithoutQuotationsInput
  docId: String
  payment: PaymentUpdateOneWithoutQuotationInput
  saleman: SalemanUpdateOneRequiredWithoutQuotationsInput
  shipping: ShippingUpdateOneWithoutQuotationInput
}

input QuotationUpdateWithoutSalemanDataInput {
  customer: UserUpdateOneRequiredWithoutQuotationsInput
  docId: String
  payment: PaymentUpdateOneWithoutQuotationInput
  productItems: ProductItemUpdateManyWithoutQuotationInput
  shipping: ShippingUpdateOneWithoutQuotationInput
}

input QuotationUpdateWithoutShippingDataInput {
  customer: UserUpdateOneRequiredWithoutQuotationsInput
  docId: String
  payment: PaymentUpdateOneWithoutQuotationInput
  productItems: ProductItemUpdateManyWithoutQuotationInput
  saleman: SalemanUpdateOneRequiredWithoutQuotationsInput
}

input QuotationUpdateWithWhereUniqueWithoutCustomerInput {
  data: QuotationUpdateWithoutCustomerDataInput!
  where: QuotationWhereUniqueInput!
}

input QuotationUpdateWithWhereUniqueWithoutSalemanInput {
  data: QuotationUpdateWithoutSalemanDataInput!
  where: QuotationWhereUniqueInput!
}

input QuotationUpsertNestedInput {
  create: QuotationCreateInput!
  update: QuotationUpdateDataInput!
}

input QuotationUpsertWithoutPaymentInput {
  create: QuotationCreateWithoutPaymentInput!
  update: QuotationUpdateWithoutPaymentDataInput!
}

input QuotationUpsertWithoutProductItemsInput {
  create: QuotationCreateWithoutProductItemsInput!
  update: QuotationUpdateWithoutProductItemsDataInput!
}

input QuotationUpsertWithoutShippingInput {
  create: QuotationCreateWithoutShippingInput!
  update: QuotationUpdateWithoutShippingDataInput!
}

input QuotationUpsertWithWhereUniqueWithoutCustomerInput {
  create: QuotationCreateWithoutCustomerInput!
  update: QuotationUpdateWithoutCustomerDataInput!
  where: QuotationWhereUniqueInput!
}

input QuotationUpsertWithWhereUniqueWithoutSalemanInput {
  create: QuotationCreateWithoutSalemanInput!
  update: QuotationUpdateWithoutSalemanDataInput!
  where: QuotationWhereUniqueInput!
}

input QuotationWhereInput {
  AND: [QuotationWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  customer: UserWhereInput
  docId: String
  docId_contains: String
  docId_ends_with: String
  docId_gt: String
  docId_gte: String
  docId_in: [String!]
  docId_lt: String
  docId_lte: String
  docId_not: String
  docId_not_contains: String
  docId_not_ends_with: String
  docId_not_in: [String!]
  docId_not_starts_with: String
  docId_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [QuotationWhereInput!]
  OR: [QuotationWhereInput!]
  payment: PaymentWhereInput
  productItems_every: ProductItemWhereInput
  productItems_none: ProductItemWhereInput
  productItems_some: ProductItemWhereInput
  saleman: SalemanWhereInput
  shipping: ShippingWhereInput
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input QuotationWhereUniqueInput {
  id: ID
}

type Saleman {
  createdAt: DateTime!
  id: ID!
  invoices(after: String, before: String, first: Int, last: Int, orderBy: InvoiceOrderByInput, skip: Int, where: InvoiceWhereInput): [Invoice!]
  payments(after: String, before: String, first: Int, last: Int, orderBy: PaymentOrderByInput, skip: Int, where: PaymentWhereInput): [Payment!]
  quotations(after: String, before: String, first: Int, last: Int, orderBy: QuotationOrderByInput, skip: Int, where: QuotationWhereInput): [Quotation!]
  updatedAt: DateTime!
}

type SalemanConnection {
  aggregate: AggregateSaleman!
  edges: [SalemanEdge!]!
  pageInfo: PageInfo!
}

input SalemanCreateInput {
  id: ID
  invoices: InvoiceCreateManyWithoutSalemanInput
  payments: PaymentCreateManyWithoutSalemanInput
  quotations: QuotationCreateManyWithoutSalemanInput
}

input SalemanCreateOneWithoutInvoicesInput {
  connect: SalemanWhereUniqueInput
  create: SalemanCreateWithoutInvoicesInput
}

input SalemanCreateOneWithoutPaymentsInput {
  connect: SalemanWhereUniqueInput
  create: SalemanCreateWithoutPaymentsInput
}

input SalemanCreateOneWithoutQuotationsInput {
  connect: SalemanWhereUniqueInput
  create: SalemanCreateWithoutQuotationsInput
}

input SalemanCreateWithoutInvoicesInput {
  id: ID
  payments: PaymentCreateManyWithoutSalemanInput
  quotations: QuotationCreateManyWithoutSalemanInput
}

input SalemanCreateWithoutPaymentsInput {
  id: ID
  invoices: InvoiceCreateManyWithoutSalemanInput
  quotations: QuotationCreateManyWithoutSalemanInput
}

input SalemanCreateWithoutQuotationsInput {
  id: ID
  invoices: InvoiceCreateManyWithoutSalemanInput
  payments: PaymentCreateManyWithoutSalemanInput
}

type SalemanEdge {
  cursor: String!
  node: Saleman!
}

enum SalemanOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input SalemanUpdateInput {
  invoices: InvoiceUpdateManyWithoutSalemanInput
  payments: PaymentUpdateManyWithoutSalemanInput
  quotations: QuotationUpdateManyWithoutSalemanInput
}

input SalemanUpdateOneRequiredWithoutInvoicesInput {
  connect: SalemanWhereUniqueInput
  create: SalemanCreateWithoutInvoicesInput
  update: SalemanUpdateWithoutInvoicesDataInput
  upsert: SalemanUpsertWithoutInvoicesInput
}

input SalemanUpdateOneRequiredWithoutPaymentsInput {
  connect: SalemanWhereUniqueInput
  create: SalemanCreateWithoutPaymentsInput
  update: SalemanUpdateWithoutPaymentsDataInput
  upsert: SalemanUpsertWithoutPaymentsInput
}

input SalemanUpdateOneRequiredWithoutQuotationsInput {
  connect: SalemanWhereUniqueInput
  create: SalemanCreateWithoutQuotationsInput
  update: SalemanUpdateWithoutQuotationsDataInput
  upsert: SalemanUpsertWithoutQuotationsInput
}

input SalemanUpdateWithoutInvoicesDataInput {
  payments: PaymentUpdateManyWithoutSalemanInput
  quotations: QuotationUpdateManyWithoutSalemanInput
}

input SalemanUpdateWithoutPaymentsDataInput {
  invoices: InvoiceUpdateManyWithoutSalemanInput
  quotations: QuotationUpdateManyWithoutSalemanInput
}

input SalemanUpdateWithoutQuotationsDataInput {
  invoices: InvoiceUpdateManyWithoutSalemanInput
  payments: PaymentUpdateManyWithoutSalemanInput
}

input SalemanUpsertWithoutInvoicesInput {
  create: SalemanCreateWithoutInvoicesInput!
  update: SalemanUpdateWithoutInvoicesDataInput!
}

input SalemanUpsertWithoutPaymentsInput {
  create: SalemanCreateWithoutPaymentsInput!
  update: SalemanUpdateWithoutPaymentsDataInput!
}

input SalemanUpsertWithoutQuotationsInput {
  create: SalemanCreateWithoutQuotationsInput!
  update: SalemanUpdateWithoutQuotationsDataInput!
}

input SalemanWhereInput {
  AND: [SalemanWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  invoices_every: InvoiceWhereInput
  invoices_none: InvoiceWhereInput
  invoices_some: InvoiceWhereInput
  NOT: [SalemanWhereInput!]
  OR: [SalemanWhereInput!]
  payments_every: PaymentWhereInput
  payments_none: PaymentWhereInput
  payments_some: PaymentWhereInput
  quotations_every: QuotationWhereInput
  quotations_none: QuotationWhereInput
  quotations_some: QuotationWhereInput
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input SalemanWhereUniqueInput {
  id: ID
}

type Shipping {
  address: Address!
  createdAt: DateTime!
  docId: String!
  dueDate: DateTime!
  id: ID!
  invoce: Invoice!
  quotation: Quotation!
  status: String!
  updatedAt: DateTime!
}

type ShippingConnection {
  aggregate: AggregateShipping!
  edges: [ShippingEdge!]!
  pageInfo: PageInfo!
}

input ShippingCreateInput {
  address: AddressCreateOneWithoutShippingInput!
  docId: String!
  dueDate: DateTime!
  id: ID
  invoce: InvoiceCreateOneInput!
  quotation: QuotationCreateOneWithoutShippingInput!
  status: String!
}

input ShippingCreateManyWithoutAddressInput {
  connect: [ShippingWhereUniqueInput!]
  create: [ShippingCreateWithoutAddressInput!]
}

input ShippingCreateOneWithoutQuotationInput {
  connect: ShippingWhereUniqueInput
  create: ShippingCreateWithoutQuotationInput
}

input ShippingCreateWithoutAddressInput {
  docId: String!
  dueDate: DateTime!
  id: ID
  invoce: InvoiceCreateOneInput!
  quotation: QuotationCreateOneWithoutShippingInput!
  status: String!
}

input ShippingCreateWithoutQuotationInput {
  address: AddressCreateOneWithoutShippingInput!
  docId: String!
  dueDate: DateTime!
  id: ID
  invoce: InvoiceCreateOneInput!
  status: String!
}

type ShippingEdge {
  cursor: String!
  node: Shipping!
}

enum ShippingOrderByInput {
  createdAt_ASC
  createdAt_DESC
  docId_ASC
  docId_DESC
  dueDate_ASC
  dueDate_DESC
  id_ASC
  id_DESC
  status_ASC
  status_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input ShippingScalarWhereInput {
  AND: [ShippingScalarWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  docId: String
  docId_contains: String
  docId_ends_with: String
  docId_gt: String
  docId_gte: String
  docId_in: [String!]
  docId_lt: String
  docId_lte: String
  docId_not: String
  docId_not_contains: String
  docId_not_ends_with: String
  docId_not_in: [String!]
  docId_not_starts_with: String
  docId_starts_with: String
  dueDate: DateTime
  dueDate_gt: DateTime
  dueDate_gte: DateTime
  dueDate_in: [DateTime!]
  dueDate_lt: DateTime
  dueDate_lte: DateTime
  dueDate_not: DateTime
  dueDate_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [ShippingScalarWhereInput!]
  OR: [ShippingScalarWhereInput!]
  status: String
  status_contains: String
  status_ends_with: String
  status_gt: String
  status_gte: String
  status_in: [String!]
  status_lt: String
  status_lte: String
  status_not: String
  status_not_contains: String
  status_not_ends_with: String
  status_not_in: [String!]
  status_not_starts_with: String
  status_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input ShippingUpdateInput {
  address: AddressUpdateOneRequiredWithoutShippingInput
  docId: String
  dueDate: DateTime
  invoce: InvoiceUpdateOneRequiredInput
  quotation: QuotationUpdateOneRequiredWithoutShippingInput
  status: String
}

input ShippingUpdateManyDataInput {
  docId: String
  dueDate: DateTime
  status: String
}

input ShippingUpdateManyMutationInput {
  docId: String
  dueDate: DateTime
  status: String
}

input ShippingUpdateManyWithoutAddressInput {
  connect: [ShippingWhereUniqueInput!]
  create: [ShippingCreateWithoutAddressInput!]
  delete: [ShippingWhereUniqueInput!]
  deleteMany: [ShippingScalarWhereInput!]
  disconnect: [ShippingWhereUniqueInput!]
  set: [ShippingWhereUniqueInput!]
  update: [ShippingUpdateWithWhereUniqueWithoutAddressInput!]
  updateMany: [ShippingUpdateManyWithWhereNestedInput!]
  upsert: [ShippingUpsertWithWhereUniqueWithoutAddressInput!]
}

input ShippingUpdateManyWithWhereNestedInput {
  data: ShippingUpdateManyDataInput!
  where: ShippingScalarWhereInput!
}

input ShippingUpdateOneWithoutQuotationInput {
  connect: ShippingWhereUniqueInput
  create: ShippingCreateWithoutQuotationInput
  delete: Boolean
  disconnect: Boolean
  update: ShippingUpdateWithoutQuotationDataInput
  upsert: ShippingUpsertWithoutQuotationInput
}

input ShippingUpdateWithoutAddressDataInput {
  docId: String
  dueDate: DateTime
  invoce: InvoiceUpdateOneRequiredInput
  quotation: QuotationUpdateOneRequiredWithoutShippingInput
  status: String
}

input ShippingUpdateWithoutQuotationDataInput {
  address: AddressUpdateOneRequiredWithoutShippingInput
  docId: String
  dueDate: DateTime
  invoce: InvoiceUpdateOneRequiredInput
  status: String
}

input ShippingUpdateWithWhereUniqueWithoutAddressInput {
  data: ShippingUpdateWithoutAddressDataInput!
  where: ShippingWhereUniqueInput!
}

input ShippingUpsertWithoutQuotationInput {
  create: ShippingCreateWithoutQuotationInput!
  update: ShippingUpdateWithoutQuotationDataInput!
}

input ShippingUpsertWithWhereUniqueWithoutAddressInput {
  create: ShippingCreateWithoutAddressInput!
  update: ShippingUpdateWithoutAddressDataInput!
  where: ShippingWhereUniqueInput!
}

input ShippingWhereInput {
  address: AddressWhereInput
  AND: [ShippingWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  docId: String
  docId_contains: String
  docId_ends_with: String
  docId_gt: String
  docId_gte: String
  docId_in: [String!]
  docId_lt: String
  docId_lte: String
  docId_not: String
  docId_not_contains: String
  docId_not_ends_with: String
  docId_not_in: [String!]
  docId_not_starts_with: String
  docId_starts_with: String
  dueDate: DateTime
  dueDate_gt: DateTime
  dueDate_gte: DateTime
  dueDate_in: [DateTime!]
  dueDate_lt: DateTime
  dueDate_lte: DateTime
  dueDate_not: DateTime
  dueDate_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  invoce: InvoiceWhereInput
  NOT: [ShippingWhereInput!]
  OR: [ShippingWhereInput!]
  quotation: QuotationWhereInput
  status: String
  status_contains: String
  status_ends_with: String
  status_gt: String
  status_gte: String
  status_in: [String!]
  status_lt: String
  status_lte: String
  status_not: String
  status_not_contains: String
  status_not_ends_with: String
  status_not_in: [String!]
  status_not_starts_with: String
  status_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input ShippingWhereUniqueInput {
  id: ID
}

type ShoppingCart {
  createdAt: DateTime!
  customer: User!
  id: ID!
  productItems(after: String, before: String, first: Int, last: Int, orderBy: ProductItemOrderByInput, skip: Int, where: ProductItemWhereInput): [ProductItem!]
  total_cost: Float!
  updatedAt: DateTime!
}

type ShoppingCartConnection {
  aggregate: AggregateShoppingCart!
  edges: [ShoppingCartEdge!]!
  pageInfo: PageInfo!
}

input ShoppingCartCreateInput {
  customer: UserCreateOneWithoutShoppingCartInput!
  id: ID
  productItems: ProductItemCreateManyWithoutShoppingCartInput
  total_cost: Float!
}

input ShoppingCartCreateOneWithoutCustomerInput {
  connect: ShoppingCartWhereUniqueInput
  create: ShoppingCartCreateWithoutCustomerInput
}

input ShoppingCartCreateOneWithoutProductItemsInput {
  connect: ShoppingCartWhereUniqueInput
  create: ShoppingCartCreateWithoutProductItemsInput
}

input ShoppingCartCreateWithoutCustomerInput {
  id: ID
  productItems: ProductItemCreateManyWithoutShoppingCartInput
  total_cost: Float!
}

input ShoppingCartCreateWithoutProductItemsInput {
  customer: UserCreateOneWithoutShoppingCartInput!
  id: ID
  total_cost: Float!
}

type ShoppingCartEdge {
  cursor: String!
  node: ShoppingCart!
}

enum ShoppingCartOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  total_cost_ASC
  total_cost_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input ShoppingCartUpdateInput {
  customer: UserUpdateOneRequiredWithoutShoppingCartInput
  productItems: ProductItemUpdateManyWithoutShoppingCartInput
  total_cost: Float
}

input ShoppingCartUpdateManyMutationInput {
  total_cost: Float
}

input ShoppingCartUpdateOneRequiredWithoutCustomerInput {
  connect: ShoppingCartWhereUniqueInput
  create: ShoppingCartCreateWithoutCustomerInput
  update: ShoppingCartUpdateWithoutCustomerDataInput
  upsert: ShoppingCartUpsertWithoutCustomerInput
}

input ShoppingCartUpdateOneWithoutProductItemsInput {
  connect: ShoppingCartWhereUniqueInput
  create: ShoppingCartCreateWithoutProductItemsInput
  delete: Boolean
  disconnect: Boolean
  update: ShoppingCartUpdateWithoutProductItemsDataInput
  upsert: ShoppingCartUpsertWithoutProductItemsInput
}

input ShoppingCartUpdateWithoutCustomerDataInput {
  productItems: ProductItemUpdateManyWithoutShoppingCartInput
  total_cost: Float
}

input ShoppingCartUpdateWithoutProductItemsDataInput {
  customer: UserUpdateOneRequiredWithoutShoppingCartInput
  total_cost: Float
}

input ShoppingCartUpsertWithoutCustomerInput {
  create: ShoppingCartCreateWithoutCustomerInput!
  update: ShoppingCartUpdateWithoutCustomerDataInput!
}

input ShoppingCartUpsertWithoutProductItemsInput {
  create: ShoppingCartCreateWithoutProductItemsInput!
  update: ShoppingCartUpdateWithoutProductItemsDataInput!
}

input ShoppingCartWhereInput {
  AND: [ShoppingCartWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  customer: UserWhereInput
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [ShoppingCartWhereInput!]
  OR: [ShoppingCartWhereInput!]
  productItems_every: ProductItemWhereInput
  productItems_none: ProductItemWhereInput
  productItems_some: ProductItemWhereInput
  total_cost: Float
  total_cost_gt: Float
  total_cost_gte: Float
  total_cost_in: [Float!]
  total_cost_lt: Float
  total_cost_lte: Float
  total_cost_not: Float
  total_cost_not_in: [Float!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input ShoppingCartWhereUniqueInput {
  id: ID
}

type User {
  addresses(after: String, before: String, first: Int, last: Int, orderBy: AddressOrderByInput, skip: Int, where: AddressWhereInput): [Address!]
  createdAt: DateTime!
  email: String!
  id: ID!
  name: String!
  password: String!
  payments(after: String, before: String, first: Int, last: Int, orderBy: PaymentOrderByInput, skip: Int, where: PaymentWhereInput): [Payment!]
  phone: String!
  quotations(after: String, before: String, first: Int, last: Int, orderBy: QuotationOrderByInput, skip: Int, where: QuotationWhereInput): [Quotation!]
  shoppingCart: ShoppingCart!
  type: String!
  updatedAt: DateTime!
}

type UserConnection {
  aggregate: AggregateUser!
  edges: [UserEdge!]!
  pageInfo: PageInfo!
}

input UserCreateInput {
  addresses: AddressCreateManyWithoutCustomerInput
  email: String!
  id: ID
  name: String!
  password: String!
  payments: PaymentCreateManyWithoutCustomerInput
  phone: String!
  quotations: QuotationCreateManyWithoutCustomerInput
  shoppingCart: ShoppingCartCreateOneWithoutCustomerInput!
  type: String!
}

input UserCreateOneInput {
  connect: UserWhereUniqueInput
  create: UserCreateInput
}

input UserCreateOneWithoutAddressesInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutAddressesInput
}

input UserCreateOneWithoutPaymentsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutPaymentsInput
}

input UserCreateOneWithoutQuotationsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutQuotationsInput
}

input UserCreateOneWithoutShoppingCartInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutShoppingCartInput
}

input UserCreateWithoutAddressesInput {
  email: String!
  id: ID
  name: String!
  password: String!
  payments: PaymentCreateManyWithoutCustomerInput
  phone: String!
  quotations: QuotationCreateManyWithoutCustomerInput
  shoppingCart: ShoppingCartCreateOneWithoutCustomerInput!
  type: String!
}

input UserCreateWithoutPaymentsInput {
  addresses: AddressCreateManyWithoutCustomerInput
  email: String!
  id: ID
  name: String!
  password: String!
  phone: String!
  quotations: QuotationCreateManyWithoutCustomerInput
  shoppingCart: ShoppingCartCreateOneWithoutCustomerInput!
  type: String!
}

input UserCreateWithoutQuotationsInput {
  addresses: AddressCreateManyWithoutCustomerInput
  email: String!
  id: ID
  name: String!
  password: String!
  payments: PaymentCreateManyWithoutCustomerInput
  phone: String!
  shoppingCart: ShoppingCartCreateOneWithoutCustomerInput!
  type: String!
}

input UserCreateWithoutShoppingCartInput {
  addresses: AddressCreateManyWithoutCustomerInput
  email: String!
  id: ID
  name: String!
  password: String!
  payments: PaymentCreateManyWithoutCustomerInput
  phone: String!
  quotations: QuotationCreateManyWithoutCustomerInput
  type: String!
}

type UserEdge {
  cursor: String!
  node: User!
}

enum UserOrderByInput {
  createdAt_ASC
  createdAt_DESC
  email_ASC
  email_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  password_ASC
  password_DESC
  phone_ASC
  phone_DESC
  type_ASC
  type_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input UserUpdateDataInput {
  addresses: AddressUpdateManyWithoutCustomerInput
  email: String
  name: String
  password: String
  payments: PaymentUpdateManyWithoutCustomerInput
  phone: String
  quotations: QuotationUpdateManyWithoutCustomerInput
  shoppingCart: ShoppingCartUpdateOneRequiredWithoutCustomerInput
  type: String
}

input UserUpdateInput {
  addresses: AddressUpdateManyWithoutCustomerInput
  email: String
  name: String
  password: String
  payments: PaymentUpdateManyWithoutCustomerInput
  phone: String
  quotations: QuotationUpdateManyWithoutCustomerInput
  shoppingCart: ShoppingCartUpdateOneRequiredWithoutCustomerInput
  type: String
}

input UserUpdateManyMutationInput {
  email: String
  name: String
  password: String
  phone: String
  type: String
}

input UserUpdateOneRequiredInput {
  connect: UserWhereUniqueInput
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
}

input UserUpdateOneRequiredWithoutAddressesInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutAddressesInput
  update: UserUpdateWithoutAddressesDataInput
  upsert: UserUpsertWithoutAddressesInput
}

input UserUpdateOneRequiredWithoutPaymentsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutPaymentsInput
  update: UserUpdateWithoutPaymentsDataInput
  upsert: UserUpsertWithoutPaymentsInput
}

input UserUpdateOneRequiredWithoutQuotationsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutQuotationsInput
  update: UserUpdateWithoutQuotationsDataInput
  upsert: UserUpsertWithoutQuotationsInput
}

input UserUpdateOneRequiredWithoutShoppingCartInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutShoppingCartInput
  update: UserUpdateWithoutShoppingCartDataInput
  upsert: UserUpsertWithoutShoppingCartInput
}

input UserUpdateWithoutAddressesDataInput {
  email: String
  name: String
  password: String
  payments: PaymentUpdateManyWithoutCustomerInput
  phone: String
  quotations: QuotationUpdateManyWithoutCustomerInput
  shoppingCart: ShoppingCartUpdateOneRequiredWithoutCustomerInput
  type: String
}

input UserUpdateWithoutPaymentsDataInput {
  addresses: AddressUpdateManyWithoutCustomerInput
  email: String
  name: String
  password: String
  phone: String
  quotations: QuotationUpdateManyWithoutCustomerInput
  shoppingCart: ShoppingCartUpdateOneRequiredWithoutCustomerInput
  type: String
}

input UserUpdateWithoutQuotationsDataInput {
  addresses: AddressUpdateManyWithoutCustomerInput
  email: String
  name: String
  password: String
  payments: PaymentUpdateManyWithoutCustomerInput
  phone: String
  shoppingCart: ShoppingCartUpdateOneRequiredWithoutCustomerInput
  type: String
}

input UserUpdateWithoutShoppingCartDataInput {
  addresses: AddressUpdateManyWithoutCustomerInput
  email: String
  name: String
  password: String
  payments: PaymentUpdateManyWithoutCustomerInput
  phone: String
  quotations: QuotationUpdateManyWithoutCustomerInput
  type: String
}

input UserUpsertNestedInput {
  create: UserCreateInput!
  update: UserUpdateDataInput!
}

input UserUpsertWithoutAddressesInput {
  create: UserCreateWithoutAddressesInput!
  update: UserUpdateWithoutAddressesDataInput!
}

input UserUpsertWithoutPaymentsInput {
  create: UserCreateWithoutPaymentsInput!
  update: UserUpdateWithoutPaymentsDataInput!
}

input UserUpsertWithoutQuotationsInput {
  create: UserCreateWithoutQuotationsInput!
  update: UserUpdateWithoutQuotationsDataInput!
}

input UserUpsertWithoutShoppingCartInput {
  create: UserCreateWithoutShoppingCartInput!
  update: UserUpdateWithoutShoppingCartDataInput!
}

input UserWhereInput {
  addresses_every: AddressWhereInput
  addresses_none: AddressWhereInput
  addresses_some: AddressWhereInput
  AND: [UserWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  email: String
  email_contains: String
  email_ends_with: String
  email_gt: String
  email_gte: String
  email_in: [String!]
  email_lt: String
  email_lte: String
  email_not: String
  email_not_contains: String
  email_not_ends_with: String
  email_not_in: [String!]
  email_not_starts_with: String
  email_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: String
  password_contains: String
  password_ends_with: String
  password_gt: String
  password_gte: String
  password_in: [String!]
  password_lt: String
  password_lte: String
  password_not: String
  password_not_contains: String
  password_not_ends_with: String
  password_not_in: [String!]
  password_not_starts_with: String
  password_starts_with: String
  payments_every: PaymentWhereInput
  payments_none: PaymentWhereInput
  payments_some: PaymentWhereInput
  phone: String
  phone_contains: String
  phone_ends_with: String
  phone_gt: String
  phone_gte: String
  phone_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_not: String
  phone_not_contains: String
  phone_not_ends_with: String
  phone_not_in: [String!]
  phone_not_starts_with: String
  phone_starts_with: String
  quotations_every: QuotationWhereInput
  quotations_none: QuotationWhereInput
  quotations_some: QuotationWhereInput
  shoppingCart: ShoppingCartWhereInput
  type: String
  type_contains: String
  type_ends_with: String
  type_gt: String
  type_gte: String
  type_in: [String!]
  type_lt: String
  type_lte: String
  type_not: String
  type_not_contains: String
  type_not_ends_with: String
  type_not_in: [String!]
  type_not_starts_with: String
  type_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input UserWhereUniqueInput {
  email: String
  id: ID
}
