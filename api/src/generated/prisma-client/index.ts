// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  address: (where?: AddressWhereInput) => Promise<boolean>;
  category: (where?: CategoryWhereInput) => Promise<boolean>;
  invoice: (where?: InvoiceWhereInput) => Promise<boolean>;
  payment: (where?: PaymentWhereInput) => Promise<boolean>;
  productItem: (where?: ProductItemWhereInput) => Promise<boolean>;
  quotation: (where?: QuotationWhereInput) => Promise<boolean>;
  quotationItem: (where?: QuotationItemWhereInput) => Promise<boolean>;
  salesman: (where?: SalesmanWhereInput) => Promise<boolean>;
  shipping: (where?: ShippingWhereInput) => Promise<boolean>;
  shoppingCart: (where?: ShoppingCartWhereInput) => Promise<boolean>;
  shoppingCartItem: (where?: ShoppingCartItemWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  address: (where: AddressWhereUniqueInput) => AddressNullablePromise;
  addresses: (args?: {
    where?: AddressWhereInput;
    orderBy?: AddressOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Address>;
  addressesConnection: (args?: {
    where?: AddressWhereInput;
    orderBy?: AddressOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AddressConnectionPromise;
  category: (where: CategoryWhereUniqueInput) => CategoryNullablePromise;
  categories: (args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Category>;
  categoriesConnection: (args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CategoryConnectionPromise;
  invoice: (where: InvoiceWhereUniqueInput) => InvoiceNullablePromise;
  invoices: (args?: {
    where?: InvoiceWhereInput;
    orderBy?: InvoiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Invoice>;
  invoicesConnection: (args?: {
    where?: InvoiceWhereInput;
    orderBy?: InvoiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => InvoiceConnectionPromise;
  payment: (where: PaymentWhereUniqueInput) => PaymentNullablePromise;
  payments: (args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Payment>;
  paymentsConnection: (args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PaymentConnectionPromise;
  productItem: (
    where: ProductItemWhereUniqueInput
  ) => ProductItemNullablePromise;
  productItems: (args?: {
    where?: ProductItemWhereInput;
    orderBy?: ProductItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProductItem>;
  productItemsConnection: (args?: {
    where?: ProductItemWhereInput;
    orderBy?: ProductItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductItemConnectionPromise;
  quotation: (where: QuotationWhereUniqueInput) => QuotationNullablePromise;
  quotations: (args?: {
    where?: QuotationWhereInput;
    orderBy?: QuotationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Quotation>;
  quotationsConnection: (args?: {
    where?: QuotationWhereInput;
    orderBy?: QuotationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => QuotationConnectionPromise;
  quotationItem: (
    where: QuotationItemWhereUniqueInput
  ) => QuotationItemNullablePromise;
  quotationItems: (args?: {
    where?: QuotationItemWhereInput;
    orderBy?: QuotationItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<QuotationItem>;
  quotationItemsConnection: (args?: {
    where?: QuotationItemWhereInput;
    orderBy?: QuotationItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => QuotationItemConnectionPromise;
  salesman: (where: SalesmanWhereUniqueInput) => SalesmanNullablePromise;
  salesmen: (args?: {
    where?: SalesmanWhereInput;
    orderBy?: SalesmanOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Salesman>;
  salesmenConnection: (args?: {
    where?: SalesmanWhereInput;
    orderBy?: SalesmanOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SalesmanConnectionPromise;
  shipping: (where: ShippingWhereUniqueInput) => ShippingNullablePromise;
  shippings: (args?: {
    where?: ShippingWhereInput;
    orderBy?: ShippingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Shipping>;
  shippingsConnection: (args?: {
    where?: ShippingWhereInput;
    orderBy?: ShippingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ShippingConnectionPromise;
  shoppingCart: (
    where: ShoppingCartWhereUniqueInput
  ) => ShoppingCartNullablePromise;
  shoppingCarts: (args?: {
    where?: ShoppingCartWhereInput;
    orderBy?: ShoppingCartOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ShoppingCart>;
  shoppingCartsConnection: (args?: {
    where?: ShoppingCartWhereInput;
    orderBy?: ShoppingCartOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ShoppingCartConnectionPromise;
  shoppingCartItem: (
    where: ShoppingCartItemWhereUniqueInput
  ) => ShoppingCartItemNullablePromise;
  shoppingCartItems: (args?: {
    where?: ShoppingCartItemWhereInput;
    orderBy?: ShoppingCartItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ShoppingCartItem>;
  shoppingCartItemsConnection: (args?: {
    where?: ShoppingCartItemWhereInput;
    orderBy?: ShoppingCartItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ShoppingCartItemConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAddress: (data: AddressCreateInput) => AddressPromise;
  updateAddress: (args: {
    data: AddressUpdateInput;
    where: AddressWhereUniqueInput;
  }) => AddressPromise;
  updateManyAddresses: (args: {
    data: AddressUpdateManyMutationInput;
    where?: AddressWhereInput;
  }) => BatchPayloadPromise;
  upsertAddress: (args: {
    where: AddressWhereUniqueInput;
    create: AddressCreateInput;
    update: AddressUpdateInput;
  }) => AddressPromise;
  deleteAddress: (where: AddressWhereUniqueInput) => AddressPromise;
  deleteManyAddresses: (where?: AddressWhereInput) => BatchPayloadPromise;
  createCategory: (data: CategoryCreateInput) => CategoryPromise;
  updateCategory: (args: {
    data: CategoryUpdateInput;
    where: CategoryWhereUniqueInput;
  }) => CategoryPromise;
  updateManyCategories: (args: {
    data: CategoryUpdateManyMutationInput;
    where?: CategoryWhereInput;
  }) => BatchPayloadPromise;
  upsertCategory: (args: {
    where: CategoryWhereUniqueInput;
    create: CategoryCreateInput;
    update: CategoryUpdateInput;
  }) => CategoryPromise;
  deleteCategory: (where: CategoryWhereUniqueInput) => CategoryPromise;
  deleteManyCategories: (where?: CategoryWhereInput) => BatchPayloadPromise;
  createInvoice: (data: InvoiceCreateInput) => InvoicePromise;
  updateInvoice: (args: {
    data: InvoiceUpdateInput;
    where: InvoiceWhereUniqueInput;
  }) => InvoicePromise;
  updateManyInvoices: (args: {
    data: InvoiceUpdateManyMutationInput;
    where?: InvoiceWhereInput;
  }) => BatchPayloadPromise;
  upsertInvoice: (args: {
    where: InvoiceWhereUniqueInput;
    create: InvoiceCreateInput;
    update: InvoiceUpdateInput;
  }) => InvoicePromise;
  deleteInvoice: (where: InvoiceWhereUniqueInput) => InvoicePromise;
  deleteManyInvoices: (where?: InvoiceWhereInput) => BatchPayloadPromise;
  createPayment: (data: PaymentCreateInput) => PaymentPromise;
  updatePayment: (args: {
    data: PaymentUpdateInput;
    where: PaymentWhereUniqueInput;
  }) => PaymentPromise;
  updateManyPayments: (args: {
    data: PaymentUpdateManyMutationInput;
    where?: PaymentWhereInput;
  }) => BatchPayloadPromise;
  upsertPayment: (args: {
    where: PaymentWhereUniqueInput;
    create: PaymentCreateInput;
    update: PaymentUpdateInput;
  }) => PaymentPromise;
  deletePayment: (where: PaymentWhereUniqueInput) => PaymentPromise;
  deleteManyPayments: (where?: PaymentWhereInput) => BatchPayloadPromise;
  createProductItem: (data: ProductItemCreateInput) => ProductItemPromise;
  updateProductItem: (args: {
    data: ProductItemUpdateInput;
    where: ProductItemWhereUniqueInput;
  }) => ProductItemPromise;
  updateManyProductItems: (args: {
    data: ProductItemUpdateManyMutationInput;
    where?: ProductItemWhereInput;
  }) => BatchPayloadPromise;
  upsertProductItem: (args: {
    where: ProductItemWhereUniqueInput;
    create: ProductItemCreateInput;
    update: ProductItemUpdateInput;
  }) => ProductItemPromise;
  deleteProductItem: (where: ProductItemWhereUniqueInput) => ProductItemPromise;
  deleteManyProductItems: (
    where?: ProductItemWhereInput
  ) => BatchPayloadPromise;
  createQuotation: (data: QuotationCreateInput) => QuotationPromise;
  updateQuotation: (args: {
    data: QuotationUpdateInput;
    where: QuotationWhereUniqueInput;
  }) => QuotationPromise;
  updateManyQuotations: (args: {
    data: QuotationUpdateManyMutationInput;
    where?: QuotationWhereInput;
  }) => BatchPayloadPromise;
  upsertQuotation: (args: {
    where: QuotationWhereUniqueInput;
    create: QuotationCreateInput;
    update: QuotationUpdateInput;
  }) => QuotationPromise;
  deleteQuotation: (where: QuotationWhereUniqueInput) => QuotationPromise;
  deleteManyQuotations: (where?: QuotationWhereInput) => BatchPayloadPromise;
  createQuotationItem: (data: QuotationItemCreateInput) => QuotationItemPromise;
  updateQuotationItem: (args: {
    data: QuotationItemUpdateInput;
    where: QuotationItemWhereUniqueInput;
  }) => QuotationItemPromise;
  updateManyQuotationItems: (args: {
    data: QuotationItemUpdateManyMutationInput;
    where?: QuotationItemWhereInput;
  }) => BatchPayloadPromise;
  upsertQuotationItem: (args: {
    where: QuotationItemWhereUniqueInput;
    create: QuotationItemCreateInput;
    update: QuotationItemUpdateInput;
  }) => QuotationItemPromise;
  deleteQuotationItem: (
    where: QuotationItemWhereUniqueInput
  ) => QuotationItemPromise;
  deleteManyQuotationItems: (
    where?: QuotationItemWhereInput
  ) => BatchPayloadPromise;
  createSalesman: (data: SalesmanCreateInput) => SalesmanPromise;
  updateSalesman: (args: {
    data: SalesmanUpdateInput;
    where: SalesmanWhereUniqueInput;
  }) => SalesmanPromise;
  updateManySalesmen: (args: {
    data: SalesmanUpdateManyMutationInput;
    where?: SalesmanWhereInput;
  }) => BatchPayloadPromise;
  upsertSalesman: (args: {
    where: SalesmanWhereUniqueInput;
    create: SalesmanCreateInput;
    update: SalesmanUpdateInput;
  }) => SalesmanPromise;
  deleteSalesman: (where: SalesmanWhereUniqueInput) => SalesmanPromise;
  deleteManySalesmen: (where?: SalesmanWhereInput) => BatchPayloadPromise;
  createShipping: (data: ShippingCreateInput) => ShippingPromise;
  updateShipping: (args: {
    data: ShippingUpdateInput;
    where: ShippingWhereUniqueInput;
  }) => ShippingPromise;
  updateManyShippings: (args: {
    data: ShippingUpdateManyMutationInput;
    where?: ShippingWhereInput;
  }) => BatchPayloadPromise;
  upsertShipping: (args: {
    where: ShippingWhereUniqueInput;
    create: ShippingCreateInput;
    update: ShippingUpdateInput;
  }) => ShippingPromise;
  deleteShipping: (where: ShippingWhereUniqueInput) => ShippingPromise;
  deleteManyShippings: (where?: ShippingWhereInput) => BatchPayloadPromise;
  createShoppingCart: (data: ShoppingCartCreateInput) => ShoppingCartPromise;
  updateShoppingCart: (args: {
    data: ShoppingCartUpdateInput;
    where: ShoppingCartWhereUniqueInput;
  }) => ShoppingCartPromise;
  updateManyShoppingCarts: (args: {
    data: ShoppingCartUpdateManyMutationInput;
    where?: ShoppingCartWhereInput;
  }) => BatchPayloadPromise;
  upsertShoppingCart: (args: {
    where: ShoppingCartWhereUniqueInput;
    create: ShoppingCartCreateInput;
    update: ShoppingCartUpdateInput;
  }) => ShoppingCartPromise;
  deleteShoppingCart: (
    where: ShoppingCartWhereUniqueInput
  ) => ShoppingCartPromise;
  deleteManyShoppingCarts: (
    where?: ShoppingCartWhereInput
  ) => BatchPayloadPromise;
  createShoppingCartItem: (
    data: ShoppingCartItemCreateInput
  ) => ShoppingCartItemPromise;
  updateShoppingCartItem: (args: {
    data: ShoppingCartItemUpdateInput;
    where: ShoppingCartItemWhereUniqueInput;
  }) => ShoppingCartItemPromise;
  updateManyShoppingCartItems: (args: {
    data: ShoppingCartItemUpdateManyMutationInput;
    where?: ShoppingCartItemWhereInput;
  }) => BatchPayloadPromise;
  upsertShoppingCartItem: (args: {
    where: ShoppingCartItemWhereUniqueInput;
    create: ShoppingCartItemCreateInput;
    update: ShoppingCartItemUpdateInput;
  }) => ShoppingCartItemPromise;
  deleteShoppingCartItem: (
    where: ShoppingCartItemWhereUniqueInput
  ) => ShoppingCartItemPromise;
  deleteManyShoppingCartItems: (
    where?: ShoppingCartItemWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  address: (
    where?: AddressSubscriptionWhereInput
  ) => AddressSubscriptionPayloadSubscription;
  category: (
    where?: CategorySubscriptionWhereInput
  ) => CategorySubscriptionPayloadSubscription;
  invoice: (
    where?: InvoiceSubscriptionWhereInput
  ) => InvoiceSubscriptionPayloadSubscription;
  payment: (
    where?: PaymentSubscriptionWhereInput
  ) => PaymentSubscriptionPayloadSubscription;
  productItem: (
    where?: ProductItemSubscriptionWhereInput
  ) => ProductItemSubscriptionPayloadSubscription;
  quotation: (
    where?: QuotationSubscriptionWhereInput
  ) => QuotationSubscriptionPayloadSubscription;
  quotationItem: (
    where?: QuotationItemSubscriptionWhereInput
  ) => QuotationItemSubscriptionPayloadSubscription;
  salesman: (
    where?: SalesmanSubscriptionWhereInput
  ) => SalesmanSubscriptionPayloadSubscription;
  shipping: (
    where?: ShippingSubscriptionWhereInput
  ) => ShippingSubscriptionPayloadSubscription;
  shoppingCart: (
    where?: ShoppingCartSubscriptionWhereInput
  ) => ShoppingCartSubscriptionPayloadSubscription;
  shoppingCartItem: (
    where?: ShoppingCartItemSubscriptionWhereInput
  ) => ShoppingCartItemSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ShoppingCartItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "key_ASC"
  | "key_DESC"
  | "amount_ASC"
  | "amount_DESC";

export type ProductItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "price_ASC"
  | "price_DESC"
  | "salePrice_ASC"
  | "salePrice_DESC"
  | "brand_ASC"
  | "brand_DESC"
  | "unitType_ASC"
  | "unitType_DESC"
  | "description_ASC"
  | "description_DESC"
  | "MenuDetail_ASC"
  | "MenuDetail_DESC"
  | "TermDetail_ASC"
  | "TermDetail_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "isPublished_ASC"
  | "isPublished_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "image_ASC"
  | "image_DESC";

export type QuotationItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "key_ASC"
  | "key_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "realPrice_ASC"
  | "realPrice_DESC";

export type PaymentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "docId_ASC"
  | "docId_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "rawEvent_ASC"
  | "rawEvent_DESC";

export type InvoiceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "docId_ASC"
  | "docId_DESC"
  | "creditTerm_ASC"
  | "creditTerm_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type QuotationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "docId_ASC"
  | "docId_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "status_ASC"
  | "status_DESC";

export type AddressOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "Address_ASC"
  | "Address_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ShippingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "docId_ASC"
  | "docId_DESC"
  | "dueDate_ASC"
  | "dueDate_DESC"
  | "status_ASC"
  | "status_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SalesmanOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ShoppingCartOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "total_cost_ASC"
  | "total_cost_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "runningId_ASC"
  | "runningId_DESC"
  | "type_ASC"
  | "type_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "avatar_ASC"
  | "avatar_DESC"
  | "activated_ASC"
  | "activated_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type AddressWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ShoppingCartItemWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  key?: Maybe<String>;
  key_not?: Maybe<String>;
  key_in?: Maybe<String[] | String>;
  key_not_in?: Maybe<String[] | String>;
  key_lt?: Maybe<String>;
  key_lte?: Maybe<String>;
  key_gt?: Maybe<String>;
  key_gte?: Maybe<String>;
  key_contains?: Maybe<String>;
  key_not_contains?: Maybe<String>;
  key_starts_with?: Maybe<String>;
  key_not_starts_with?: Maybe<String>;
  key_ends_with?: Maybe<String>;
  key_not_ends_with?: Maybe<String>;
  product?: Maybe<ProductItemWhereInput>;
  amount?: Maybe<Int>;
  amount_not?: Maybe<Int>;
  amount_in?: Maybe<Int[] | Int>;
  amount_not_in?: Maybe<Int[] | Int>;
  amount_lt?: Maybe<Int>;
  amount_lte?: Maybe<Int>;
  amount_gt?: Maybe<Int>;
  amount_gte?: Maybe<Int>;
  ShoppingCart?: Maybe<ShoppingCartWhereInput>;
  AND?: Maybe<ShoppingCartItemWhereInput[] | ShoppingCartItemWhereInput>;
  OR?: Maybe<ShoppingCartItemWhereInput[] | ShoppingCartItemWhereInput>;
  NOT?: Maybe<ShoppingCartItemWhereInput[] | ShoppingCartItemWhereInput>;
}

export interface ProductItemWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  price?: Maybe<String>;
  price_not?: Maybe<String>;
  price_in?: Maybe<String[] | String>;
  price_not_in?: Maybe<String[] | String>;
  price_lt?: Maybe<String>;
  price_lte?: Maybe<String>;
  price_gt?: Maybe<String>;
  price_gte?: Maybe<String>;
  price_contains?: Maybe<String>;
  price_not_contains?: Maybe<String>;
  price_starts_with?: Maybe<String>;
  price_not_starts_with?: Maybe<String>;
  price_ends_with?: Maybe<String>;
  price_not_ends_with?: Maybe<String>;
  salePrice?: Maybe<String>;
  salePrice_not?: Maybe<String>;
  salePrice_in?: Maybe<String[] | String>;
  salePrice_not_in?: Maybe<String[] | String>;
  salePrice_lt?: Maybe<String>;
  salePrice_lte?: Maybe<String>;
  salePrice_gt?: Maybe<String>;
  salePrice_gte?: Maybe<String>;
  salePrice_contains?: Maybe<String>;
  salePrice_not_contains?: Maybe<String>;
  salePrice_starts_with?: Maybe<String>;
  salePrice_not_starts_with?: Maybe<String>;
  salePrice_ends_with?: Maybe<String>;
  salePrice_not_ends_with?: Maybe<String>;
  brand?: Maybe<String>;
  brand_not?: Maybe<String>;
  brand_in?: Maybe<String[] | String>;
  brand_not_in?: Maybe<String[] | String>;
  brand_lt?: Maybe<String>;
  brand_lte?: Maybe<String>;
  brand_gt?: Maybe<String>;
  brand_gte?: Maybe<String>;
  brand_contains?: Maybe<String>;
  brand_not_contains?: Maybe<String>;
  brand_starts_with?: Maybe<String>;
  brand_not_starts_with?: Maybe<String>;
  brand_ends_with?: Maybe<String>;
  brand_not_ends_with?: Maybe<String>;
  unitType?: Maybe<String>;
  unitType_not?: Maybe<String>;
  unitType_in?: Maybe<String[] | String>;
  unitType_not_in?: Maybe<String[] | String>;
  unitType_lt?: Maybe<String>;
  unitType_lte?: Maybe<String>;
  unitType_gt?: Maybe<String>;
  unitType_gte?: Maybe<String>;
  unitType_contains?: Maybe<String>;
  unitType_not_contains?: Maybe<String>;
  unitType_starts_with?: Maybe<String>;
  unitType_not_starts_with?: Maybe<String>;
  unitType_ends_with?: Maybe<String>;
  unitType_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  MenuDetail?: Maybe<String>;
  MenuDetail_not?: Maybe<String>;
  MenuDetail_in?: Maybe<String[] | String>;
  MenuDetail_not_in?: Maybe<String[] | String>;
  MenuDetail_lt?: Maybe<String>;
  MenuDetail_lte?: Maybe<String>;
  MenuDetail_gt?: Maybe<String>;
  MenuDetail_gte?: Maybe<String>;
  MenuDetail_contains?: Maybe<String>;
  MenuDetail_not_contains?: Maybe<String>;
  MenuDetail_starts_with?: Maybe<String>;
  MenuDetail_not_starts_with?: Maybe<String>;
  MenuDetail_ends_with?: Maybe<String>;
  MenuDetail_not_ends_with?: Maybe<String>;
  TermDetail?: Maybe<String>;
  TermDetail_not?: Maybe<String>;
  TermDetail_in?: Maybe<String[] | String>;
  TermDetail_not_in?: Maybe<String[] | String>;
  TermDetail_lt?: Maybe<String>;
  TermDetail_lte?: Maybe<String>;
  TermDetail_gt?: Maybe<String>;
  TermDetail_gte?: Maybe<String>;
  TermDetail_contains?: Maybe<String>;
  TermDetail_not_contains?: Maybe<String>;
  TermDetail_starts_with?: Maybe<String>;
  TermDetail_not_starts_with?: Maybe<String>;
  TermDetail_ends_with?: Maybe<String>;
  TermDetail_not_ends_with?: Maybe<String>;
  amount?: Maybe<Int>;
  amount_not?: Maybe<Int>;
  amount_in?: Maybe<Int[] | Int>;
  amount_not_in?: Maybe<Int[] | Int>;
  amount_lt?: Maybe<Int>;
  amount_lte?: Maybe<Int>;
  amount_gt?: Maybe<Int>;
  amount_gte?: Maybe<Int>;
  isPublished?: Maybe<Boolean>;
  isPublished_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  category?: Maybe<CategoryWhereInput>;
  shoppingCart?: Maybe<ShoppingCartWhereInput>;
  quotation?: Maybe<QuotationWhereInput>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  relatedProduct_every?: Maybe<ProductItemWhereInput>;
  relatedProduct_some?: Maybe<ProductItemWhereInput>;
  relatedProduct_none?: Maybe<ProductItemWhereInput>;
  AND?: Maybe<ProductItemWhereInput[] | ProductItemWhereInput>;
  OR?: Maybe<ProductItemWhereInput[] | ProductItemWhereInput>;
  NOT?: Maybe<ProductItemWhereInput[] | ProductItemWhereInput>;
}

export interface CategoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  productItem_every?: Maybe<ProductItemWhereInput>;
  productItem_some?: Maybe<ProductItemWhereInput>;
  productItem_none?: Maybe<ProductItemWhereInput>;
  category?: Maybe<CategoryWhereInput>;
  AND?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
  OR?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
  NOT?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
}

export interface ShoppingCartWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  total_cost?: Maybe<Float>;
  total_cost_not?: Maybe<Float>;
  total_cost_in?: Maybe<Float[] | Float>;
  total_cost_not_in?: Maybe<Float[] | Float>;
  total_cost_lt?: Maybe<Float>;
  total_cost_lte?: Maybe<Float>;
  total_cost_gt?: Maybe<Float>;
  total_cost_gte?: Maybe<Float>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  productItems_every?: Maybe<ShoppingCartItemWhereInput>;
  productItems_some?: Maybe<ShoppingCartItemWhereInput>;
  productItems_none?: Maybe<ShoppingCartItemWhereInput>;
  customer?: Maybe<UserWhereInput>;
  AND?: Maybe<ShoppingCartWhereInput[] | ShoppingCartWhereInput>;
  OR?: Maybe<ShoppingCartWhereInput[] | ShoppingCartWhereInput>;
  NOT?: Maybe<ShoppingCartWhereInput[] | ShoppingCartWhereInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  runningId?: Maybe<Int>;
  runningId_not?: Maybe<Int>;
  runningId_in?: Maybe<Int[] | Int>;
  runningId_not_in?: Maybe<Int[] | Int>;
  runningId_lt?: Maybe<Int>;
  runningId_lte?: Maybe<Int>;
  runningId_gt?: Maybe<Int>;
  runningId_gte?: Maybe<Int>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  avatar?: Maybe<String>;
  avatar_not?: Maybe<String>;
  avatar_in?: Maybe<String[] | String>;
  avatar_not_in?: Maybe<String[] | String>;
  avatar_lt?: Maybe<String>;
  avatar_lte?: Maybe<String>;
  avatar_gt?: Maybe<String>;
  avatar_gte?: Maybe<String>;
  avatar_contains?: Maybe<String>;
  avatar_not_contains?: Maybe<String>;
  avatar_starts_with?: Maybe<String>;
  avatar_not_starts_with?: Maybe<String>;
  avatar_ends_with?: Maybe<String>;
  avatar_not_ends_with?: Maybe<String>;
  activated?: Maybe<Boolean>;
  activated_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  shoppingCart?: Maybe<ShoppingCartWhereInput>;
  quotations_every?: Maybe<QuotationWhereInput>;
  quotations_some?: Maybe<QuotationWhereInput>;
  quotations_none?: Maybe<QuotationWhereInput>;
  payments_every?: Maybe<PaymentWhereInput>;
  payments_some?: Maybe<PaymentWhereInput>;
  payments_none?: Maybe<PaymentWhereInput>;
  addresses_every?: Maybe<AddressWhereInput>;
  addresses_some?: Maybe<AddressWhereInput>;
  addresses_none?: Maybe<AddressWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface QuotationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  docId?: Maybe<String>;
  docId_not?: Maybe<String>;
  docId_in?: Maybe<String[] | String>;
  docId_not_in?: Maybe<String[] | String>;
  docId_lt?: Maybe<String>;
  docId_lte?: Maybe<String>;
  docId_gt?: Maybe<String>;
  docId_gte?: Maybe<String>;
  docId_contains?: Maybe<String>;
  docId_not_contains?: Maybe<String>;
  docId_starts_with?: Maybe<String>;
  docId_not_starts_with?: Maybe<String>;
  docId_ends_with?: Maybe<String>;
  docId_not_ends_with?: Maybe<String>;
  quotationItem_every?: Maybe<QuotationItemWhereInput>;
  quotationItem_some?: Maybe<QuotationItemWhereInput>;
  quotationItem_none?: Maybe<QuotationItemWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  salesman?: Maybe<SalesmanWhereInput>;
  payment?: Maybe<PaymentWhereInput>;
  shipping?: Maybe<ShippingWhereInput>;
  customer?: Maybe<UserWhereInput>;
  status?: Maybe<String>;
  status_not?: Maybe<String>;
  status_in?: Maybe<String[] | String>;
  status_not_in?: Maybe<String[] | String>;
  status_lt?: Maybe<String>;
  status_lte?: Maybe<String>;
  status_gt?: Maybe<String>;
  status_gte?: Maybe<String>;
  status_contains?: Maybe<String>;
  status_not_contains?: Maybe<String>;
  status_starts_with?: Maybe<String>;
  status_not_starts_with?: Maybe<String>;
  status_ends_with?: Maybe<String>;
  status_not_ends_with?: Maybe<String>;
  AND?: Maybe<QuotationWhereInput[] | QuotationWhereInput>;
  OR?: Maybe<QuotationWhereInput[] | QuotationWhereInput>;
  NOT?: Maybe<QuotationWhereInput[] | QuotationWhereInput>;
}

export interface QuotationItemWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  key?: Maybe<String>;
  key_not?: Maybe<String>;
  key_in?: Maybe<String[] | String>;
  key_not_in?: Maybe<String[] | String>;
  key_lt?: Maybe<String>;
  key_lte?: Maybe<String>;
  key_gt?: Maybe<String>;
  key_gte?: Maybe<String>;
  key_contains?: Maybe<String>;
  key_not_contains?: Maybe<String>;
  key_starts_with?: Maybe<String>;
  key_not_starts_with?: Maybe<String>;
  key_ends_with?: Maybe<String>;
  key_not_ends_with?: Maybe<String>;
  product?: Maybe<ProductItemWhereInput>;
  amount?: Maybe<Int>;
  amount_not?: Maybe<Int>;
  amount_in?: Maybe<Int[] | Int>;
  amount_not_in?: Maybe<Int[] | Int>;
  amount_lt?: Maybe<Int>;
  amount_lte?: Maybe<Int>;
  amount_gt?: Maybe<Int>;
  amount_gte?: Maybe<Int>;
  realPrice?: Maybe<Float>;
  realPrice_not?: Maybe<Float>;
  realPrice_in?: Maybe<Float[] | Float>;
  realPrice_not_in?: Maybe<Float[] | Float>;
  realPrice_lt?: Maybe<Float>;
  realPrice_lte?: Maybe<Float>;
  realPrice_gt?: Maybe<Float>;
  realPrice_gte?: Maybe<Float>;
  quotation?: Maybe<QuotationWhereInput>;
  AND?: Maybe<QuotationItemWhereInput[] | QuotationItemWhereInput>;
  OR?: Maybe<QuotationItemWhereInput[] | QuotationItemWhereInput>;
  NOT?: Maybe<QuotationItemWhereInput[] | QuotationItemWhereInput>;
}

export interface SalesmanWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  payments_every?: Maybe<PaymentWhereInput>;
  payments_some?: Maybe<PaymentWhereInput>;
  payments_none?: Maybe<PaymentWhereInput>;
  invoices_every?: Maybe<InvoiceWhereInput>;
  invoices_some?: Maybe<InvoiceWhereInput>;
  invoices_none?: Maybe<InvoiceWhereInput>;
  quotations_every?: Maybe<QuotationWhereInput>;
  quotations_some?: Maybe<QuotationWhereInput>;
  quotations_none?: Maybe<QuotationWhereInput>;
  AND?: Maybe<SalesmanWhereInput[] | SalesmanWhereInput>;
  OR?: Maybe<SalesmanWhereInput[] | SalesmanWhereInput>;
  NOT?: Maybe<SalesmanWhereInput[] | SalesmanWhereInput>;
}

export interface PaymentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  docId?: Maybe<String>;
  docId_not?: Maybe<String>;
  docId_in?: Maybe<String[] | String>;
  docId_not_in?: Maybe<String[] | String>;
  docId_lt?: Maybe<String>;
  docId_lte?: Maybe<String>;
  docId_gt?: Maybe<String>;
  docId_gte?: Maybe<String>;
  docId_contains?: Maybe<String>;
  docId_not_contains?: Maybe<String>;
  docId_starts_with?: Maybe<String>;
  docId_not_starts_with?: Maybe<String>;
  docId_ends_with?: Maybe<String>;
  docId_not_ends_with?: Maybe<String>;
  amount?: Maybe<String>;
  amount_not?: Maybe<String>;
  amount_in?: Maybe<String[] | String>;
  amount_not_in?: Maybe<String[] | String>;
  amount_lt?: Maybe<String>;
  amount_lte?: Maybe<String>;
  amount_gt?: Maybe<String>;
  amount_gte?: Maybe<String>;
  amount_contains?: Maybe<String>;
  amount_not_contains?: Maybe<String>;
  amount_starts_with?: Maybe<String>;
  amount_not_starts_with?: Maybe<String>;
  amount_ends_with?: Maybe<String>;
  amount_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  customer?: Maybe<UserWhereInput>;
  salesman?: Maybe<SalesmanWhereInput>;
  quotation?: Maybe<QuotationWhereInput>;
  Invoice?: Maybe<InvoiceWhereInput>;
  rawEvent?: Maybe<String>;
  rawEvent_not?: Maybe<String>;
  rawEvent_in?: Maybe<String[] | String>;
  rawEvent_not_in?: Maybe<String[] | String>;
  rawEvent_lt?: Maybe<String>;
  rawEvent_lte?: Maybe<String>;
  rawEvent_gt?: Maybe<String>;
  rawEvent_gte?: Maybe<String>;
  rawEvent_contains?: Maybe<String>;
  rawEvent_not_contains?: Maybe<String>;
  rawEvent_starts_with?: Maybe<String>;
  rawEvent_not_starts_with?: Maybe<String>;
  rawEvent_ends_with?: Maybe<String>;
  rawEvent_not_ends_with?: Maybe<String>;
  AND?: Maybe<PaymentWhereInput[] | PaymentWhereInput>;
  OR?: Maybe<PaymentWhereInput[] | PaymentWhereInput>;
  NOT?: Maybe<PaymentWhereInput[] | PaymentWhereInput>;
}

export interface InvoiceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  docId?: Maybe<String>;
  docId_not?: Maybe<String>;
  docId_in?: Maybe<String[] | String>;
  docId_not_in?: Maybe<String[] | String>;
  docId_lt?: Maybe<String>;
  docId_lte?: Maybe<String>;
  docId_gt?: Maybe<String>;
  docId_gte?: Maybe<String>;
  docId_contains?: Maybe<String>;
  docId_not_contains?: Maybe<String>;
  docId_starts_with?: Maybe<String>;
  docId_not_starts_with?: Maybe<String>;
  docId_ends_with?: Maybe<String>;
  docId_not_ends_with?: Maybe<String>;
  creditTerm?: Maybe<String>;
  creditTerm_not?: Maybe<String>;
  creditTerm_in?: Maybe<String[] | String>;
  creditTerm_not_in?: Maybe<String[] | String>;
  creditTerm_lt?: Maybe<String>;
  creditTerm_lte?: Maybe<String>;
  creditTerm_gt?: Maybe<String>;
  creditTerm_gte?: Maybe<String>;
  creditTerm_contains?: Maybe<String>;
  creditTerm_not_contains?: Maybe<String>;
  creditTerm_starts_with?: Maybe<String>;
  creditTerm_not_starts_with?: Maybe<String>;
  creditTerm_ends_with?: Maybe<String>;
  creditTerm_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  user?: Maybe<UserWhereInput>;
  quotation?: Maybe<QuotationWhereInput>;
  salesman?: Maybe<SalesmanWhereInput>;
  address?: Maybe<AddressWhereInput>;
  payment?: Maybe<PaymentWhereInput>;
  AND?: Maybe<InvoiceWhereInput[] | InvoiceWhereInput>;
  OR?: Maybe<InvoiceWhereInput[] | InvoiceWhereInput>;
  NOT?: Maybe<InvoiceWhereInput[] | InvoiceWhereInput>;
}

export interface AddressWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  Address?: Maybe<String>;
  Address_not?: Maybe<String>;
  Address_in?: Maybe<String[] | String>;
  Address_not_in?: Maybe<String[] | String>;
  Address_lt?: Maybe<String>;
  Address_lte?: Maybe<String>;
  Address_gt?: Maybe<String>;
  Address_gte?: Maybe<String>;
  Address_contains?: Maybe<String>;
  Address_not_contains?: Maybe<String>;
  Address_starts_with?: Maybe<String>;
  Address_not_starts_with?: Maybe<String>;
  Address_ends_with?: Maybe<String>;
  Address_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  customer?: Maybe<UserWhereInput>;
  invoices_every?: Maybe<InvoiceWhereInput>;
  invoices_some?: Maybe<InvoiceWhereInput>;
  invoices_none?: Maybe<InvoiceWhereInput>;
  shipping_every?: Maybe<ShippingWhereInput>;
  shipping_some?: Maybe<ShippingWhereInput>;
  shipping_none?: Maybe<ShippingWhereInput>;
  AND?: Maybe<AddressWhereInput[] | AddressWhereInput>;
  OR?: Maybe<AddressWhereInput[] | AddressWhereInput>;
  NOT?: Maybe<AddressWhereInput[] | AddressWhereInput>;
}

export interface ShippingWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  docId?: Maybe<String>;
  docId_not?: Maybe<String>;
  docId_in?: Maybe<String[] | String>;
  docId_not_in?: Maybe<String[] | String>;
  docId_lt?: Maybe<String>;
  docId_lte?: Maybe<String>;
  docId_gt?: Maybe<String>;
  docId_gte?: Maybe<String>;
  docId_contains?: Maybe<String>;
  docId_not_contains?: Maybe<String>;
  docId_starts_with?: Maybe<String>;
  docId_not_starts_with?: Maybe<String>;
  docId_ends_with?: Maybe<String>;
  docId_not_ends_with?: Maybe<String>;
  dueDate?: Maybe<DateTimeInput>;
  dueDate_not?: Maybe<DateTimeInput>;
  dueDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dueDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dueDate_lt?: Maybe<DateTimeInput>;
  dueDate_lte?: Maybe<DateTimeInput>;
  dueDate_gt?: Maybe<DateTimeInput>;
  dueDate_gte?: Maybe<DateTimeInput>;
  status?: Maybe<String>;
  status_not?: Maybe<String>;
  status_in?: Maybe<String[] | String>;
  status_not_in?: Maybe<String[] | String>;
  status_lt?: Maybe<String>;
  status_lte?: Maybe<String>;
  status_gt?: Maybe<String>;
  status_gte?: Maybe<String>;
  status_contains?: Maybe<String>;
  status_not_contains?: Maybe<String>;
  status_starts_with?: Maybe<String>;
  status_not_starts_with?: Maybe<String>;
  status_ends_with?: Maybe<String>;
  status_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  invoce?: Maybe<InvoiceWhereInput>;
  address?: Maybe<AddressWhereInput>;
  quotation?: Maybe<QuotationWhereInput>;
  AND?: Maybe<ShippingWhereInput[] | ShippingWhereInput>;
  OR?: Maybe<ShippingWhereInput[] | ShippingWhereInput>;
  NOT?: Maybe<ShippingWhereInput[] | ShippingWhereInput>;
}

export type CategoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type InvoiceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type PaymentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ProductItemWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type QuotationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type QuotationItemWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  key?: Maybe<String>;
}>;

export type SalesmanWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ShippingWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ShoppingCartWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ShoppingCartItemWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  key?: Maybe<String>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface AddressCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  Address: String;
  customer: UserCreateOneWithoutAddressesInput;
  invoices?: Maybe<InvoiceCreateManyWithoutAddressInput>;
  shipping?: Maybe<ShippingCreateManyWithoutAddressInput>;
}

export interface UserCreateOneWithoutAddressesInput {
  create?: Maybe<UserCreateWithoutAddressesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutAddressesInput {
  id?: Maybe<ID_Input>;
  runningId?: Maybe<Int>;
  type?: Maybe<String>;
  name: String;
  email: String;
  password: String;
  phone: String;
  avatar?: Maybe<String>;
  activated?: Maybe<Boolean>;
  shoppingCart: ShoppingCartCreateOneWithoutCustomerInput;
  quotations?: Maybe<QuotationCreateManyWithoutCustomerInput>;
  payments?: Maybe<PaymentCreateManyWithoutCustomerInput>;
}

export interface ShoppingCartCreateOneWithoutCustomerInput {
  create?: Maybe<ShoppingCartCreateWithoutCustomerInput>;
  connect?: Maybe<ShoppingCartWhereUniqueInput>;
}

export interface ShoppingCartCreateWithoutCustomerInput {
  id?: Maybe<ID_Input>;
  total_cost: Float;
  productItems?: Maybe<ShoppingCartItemCreateManyWithoutShoppingCartInput>;
}

export interface ShoppingCartItemCreateManyWithoutShoppingCartInput {
  create?: Maybe<
    | ShoppingCartItemCreateWithoutShoppingCartInput[]
    | ShoppingCartItemCreateWithoutShoppingCartInput
  >;
  connect?: Maybe<
    ShoppingCartItemWhereUniqueInput[] | ShoppingCartItemWhereUniqueInput
  >;
}

export interface ShoppingCartItemCreateWithoutShoppingCartInput {
  id?: Maybe<ID_Input>;
  key: String;
  product: ProductItemCreateOneInput;
  amount: Int;
}

export interface ProductItemCreateOneInput {
  create?: Maybe<ProductItemCreateInput>;
  connect?: Maybe<ProductItemWhereUniqueInput>;
}

export interface ProductItemCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  price: String;
  salePrice: String;
  brand: String;
  unitType: String;
  description?: Maybe<String>;
  MenuDetail: String;
  TermDetail: String;
  amount: Int;
  isPublished?: Maybe<Boolean>;
  category: CategoryCreateOneWithoutProductItemInput;
  shoppingCart?: Maybe<ShoppingCartCreateOneInput>;
  quotation?: Maybe<QuotationCreateOneInput>;
  image?: Maybe<String>;
  relatedProduct?: Maybe<ProductItemCreateManyInput>;
}

export interface CategoryCreateOneWithoutProductItemInput {
  create?: Maybe<CategoryCreateWithoutProductItemInput>;
  connect?: Maybe<CategoryWhereUniqueInput>;
}

export interface CategoryCreateWithoutProductItemInput {
  id?: Maybe<ID_Input>;
  name: String;
  category?: Maybe<CategoryCreateOneInput>;
}

export interface CategoryCreateOneInput {
  create?: Maybe<CategoryCreateInput>;
  connect?: Maybe<CategoryWhereUniqueInput>;
}

export interface CategoryCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  productItem?: Maybe<ProductItemCreateManyWithoutCategoryInput>;
  category?: Maybe<CategoryCreateOneInput>;
}

export interface ProductItemCreateManyWithoutCategoryInput {
  create?: Maybe<
    | ProductItemCreateWithoutCategoryInput[]
    | ProductItemCreateWithoutCategoryInput
  >;
  connect?: Maybe<ProductItemWhereUniqueInput[] | ProductItemWhereUniqueInput>;
}

export interface ProductItemCreateWithoutCategoryInput {
  id?: Maybe<ID_Input>;
  name: String;
  price: String;
  salePrice: String;
  brand: String;
  unitType: String;
  description?: Maybe<String>;
  MenuDetail: String;
  TermDetail: String;
  amount: Int;
  isPublished?: Maybe<Boolean>;
  shoppingCart?: Maybe<ShoppingCartCreateOneInput>;
  quotation?: Maybe<QuotationCreateOneInput>;
  image?: Maybe<String>;
  relatedProduct?: Maybe<ProductItemCreateManyInput>;
}

export interface ShoppingCartCreateOneInput {
  create?: Maybe<ShoppingCartCreateInput>;
  connect?: Maybe<ShoppingCartWhereUniqueInput>;
}

export interface ShoppingCartCreateInput {
  id?: Maybe<ID_Input>;
  total_cost: Float;
  productItems?: Maybe<ShoppingCartItemCreateManyWithoutShoppingCartInput>;
  customer: UserCreateOneWithoutShoppingCartInput;
}

export interface UserCreateOneWithoutShoppingCartInput {
  create?: Maybe<UserCreateWithoutShoppingCartInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutShoppingCartInput {
  id?: Maybe<ID_Input>;
  runningId?: Maybe<Int>;
  type?: Maybe<String>;
  name: String;
  email: String;
  password: String;
  phone: String;
  avatar?: Maybe<String>;
  activated?: Maybe<Boolean>;
  quotations?: Maybe<QuotationCreateManyWithoutCustomerInput>;
  payments?: Maybe<PaymentCreateManyWithoutCustomerInput>;
  addresses?: Maybe<AddressCreateManyWithoutCustomerInput>;
}

export interface QuotationCreateManyWithoutCustomerInput {
  create?: Maybe<
    QuotationCreateWithoutCustomerInput[] | QuotationCreateWithoutCustomerInput
  >;
  connect?: Maybe<QuotationWhereUniqueInput[] | QuotationWhereUniqueInput>;
}

export interface QuotationCreateWithoutCustomerInput {
  id?: Maybe<ID_Input>;
  docId?: Maybe<String>;
  quotationItem?: Maybe<QuotationItemCreateManyWithoutQuotationInput>;
  salesman?: Maybe<SalesmanCreateOneWithoutQuotationsInput>;
  payment?: Maybe<PaymentCreateOneWithoutQuotationInput>;
  shipping?: Maybe<ShippingCreateOneWithoutQuotationInput>;
  status?: Maybe<String>;
}

export interface QuotationItemCreateManyWithoutQuotationInput {
  create?: Maybe<
    | QuotationItemCreateWithoutQuotationInput[]
    | QuotationItemCreateWithoutQuotationInput
  >;
  connect?: Maybe<
    QuotationItemWhereUniqueInput[] | QuotationItemWhereUniqueInput
  >;
}

export interface QuotationItemCreateWithoutQuotationInput {
  id?: Maybe<ID_Input>;
  key: String;
  product: ProductItemCreateOneInput;
  amount: Int;
  realPrice: Float;
}

export interface SalesmanCreateOneWithoutQuotationsInput {
  create?: Maybe<SalesmanCreateWithoutQuotationsInput>;
  connect?: Maybe<SalesmanWhereUniqueInput>;
}

export interface SalesmanCreateWithoutQuotationsInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  phone: String;
  payments?: Maybe<PaymentCreateManyWithoutSalesmanInput>;
  invoices?: Maybe<InvoiceCreateManyWithoutSalesmanInput>;
}

export interface PaymentCreateManyWithoutSalesmanInput {
  create?: Maybe<
    PaymentCreateWithoutSalesmanInput[] | PaymentCreateWithoutSalesmanInput
  >;
  connect?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
}

export interface PaymentCreateWithoutSalesmanInput {
  id?: Maybe<ID_Input>;
  docId: String;
  amount: String;
  customer: UserCreateOneWithoutPaymentsInput;
  quotation: QuotationCreateOneWithoutPaymentInput;
  Invoice?: Maybe<InvoiceCreateOneWithoutPaymentInput>;
  rawEvent?: Maybe<String>;
}

export interface UserCreateOneWithoutPaymentsInput {
  create?: Maybe<UserCreateWithoutPaymentsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutPaymentsInput {
  id?: Maybe<ID_Input>;
  runningId?: Maybe<Int>;
  type?: Maybe<String>;
  name: String;
  email: String;
  password: String;
  phone: String;
  avatar?: Maybe<String>;
  activated?: Maybe<Boolean>;
  shoppingCart: ShoppingCartCreateOneWithoutCustomerInput;
  quotations?: Maybe<QuotationCreateManyWithoutCustomerInput>;
  addresses?: Maybe<AddressCreateManyWithoutCustomerInput>;
}

export interface AddressCreateManyWithoutCustomerInput {
  create?: Maybe<
    AddressCreateWithoutCustomerInput[] | AddressCreateWithoutCustomerInput
  >;
  connect?: Maybe<AddressWhereUniqueInput[] | AddressWhereUniqueInput>;
}

export interface AddressCreateWithoutCustomerInput {
  id?: Maybe<ID_Input>;
  name: String;
  Address: String;
  invoices?: Maybe<InvoiceCreateManyWithoutAddressInput>;
  shipping?: Maybe<ShippingCreateManyWithoutAddressInput>;
}

export interface InvoiceCreateManyWithoutAddressInput {
  create?: Maybe<
    InvoiceCreateWithoutAddressInput[] | InvoiceCreateWithoutAddressInput
  >;
  connect?: Maybe<InvoiceWhereUniqueInput[] | InvoiceWhereUniqueInput>;
}

export interface InvoiceCreateWithoutAddressInput {
  id?: Maybe<ID_Input>;
  docId: String;
  creditTerm: String;
  user: UserCreateOneInput;
  quotation: QuotationCreateOneInput;
  salesman: SalesmanCreateOneWithoutInvoicesInput;
  payment?: Maybe<PaymentCreateOneWithoutInvoiceInput>;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  runningId?: Maybe<Int>;
  type?: Maybe<String>;
  name: String;
  email: String;
  password: String;
  phone: String;
  avatar?: Maybe<String>;
  activated?: Maybe<Boolean>;
  shoppingCart: ShoppingCartCreateOneWithoutCustomerInput;
  quotations?: Maybe<QuotationCreateManyWithoutCustomerInput>;
  payments?: Maybe<PaymentCreateManyWithoutCustomerInput>;
  addresses?: Maybe<AddressCreateManyWithoutCustomerInput>;
}

export interface PaymentCreateManyWithoutCustomerInput {
  create?: Maybe<
    PaymentCreateWithoutCustomerInput[] | PaymentCreateWithoutCustomerInput
  >;
  connect?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
}

export interface PaymentCreateWithoutCustomerInput {
  id?: Maybe<ID_Input>;
  docId: String;
  amount: String;
  salesman?: Maybe<SalesmanCreateOneWithoutPaymentsInput>;
  quotation: QuotationCreateOneWithoutPaymentInput;
  Invoice?: Maybe<InvoiceCreateOneWithoutPaymentInput>;
  rawEvent?: Maybe<String>;
}

export interface SalesmanCreateOneWithoutPaymentsInput {
  create?: Maybe<SalesmanCreateWithoutPaymentsInput>;
  connect?: Maybe<SalesmanWhereUniqueInput>;
}

export interface SalesmanCreateWithoutPaymentsInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  phone: String;
  invoices?: Maybe<InvoiceCreateManyWithoutSalesmanInput>;
  quotations?: Maybe<QuotationCreateManyWithoutSalesmanInput>;
}

export interface InvoiceCreateManyWithoutSalesmanInput {
  create?: Maybe<
    InvoiceCreateWithoutSalesmanInput[] | InvoiceCreateWithoutSalesmanInput
  >;
  connect?: Maybe<InvoiceWhereUniqueInput[] | InvoiceWhereUniqueInput>;
}

export interface InvoiceCreateWithoutSalesmanInput {
  id?: Maybe<ID_Input>;
  docId: String;
  creditTerm: String;
  user: UserCreateOneInput;
  quotation: QuotationCreateOneInput;
  address?: Maybe<AddressCreateOneWithoutInvoicesInput>;
  payment?: Maybe<PaymentCreateOneWithoutInvoiceInput>;
}

export interface QuotationCreateOneInput {
  create?: Maybe<QuotationCreateInput>;
  connect?: Maybe<QuotationWhereUniqueInput>;
}

export interface QuotationCreateInput {
  id?: Maybe<ID_Input>;
  docId?: Maybe<String>;
  quotationItem?: Maybe<QuotationItemCreateManyWithoutQuotationInput>;
  salesman?: Maybe<SalesmanCreateOneWithoutQuotationsInput>;
  payment?: Maybe<PaymentCreateOneWithoutQuotationInput>;
  shipping?: Maybe<ShippingCreateOneWithoutQuotationInput>;
  customer: UserCreateOneWithoutQuotationsInput;
  status?: Maybe<String>;
}

export interface PaymentCreateOneWithoutQuotationInput {
  create?: Maybe<PaymentCreateWithoutQuotationInput>;
  connect?: Maybe<PaymentWhereUniqueInput>;
}

export interface PaymentCreateWithoutQuotationInput {
  id?: Maybe<ID_Input>;
  docId: String;
  amount: String;
  customer: UserCreateOneWithoutPaymentsInput;
  salesman?: Maybe<SalesmanCreateOneWithoutPaymentsInput>;
  Invoice?: Maybe<InvoiceCreateOneWithoutPaymentInput>;
  rawEvent?: Maybe<String>;
}

export interface InvoiceCreateOneWithoutPaymentInput {
  create?: Maybe<InvoiceCreateWithoutPaymentInput>;
  connect?: Maybe<InvoiceWhereUniqueInput>;
}

export interface InvoiceCreateWithoutPaymentInput {
  id?: Maybe<ID_Input>;
  docId: String;
  creditTerm: String;
  user: UserCreateOneInput;
  quotation: QuotationCreateOneInput;
  salesman: SalesmanCreateOneWithoutInvoicesInput;
  address?: Maybe<AddressCreateOneWithoutInvoicesInput>;
}

export interface SalesmanCreateOneWithoutInvoicesInput {
  create?: Maybe<SalesmanCreateWithoutInvoicesInput>;
  connect?: Maybe<SalesmanWhereUniqueInput>;
}

export interface SalesmanCreateWithoutInvoicesInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  phone: String;
  payments?: Maybe<PaymentCreateManyWithoutSalesmanInput>;
  quotations?: Maybe<QuotationCreateManyWithoutSalesmanInput>;
}

export interface QuotationCreateManyWithoutSalesmanInput {
  create?: Maybe<
    QuotationCreateWithoutSalesmanInput[] | QuotationCreateWithoutSalesmanInput
  >;
  connect?: Maybe<QuotationWhereUniqueInput[] | QuotationWhereUniqueInput>;
}

export interface QuotationCreateWithoutSalesmanInput {
  id?: Maybe<ID_Input>;
  docId?: Maybe<String>;
  quotationItem?: Maybe<QuotationItemCreateManyWithoutQuotationInput>;
  payment?: Maybe<PaymentCreateOneWithoutQuotationInput>;
  shipping?: Maybe<ShippingCreateOneWithoutQuotationInput>;
  customer: UserCreateOneWithoutQuotationsInput;
  status?: Maybe<String>;
}

export interface ShippingCreateOneWithoutQuotationInput {
  create?: Maybe<ShippingCreateWithoutQuotationInput>;
  connect?: Maybe<ShippingWhereUniqueInput>;
}

export interface ShippingCreateWithoutQuotationInput {
  id?: Maybe<ID_Input>;
  docId: String;
  dueDate: DateTimeInput;
  status: String;
  invoce: InvoiceCreateOneInput;
  address: AddressCreateOneWithoutShippingInput;
}

export interface InvoiceCreateOneInput {
  create?: Maybe<InvoiceCreateInput>;
  connect?: Maybe<InvoiceWhereUniqueInput>;
}

export interface InvoiceCreateInput {
  id?: Maybe<ID_Input>;
  docId: String;
  creditTerm: String;
  user: UserCreateOneInput;
  quotation: QuotationCreateOneInput;
  salesman: SalesmanCreateOneWithoutInvoicesInput;
  address?: Maybe<AddressCreateOneWithoutInvoicesInput>;
  payment?: Maybe<PaymentCreateOneWithoutInvoiceInput>;
}

export interface AddressCreateOneWithoutInvoicesInput {
  create?: Maybe<AddressCreateWithoutInvoicesInput>;
  connect?: Maybe<AddressWhereUniqueInput>;
}

export interface AddressCreateWithoutInvoicesInput {
  id?: Maybe<ID_Input>;
  name: String;
  Address: String;
  customer: UserCreateOneWithoutAddressesInput;
  shipping?: Maybe<ShippingCreateManyWithoutAddressInput>;
}

export interface ShippingCreateManyWithoutAddressInput {
  create?: Maybe<
    ShippingCreateWithoutAddressInput[] | ShippingCreateWithoutAddressInput
  >;
  connect?: Maybe<ShippingWhereUniqueInput[] | ShippingWhereUniqueInput>;
}

export interface ShippingCreateWithoutAddressInput {
  id?: Maybe<ID_Input>;
  docId: String;
  dueDate: DateTimeInput;
  status: String;
  invoce: InvoiceCreateOneInput;
  quotation: QuotationCreateOneWithoutShippingInput;
}

export interface QuotationCreateOneWithoutShippingInput {
  create?: Maybe<QuotationCreateWithoutShippingInput>;
  connect?: Maybe<QuotationWhereUniqueInput>;
}

export interface QuotationCreateWithoutShippingInput {
  id?: Maybe<ID_Input>;
  docId?: Maybe<String>;
  quotationItem?: Maybe<QuotationItemCreateManyWithoutQuotationInput>;
  salesman?: Maybe<SalesmanCreateOneWithoutQuotationsInput>;
  payment?: Maybe<PaymentCreateOneWithoutQuotationInput>;
  customer: UserCreateOneWithoutQuotationsInput;
  status?: Maybe<String>;
}

export interface UserCreateOneWithoutQuotationsInput {
  create?: Maybe<UserCreateWithoutQuotationsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutQuotationsInput {
  id?: Maybe<ID_Input>;
  runningId?: Maybe<Int>;
  type?: Maybe<String>;
  name: String;
  email: String;
  password: String;
  phone: String;
  avatar?: Maybe<String>;
  activated?: Maybe<Boolean>;
  shoppingCart: ShoppingCartCreateOneWithoutCustomerInput;
  payments?: Maybe<PaymentCreateManyWithoutCustomerInput>;
  addresses?: Maybe<AddressCreateManyWithoutCustomerInput>;
}

export interface PaymentCreateOneWithoutInvoiceInput {
  create?: Maybe<PaymentCreateWithoutInvoiceInput>;
  connect?: Maybe<PaymentWhereUniqueInput>;
}

export interface PaymentCreateWithoutInvoiceInput {
  id?: Maybe<ID_Input>;
  docId: String;
  amount: String;
  customer: UserCreateOneWithoutPaymentsInput;
  salesman?: Maybe<SalesmanCreateOneWithoutPaymentsInput>;
  quotation: QuotationCreateOneWithoutPaymentInput;
  rawEvent?: Maybe<String>;
}

export interface QuotationCreateOneWithoutPaymentInput {
  create?: Maybe<QuotationCreateWithoutPaymentInput>;
  connect?: Maybe<QuotationWhereUniqueInput>;
}

export interface QuotationCreateWithoutPaymentInput {
  id?: Maybe<ID_Input>;
  docId?: Maybe<String>;
  quotationItem?: Maybe<QuotationItemCreateManyWithoutQuotationInput>;
  salesman?: Maybe<SalesmanCreateOneWithoutQuotationsInput>;
  shipping?: Maybe<ShippingCreateOneWithoutQuotationInput>;
  customer: UserCreateOneWithoutQuotationsInput;
  status?: Maybe<String>;
}

export interface AddressCreateOneWithoutShippingInput {
  create?: Maybe<AddressCreateWithoutShippingInput>;
  connect?: Maybe<AddressWhereUniqueInput>;
}

export interface AddressCreateWithoutShippingInput {
  id?: Maybe<ID_Input>;
  name: String;
  Address: String;
  customer: UserCreateOneWithoutAddressesInput;
  invoices?: Maybe<InvoiceCreateManyWithoutAddressInput>;
}

export interface ProductItemCreateManyInput {
  create?: Maybe<ProductItemCreateInput[] | ProductItemCreateInput>;
  connect?: Maybe<ProductItemWhereUniqueInput[] | ProductItemWhereUniqueInput>;
}

export interface AddressUpdateInput {
  name?: Maybe<String>;
  Address?: Maybe<String>;
  customer?: Maybe<UserUpdateOneRequiredWithoutAddressesInput>;
  invoices?: Maybe<InvoiceUpdateManyWithoutAddressInput>;
  shipping?: Maybe<ShippingUpdateManyWithoutAddressInput>;
}

export interface UserUpdateOneRequiredWithoutAddressesInput {
  create?: Maybe<UserCreateWithoutAddressesInput>;
  update?: Maybe<UserUpdateWithoutAddressesDataInput>;
  upsert?: Maybe<UserUpsertWithoutAddressesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutAddressesDataInput {
  runningId?: Maybe<Int>;
  type?: Maybe<String>;
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  avatar?: Maybe<String>;
  activated?: Maybe<Boolean>;
  shoppingCart?: Maybe<ShoppingCartUpdateOneRequiredWithoutCustomerInput>;
  quotations?: Maybe<QuotationUpdateManyWithoutCustomerInput>;
  payments?: Maybe<PaymentUpdateManyWithoutCustomerInput>;
}

export interface ShoppingCartUpdateOneRequiredWithoutCustomerInput {
  create?: Maybe<ShoppingCartCreateWithoutCustomerInput>;
  update?: Maybe<ShoppingCartUpdateWithoutCustomerDataInput>;
  upsert?: Maybe<ShoppingCartUpsertWithoutCustomerInput>;
  connect?: Maybe<ShoppingCartWhereUniqueInput>;
}

export interface ShoppingCartUpdateWithoutCustomerDataInput {
  total_cost?: Maybe<Float>;
  productItems?: Maybe<ShoppingCartItemUpdateManyWithoutShoppingCartInput>;
}

export interface ShoppingCartItemUpdateManyWithoutShoppingCartInput {
  create?: Maybe<
    | ShoppingCartItemCreateWithoutShoppingCartInput[]
    | ShoppingCartItemCreateWithoutShoppingCartInput
  >;
  delete?: Maybe<
    ShoppingCartItemWhereUniqueInput[] | ShoppingCartItemWhereUniqueInput
  >;
  connect?: Maybe<
    ShoppingCartItemWhereUniqueInput[] | ShoppingCartItemWhereUniqueInput
  >;
  set?: Maybe<
    ShoppingCartItemWhereUniqueInput[] | ShoppingCartItemWhereUniqueInput
  >;
  disconnect?: Maybe<
    ShoppingCartItemWhereUniqueInput[] | ShoppingCartItemWhereUniqueInput
  >;
  update?: Maybe<
    | ShoppingCartItemUpdateWithWhereUniqueWithoutShoppingCartInput[]
    | ShoppingCartItemUpdateWithWhereUniqueWithoutShoppingCartInput
  >;
  upsert?: Maybe<
    | ShoppingCartItemUpsertWithWhereUniqueWithoutShoppingCartInput[]
    | ShoppingCartItemUpsertWithWhereUniqueWithoutShoppingCartInput
  >;
  deleteMany?: Maybe<
    ShoppingCartItemScalarWhereInput[] | ShoppingCartItemScalarWhereInput
  >;
  updateMany?: Maybe<
    | ShoppingCartItemUpdateManyWithWhereNestedInput[]
    | ShoppingCartItemUpdateManyWithWhereNestedInput
  >;
}

export interface ShoppingCartItemUpdateWithWhereUniqueWithoutShoppingCartInput {
  where: ShoppingCartItemWhereUniqueInput;
  data: ShoppingCartItemUpdateWithoutShoppingCartDataInput;
}

export interface ShoppingCartItemUpdateWithoutShoppingCartDataInput {
  key?: Maybe<String>;
  product?: Maybe<ProductItemUpdateOneRequiredInput>;
  amount?: Maybe<Int>;
}

export interface ProductItemUpdateOneRequiredInput {
  create?: Maybe<ProductItemCreateInput>;
  update?: Maybe<ProductItemUpdateDataInput>;
  upsert?: Maybe<ProductItemUpsertNestedInput>;
  connect?: Maybe<ProductItemWhereUniqueInput>;
}

export interface ProductItemUpdateDataInput {
  name?: Maybe<String>;
  price?: Maybe<String>;
  salePrice?: Maybe<String>;
  brand?: Maybe<String>;
  unitType?: Maybe<String>;
  description?: Maybe<String>;
  MenuDetail?: Maybe<String>;
  TermDetail?: Maybe<String>;
  amount?: Maybe<Int>;
  isPublished?: Maybe<Boolean>;
  category?: Maybe<CategoryUpdateOneRequiredWithoutProductItemInput>;
  shoppingCart?: Maybe<ShoppingCartUpdateOneInput>;
  quotation?: Maybe<QuotationUpdateOneInput>;
  image?: Maybe<String>;
  relatedProduct?: Maybe<ProductItemUpdateManyInput>;
}

export interface CategoryUpdateOneRequiredWithoutProductItemInput {
  create?: Maybe<CategoryCreateWithoutProductItemInput>;
  update?: Maybe<CategoryUpdateWithoutProductItemDataInput>;
  upsert?: Maybe<CategoryUpsertWithoutProductItemInput>;
  connect?: Maybe<CategoryWhereUniqueInput>;
}

export interface CategoryUpdateWithoutProductItemDataInput {
  name?: Maybe<String>;
  category?: Maybe<CategoryUpdateOneInput>;
}

export interface CategoryUpdateOneInput {
  create?: Maybe<CategoryCreateInput>;
  update?: Maybe<CategoryUpdateDataInput>;
  upsert?: Maybe<CategoryUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CategoryWhereUniqueInput>;
}

export interface CategoryUpdateDataInput {
  name?: Maybe<String>;
  productItem?: Maybe<ProductItemUpdateManyWithoutCategoryInput>;
  category?: Maybe<CategoryUpdateOneInput>;
}

export interface ProductItemUpdateManyWithoutCategoryInput {
  create?: Maybe<
    | ProductItemCreateWithoutCategoryInput[]
    | ProductItemCreateWithoutCategoryInput
  >;
  delete?: Maybe<ProductItemWhereUniqueInput[] | ProductItemWhereUniqueInput>;
  connect?: Maybe<ProductItemWhereUniqueInput[] | ProductItemWhereUniqueInput>;
  set?: Maybe<ProductItemWhereUniqueInput[] | ProductItemWhereUniqueInput>;
  disconnect?: Maybe<
    ProductItemWhereUniqueInput[] | ProductItemWhereUniqueInput
  >;
  update?: Maybe<
    | ProductItemUpdateWithWhereUniqueWithoutCategoryInput[]
    | ProductItemUpdateWithWhereUniqueWithoutCategoryInput
  >;
  upsert?: Maybe<
    | ProductItemUpsertWithWhereUniqueWithoutCategoryInput[]
    | ProductItemUpsertWithWhereUniqueWithoutCategoryInput
  >;
  deleteMany?: Maybe<
    ProductItemScalarWhereInput[] | ProductItemScalarWhereInput
  >;
  updateMany?: Maybe<
    | ProductItemUpdateManyWithWhereNestedInput[]
    | ProductItemUpdateManyWithWhereNestedInput
  >;
}

export interface ProductItemUpdateWithWhereUniqueWithoutCategoryInput {
  where: ProductItemWhereUniqueInput;
  data: ProductItemUpdateWithoutCategoryDataInput;
}

export interface ProductItemUpdateWithoutCategoryDataInput {
  name?: Maybe<String>;
  price?: Maybe<String>;
  salePrice?: Maybe<String>;
  brand?: Maybe<String>;
  unitType?: Maybe<String>;
  description?: Maybe<String>;
  MenuDetail?: Maybe<String>;
  TermDetail?: Maybe<String>;
  amount?: Maybe<Int>;
  isPublished?: Maybe<Boolean>;
  shoppingCart?: Maybe<ShoppingCartUpdateOneInput>;
  quotation?: Maybe<QuotationUpdateOneInput>;
  image?: Maybe<String>;
  relatedProduct?: Maybe<ProductItemUpdateManyInput>;
}

export interface ShoppingCartUpdateOneInput {
  create?: Maybe<ShoppingCartCreateInput>;
  update?: Maybe<ShoppingCartUpdateDataInput>;
  upsert?: Maybe<ShoppingCartUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ShoppingCartWhereUniqueInput>;
}

export interface ShoppingCartUpdateDataInput {
  total_cost?: Maybe<Float>;
  productItems?: Maybe<ShoppingCartItemUpdateManyWithoutShoppingCartInput>;
  customer?: Maybe<UserUpdateOneRequiredWithoutShoppingCartInput>;
}

export interface UserUpdateOneRequiredWithoutShoppingCartInput {
  create?: Maybe<UserCreateWithoutShoppingCartInput>;
  update?: Maybe<UserUpdateWithoutShoppingCartDataInput>;
  upsert?: Maybe<UserUpsertWithoutShoppingCartInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutShoppingCartDataInput {
  runningId?: Maybe<Int>;
  type?: Maybe<String>;
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  avatar?: Maybe<String>;
  activated?: Maybe<Boolean>;
  quotations?: Maybe<QuotationUpdateManyWithoutCustomerInput>;
  payments?: Maybe<PaymentUpdateManyWithoutCustomerInput>;
  addresses?: Maybe<AddressUpdateManyWithoutCustomerInput>;
}

export interface QuotationUpdateManyWithoutCustomerInput {
  create?: Maybe<
    QuotationCreateWithoutCustomerInput[] | QuotationCreateWithoutCustomerInput
  >;
  delete?: Maybe<QuotationWhereUniqueInput[] | QuotationWhereUniqueInput>;
  connect?: Maybe<QuotationWhereUniqueInput[] | QuotationWhereUniqueInput>;
  set?: Maybe<QuotationWhereUniqueInput[] | QuotationWhereUniqueInput>;
  disconnect?: Maybe<QuotationWhereUniqueInput[] | QuotationWhereUniqueInput>;
  update?: Maybe<
    | QuotationUpdateWithWhereUniqueWithoutCustomerInput[]
    | QuotationUpdateWithWhereUniqueWithoutCustomerInput
  >;
  upsert?: Maybe<
    | QuotationUpsertWithWhereUniqueWithoutCustomerInput[]
    | QuotationUpsertWithWhereUniqueWithoutCustomerInput
  >;
  deleteMany?: Maybe<QuotationScalarWhereInput[] | QuotationScalarWhereInput>;
  updateMany?: Maybe<
    | QuotationUpdateManyWithWhereNestedInput[]
    | QuotationUpdateManyWithWhereNestedInput
  >;
}

export interface QuotationUpdateWithWhereUniqueWithoutCustomerInput {
  where: QuotationWhereUniqueInput;
  data: QuotationUpdateWithoutCustomerDataInput;
}

export interface QuotationUpdateWithoutCustomerDataInput {
  docId?: Maybe<String>;
  quotationItem?: Maybe<QuotationItemUpdateManyWithoutQuotationInput>;
  salesman?: Maybe<SalesmanUpdateOneWithoutQuotationsInput>;
  payment?: Maybe<PaymentUpdateOneWithoutQuotationInput>;
  shipping?: Maybe<ShippingUpdateOneWithoutQuotationInput>;
  status?: Maybe<String>;
}

export interface QuotationItemUpdateManyWithoutQuotationInput {
  create?: Maybe<
    | QuotationItemCreateWithoutQuotationInput[]
    | QuotationItemCreateWithoutQuotationInput
  >;
  delete?: Maybe<
    QuotationItemWhereUniqueInput[] | QuotationItemWhereUniqueInput
  >;
  connect?: Maybe<
    QuotationItemWhereUniqueInput[] | QuotationItemWhereUniqueInput
  >;
  set?: Maybe<QuotationItemWhereUniqueInput[] | QuotationItemWhereUniqueInput>;
  disconnect?: Maybe<
    QuotationItemWhereUniqueInput[] | QuotationItemWhereUniqueInput
  >;
  update?: Maybe<
    | QuotationItemUpdateWithWhereUniqueWithoutQuotationInput[]
    | QuotationItemUpdateWithWhereUniqueWithoutQuotationInput
  >;
  upsert?: Maybe<
    | QuotationItemUpsertWithWhereUniqueWithoutQuotationInput[]
    | QuotationItemUpsertWithWhereUniqueWithoutQuotationInput
  >;
  deleteMany?: Maybe<
    QuotationItemScalarWhereInput[] | QuotationItemScalarWhereInput
  >;
  updateMany?: Maybe<
    | QuotationItemUpdateManyWithWhereNestedInput[]
    | QuotationItemUpdateManyWithWhereNestedInput
  >;
}

export interface QuotationItemUpdateWithWhereUniqueWithoutQuotationInput {
  where: QuotationItemWhereUniqueInput;
  data: QuotationItemUpdateWithoutQuotationDataInput;
}

export interface QuotationItemUpdateWithoutQuotationDataInput {
  key?: Maybe<String>;
  product?: Maybe<ProductItemUpdateOneRequiredInput>;
  amount?: Maybe<Int>;
  realPrice?: Maybe<Float>;
}

export interface QuotationItemUpsertWithWhereUniqueWithoutQuotationInput {
  where: QuotationItemWhereUniqueInput;
  update: QuotationItemUpdateWithoutQuotationDataInput;
  create: QuotationItemCreateWithoutQuotationInput;
}

export interface QuotationItemScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  key?: Maybe<String>;
  key_not?: Maybe<String>;
  key_in?: Maybe<String[] | String>;
  key_not_in?: Maybe<String[] | String>;
  key_lt?: Maybe<String>;
  key_lte?: Maybe<String>;
  key_gt?: Maybe<String>;
  key_gte?: Maybe<String>;
  key_contains?: Maybe<String>;
  key_not_contains?: Maybe<String>;
  key_starts_with?: Maybe<String>;
  key_not_starts_with?: Maybe<String>;
  key_ends_with?: Maybe<String>;
  key_not_ends_with?: Maybe<String>;
  amount?: Maybe<Int>;
  amount_not?: Maybe<Int>;
  amount_in?: Maybe<Int[] | Int>;
  amount_not_in?: Maybe<Int[] | Int>;
  amount_lt?: Maybe<Int>;
  amount_lte?: Maybe<Int>;
  amount_gt?: Maybe<Int>;
  amount_gte?: Maybe<Int>;
  realPrice?: Maybe<Float>;
  realPrice_not?: Maybe<Float>;
  realPrice_in?: Maybe<Float[] | Float>;
  realPrice_not_in?: Maybe<Float[] | Float>;
  realPrice_lt?: Maybe<Float>;
  realPrice_lte?: Maybe<Float>;
  realPrice_gt?: Maybe<Float>;
  realPrice_gte?: Maybe<Float>;
  AND?: Maybe<QuotationItemScalarWhereInput[] | QuotationItemScalarWhereInput>;
  OR?: Maybe<QuotationItemScalarWhereInput[] | QuotationItemScalarWhereInput>;
  NOT?: Maybe<QuotationItemScalarWhereInput[] | QuotationItemScalarWhereInput>;
}

export interface QuotationItemUpdateManyWithWhereNestedInput {
  where: QuotationItemScalarWhereInput;
  data: QuotationItemUpdateManyDataInput;
}

export interface QuotationItemUpdateManyDataInput {
  key?: Maybe<String>;
  amount?: Maybe<Int>;
  realPrice?: Maybe<Float>;
}

export interface SalesmanUpdateOneWithoutQuotationsInput {
  create?: Maybe<SalesmanCreateWithoutQuotationsInput>;
  update?: Maybe<SalesmanUpdateWithoutQuotationsDataInput>;
  upsert?: Maybe<SalesmanUpsertWithoutQuotationsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<SalesmanWhereUniqueInput>;
}

export interface SalesmanUpdateWithoutQuotationsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  phone?: Maybe<String>;
  payments?: Maybe<PaymentUpdateManyWithoutSalesmanInput>;
  invoices?: Maybe<InvoiceUpdateManyWithoutSalesmanInput>;
}

export interface PaymentUpdateManyWithoutSalesmanInput {
  create?: Maybe<
    PaymentCreateWithoutSalesmanInput[] | PaymentCreateWithoutSalesmanInput
  >;
  delete?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
  connect?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
  set?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
  disconnect?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
  update?: Maybe<
    | PaymentUpdateWithWhereUniqueWithoutSalesmanInput[]
    | PaymentUpdateWithWhereUniqueWithoutSalesmanInput
  >;
  upsert?: Maybe<
    | PaymentUpsertWithWhereUniqueWithoutSalesmanInput[]
    | PaymentUpsertWithWhereUniqueWithoutSalesmanInput
  >;
  deleteMany?: Maybe<PaymentScalarWhereInput[] | PaymentScalarWhereInput>;
  updateMany?: Maybe<
    | PaymentUpdateManyWithWhereNestedInput[]
    | PaymentUpdateManyWithWhereNestedInput
  >;
}

export interface PaymentUpdateWithWhereUniqueWithoutSalesmanInput {
  where: PaymentWhereUniqueInput;
  data: PaymentUpdateWithoutSalesmanDataInput;
}

export interface PaymentUpdateWithoutSalesmanDataInput {
  docId?: Maybe<String>;
  amount?: Maybe<String>;
  customer?: Maybe<UserUpdateOneRequiredWithoutPaymentsInput>;
  quotation?: Maybe<QuotationUpdateOneRequiredWithoutPaymentInput>;
  Invoice?: Maybe<InvoiceUpdateOneWithoutPaymentInput>;
  rawEvent?: Maybe<String>;
}

export interface UserUpdateOneRequiredWithoutPaymentsInput {
  create?: Maybe<UserCreateWithoutPaymentsInput>;
  update?: Maybe<UserUpdateWithoutPaymentsDataInput>;
  upsert?: Maybe<UserUpsertWithoutPaymentsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutPaymentsDataInput {
  runningId?: Maybe<Int>;
  type?: Maybe<String>;
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  avatar?: Maybe<String>;
  activated?: Maybe<Boolean>;
  shoppingCart?: Maybe<ShoppingCartUpdateOneRequiredWithoutCustomerInput>;
  quotations?: Maybe<QuotationUpdateManyWithoutCustomerInput>;
  addresses?: Maybe<AddressUpdateManyWithoutCustomerInput>;
}

export interface AddressUpdateManyWithoutCustomerInput {
  create?: Maybe<
    AddressCreateWithoutCustomerInput[] | AddressCreateWithoutCustomerInput
  >;
  delete?: Maybe<AddressWhereUniqueInput[] | AddressWhereUniqueInput>;
  connect?: Maybe<AddressWhereUniqueInput[] | AddressWhereUniqueInput>;
  set?: Maybe<AddressWhereUniqueInput[] | AddressWhereUniqueInput>;
  disconnect?: Maybe<AddressWhereUniqueInput[] | AddressWhereUniqueInput>;
  update?: Maybe<
    | AddressUpdateWithWhereUniqueWithoutCustomerInput[]
    | AddressUpdateWithWhereUniqueWithoutCustomerInput
  >;
  upsert?: Maybe<
    | AddressUpsertWithWhereUniqueWithoutCustomerInput[]
    | AddressUpsertWithWhereUniqueWithoutCustomerInput
  >;
  deleteMany?: Maybe<AddressScalarWhereInput[] | AddressScalarWhereInput>;
  updateMany?: Maybe<
    | AddressUpdateManyWithWhereNestedInput[]
    | AddressUpdateManyWithWhereNestedInput
  >;
}

export interface AddressUpdateWithWhereUniqueWithoutCustomerInput {
  where: AddressWhereUniqueInput;
  data: AddressUpdateWithoutCustomerDataInput;
}

export interface AddressUpdateWithoutCustomerDataInput {
  name?: Maybe<String>;
  Address?: Maybe<String>;
  invoices?: Maybe<InvoiceUpdateManyWithoutAddressInput>;
  shipping?: Maybe<ShippingUpdateManyWithoutAddressInput>;
}

export interface InvoiceUpdateManyWithoutAddressInput {
  create?: Maybe<
    InvoiceCreateWithoutAddressInput[] | InvoiceCreateWithoutAddressInput
  >;
  delete?: Maybe<InvoiceWhereUniqueInput[] | InvoiceWhereUniqueInput>;
  connect?: Maybe<InvoiceWhereUniqueInput[] | InvoiceWhereUniqueInput>;
  set?: Maybe<InvoiceWhereUniqueInput[] | InvoiceWhereUniqueInput>;
  disconnect?: Maybe<InvoiceWhereUniqueInput[] | InvoiceWhereUniqueInput>;
  update?: Maybe<
    | InvoiceUpdateWithWhereUniqueWithoutAddressInput[]
    | InvoiceUpdateWithWhereUniqueWithoutAddressInput
  >;
  upsert?: Maybe<
    | InvoiceUpsertWithWhereUniqueWithoutAddressInput[]
    | InvoiceUpsertWithWhereUniqueWithoutAddressInput
  >;
  deleteMany?: Maybe<InvoiceScalarWhereInput[] | InvoiceScalarWhereInput>;
  updateMany?: Maybe<
    | InvoiceUpdateManyWithWhereNestedInput[]
    | InvoiceUpdateManyWithWhereNestedInput
  >;
}

export interface InvoiceUpdateWithWhereUniqueWithoutAddressInput {
  where: InvoiceWhereUniqueInput;
  data: InvoiceUpdateWithoutAddressDataInput;
}

export interface InvoiceUpdateWithoutAddressDataInput {
  docId?: Maybe<String>;
  creditTerm?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredInput>;
  quotation?: Maybe<QuotationUpdateOneRequiredInput>;
  salesman?: Maybe<SalesmanUpdateOneRequiredWithoutInvoicesInput>;
  payment?: Maybe<PaymentUpdateOneWithoutInvoiceInput>;
}

export interface UserUpdateOneRequiredInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateDataInput {
  runningId?: Maybe<Int>;
  type?: Maybe<String>;
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  avatar?: Maybe<String>;
  activated?: Maybe<Boolean>;
  shoppingCart?: Maybe<ShoppingCartUpdateOneRequiredWithoutCustomerInput>;
  quotations?: Maybe<QuotationUpdateManyWithoutCustomerInput>;
  payments?: Maybe<PaymentUpdateManyWithoutCustomerInput>;
  addresses?: Maybe<AddressUpdateManyWithoutCustomerInput>;
}

export interface PaymentUpdateManyWithoutCustomerInput {
  create?: Maybe<
    PaymentCreateWithoutCustomerInput[] | PaymentCreateWithoutCustomerInput
  >;
  delete?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
  connect?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
  set?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
  disconnect?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
  update?: Maybe<
    | PaymentUpdateWithWhereUniqueWithoutCustomerInput[]
    | PaymentUpdateWithWhereUniqueWithoutCustomerInput
  >;
  upsert?: Maybe<
    | PaymentUpsertWithWhereUniqueWithoutCustomerInput[]
    | PaymentUpsertWithWhereUniqueWithoutCustomerInput
  >;
  deleteMany?: Maybe<PaymentScalarWhereInput[] | PaymentScalarWhereInput>;
  updateMany?: Maybe<
    | PaymentUpdateManyWithWhereNestedInput[]
    | PaymentUpdateManyWithWhereNestedInput
  >;
}

export interface PaymentUpdateWithWhereUniqueWithoutCustomerInput {
  where: PaymentWhereUniqueInput;
  data: PaymentUpdateWithoutCustomerDataInput;
}

export interface PaymentUpdateWithoutCustomerDataInput {
  docId?: Maybe<String>;
  amount?: Maybe<String>;
  salesman?: Maybe<SalesmanUpdateOneWithoutPaymentsInput>;
  quotation?: Maybe<QuotationUpdateOneRequiredWithoutPaymentInput>;
  Invoice?: Maybe<InvoiceUpdateOneWithoutPaymentInput>;
  rawEvent?: Maybe<String>;
}

export interface SalesmanUpdateOneWithoutPaymentsInput {
  create?: Maybe<SalesmanCreateWithoutPaymentsInput>;
  update?: Maybe<SalesmanUpdateWithoutPaymentsDataInput>;
  upsert?: Maybe<SalesmanUpsertWithoutPaymentsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<SalesmanWhereUniqueInput>;
}

export interface SalesmanUpdateWithoutPaymentsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  phone?: Maybe<String>;
  invoices?: Maybe<InvoiceUpdateManyWithoutSalesmanInput>;
  quotations?: Maybe<QuotationUpdateManyWithoutSalesmanInput>;
}

export interface InvoiceUpdateManyWithoutSalesmanInput {
  create?: Maybe<
    InvoiceCreateWithoutSalesmanInput[] | InvoiceCreateWithoutSalesmanInput
  >;
  delete?: Maybe<InvoiceWhereUniqueInput[] | InvoiceWhereUniqueInput>;
  connect?: Maybe<InvoiceWhereUniqueInput[] | InvoiceWhereUniqueInput>;
  set?: Maybe<InvoiceWhereUniqueInput[] | InvoiceWhereUniqueInput>;
  disconnect?: Maybe<InvoiceWhereUniqueInput[] | InvoiceWhereUniqueInput>;
  update?: Maybe<
    | InvoiceUpdateWithWhereUniqueWithoutSalesmanInput[]
    | InvoiceUpdateWithWhereUniqueWithoutSalesmanInput
  >;
  upsert?: Maybe<
    | InvoiceUpsertWithWhereUniqueWithoutSalesmanInput[]
    | InvoiceUpsertWithWhereUniqueWithoutSalesmanInput
  >;
  deleteMany?: Maybe<InvoiceScalarWhereInput[] | InvoiceScalarWhereInput>;
  updateMany?: Maybe<
    | InvoiceUpdateManyWithWhereNestedInput[]
    | InvoiceUpdateManyWithWhereNestedInput
  >;
}

export interface InvoiceUpdateWithWhereUniqueWithoutSalesmanInput {
  where: InvoiceWhereUniqueInput;
  data: InvoiceUpdateWithoutSalesmanDataInput;
}

export interface InvoiceUpdateWithoutSalesmanDataInput {
  docId?: Maybe<String>;
  creditTerm?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredInput>;
  quotation?: Maybe<QuotationUpdateOneRequiredInput>;
  address?: Maybe<AddressUpdateOneWithoutInvoicesInput>;
  payment?: Maybe<PaymentUpdateOneWithoutInvoiceInput>;
}

export interface QuotationUpdateOneRequiredInput {
  create?: Maybe<QuotationCreateInput>;
  update?: Maybe<QuotationUpdateDataInput>;
  upsert?: Maybe<QuotationUpsertNestedInput>;
  connect?: Maybe<QuotationWhereUniqueInput>;
}

export interface QuotationUpdateDataInput {
  docId?: Maybe<String>;
  quotationItem?: Maybe<QuotationItemUpdateManyWithoutQuotationInput>;
  salesman?: Maybe<SalesmanUpdateOneWithoutQuotationsInput>;
  payment?: Maybe<PaymentUpdateOneWithoutQuotationInput>;
  shipping?: Maybe<ShippingUpdateOneWithoutQuotationInput>;
  customer?: Maybe<UserUpdateOneRequiredWithoutQuotationsInput>;
  status?: Maybe<String>;
}

export interface PaymentUpdateOneWithoutQuotationInput {
  create?: Maybe<PaymentCreateWithoutQuotationInput>;
  update?: Maybe<PaymentUpdateWithoutQuotationDataInput>;
  upsert?: Maybe<PaymentUpsertWithoutQuotationInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PaymentWhereUniqueInput>;
}

export interface PaymentUpdateWithoutQuotationDataInput {
  docId?: Maybe<String>;
  amount?: Maybe<String>;
  customer?: Maybe<UserUpdateOneRequiredWithoutPaymentsInput>;
  salesman?: Maybe<SalesmanUpdateOneWithoutPaymentsInput>;
  Invoice?: Maybe<InvoiceUpdateOneWithoutPaymentInput>;
  rawEvent?: Maybe<String>;
}

export interface InvoiceUpdateOneWithoutPaymentInput {
  create?: Maybe<InvoiceCreateWithoutPaymentInput>;
  update?: Maybe<InvoiceUpdateWithoutPaymentDataInput>;
  upsert?: Maybe<InvoiceUpsertWithoutPaymentInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<InvoiceWhereUniqueInput>;
}

export interface InvoiceUpdateWithoutPaymentDataInput {
  docId?: Maybe<String>;
  creditTerm?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredInput>;
  quotation?: Maybe<QuotationUpdateOneRequiredInput>;
  salesman?: Maybe<SalesmanUpdateOneRequiredWithoutInvoicesInput>;
  address?: Maybe<AddressUpdateOneWithoutInvoicesInput>;
}

export interface SalesmanUpdateOneRequiredWithoutInvoicesInput {
  create?: Maybe<SalesmanCreateWithoutInvoicesInput>;
  update?: Maybe<SalesmanUpdateWithoutInvoicesDataInput>;
  upsert?: Maybe<SalesmanUpsertWithoutInvoicesInput>;
  connect?: Maybe<SalesmanWhereUniqueInput>;
}

export interface SalesmanUpdateWithoutInvoicesDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  phone?: Maybe<String>;
  payments?: Maybe<PaymentUpdateManyWithoutSalesmanInput>;
  quotations?: Maybe<QuotationUpdateManyWithoutSalesmanInput>;
}

export interface QuotationUpdateManyWithoutSalesmanInput {
  create?: Maybe<
    QuotationCreateWithoutSalesmanInput[] | QuotationCreateWithoutSalesmanInput
  >;
  delete?: Maybe<QuotationWhereUniqueInput[] | QuotationWhereUniqueInput>;
  connect?: Maybe<QuotationWhereUniqueInput[] | QuotationWhereUniqueInput>;
  set?: Maybe<QuotationWhereUniqueInput[] | QuotationWhereUniqueInput>;
  disconnect?: Maybe<QuotationWhereUniqueInput[] | QuotationWhereUniqueInput>;
  update?: Maybe<
    | QuotationUpdateWithWhereUniqueWithoutSalesmanInput[]
    | QuotationUpdateWithWhereUniqueWithoutSalesmanInput
  >;
  upsert?: Maybe<
    | QuotationUpsertWithWhereUniqueWithoutSalesmanInput[]
    | QuotationUpsertWithWhereUniqueWithoutSalesmanInput
  >;
  deleteMany?: Maybe<QuotationScalarWhereInput[] | QuotationScalarWhereInput>;
  updateMany?: Maybe<
    | QuotationUpdateManyWithWhereNestedInput[]
    | QuotationUpdateManyWithWhereNestedInput
  >;
}

export interface QuotationUpdateWithWhereUniqueWithoutSalesmanInput {
  where: QuotationWhereUniqueInput;
  data: QuotationUpdateWithoutSalesmanDataInput;
}

export interface QuotationUpdateWithoutSalesmanDataInput {
  docId?: Maybe<String>;
  quotationItem?: Maybe<QuotationItemUpdateManyWithoutQuotationInput>;
  payment?: Maybe<PaymentUpdateOneWithoutQuotationInput>;
  shipping?: Maybe<ShippingUpdateOneWithoutQuotationInput>;
  customer?: Maybe<UserUpdateOneRequiredWithoutQuotationsInput>;
  status?: Maybe<String>;
}

export interface ShippingUpdateOneWithoutQuotationInput {
  create?: Maybe<ShippingCreateWithoutQuotationInput>;
  update?: Maybe<ShippingUpdateWithoutQuotationDataInput>;
  upsert?: Maybe<ShippingUpsertWithoutQuotationInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ShippingWhereUniqueInput>;
}

export interface ShippingUpdateWithoutQuotationDataInput {
  docId?: Maybe<String>;
  dueDate?: Maybe<DateTimeInput>;
  status?: Maybe<String>;
  invoce?: Maybe<InvoiceUpdateOneRequiredInput>;
  address?: Maybe<AddressUpdateOneRequiredWithoutShippingInput>;
}

export interface InvoiceUpdateOneRequiredInput {
  create?: Maybe<InvoiceCreateInput>;
  update?: Maybe<InvoiceUpdateDataInput>;
  upsert?: Maybe<InvoiceUpsertNestedInput>;
  connect?: Maybe<InvoiceWhereUniqueInput>;
}

export interface InvoiceUpdateDataInput {
  docId?: Maybe<String>;
  creditTerm?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredInput>;
  quotation?: Maybe<QuotationUpdateOneRequiredInput>;
  salesman?: Maybe<SalesmanUpdateOneRequiredWithoutInvoicesInput>;
  address?: Maybe<AddressUpdateOneWithoutInvoicesInput>;
  payment?: Maybe<PaymentUpdateOneWithoutInvoiceInput>;
}

export interface AddressUpdateOneWithoutInvoicesInput {
  create?: Maybe<AddressCreateWithoutInvoicesInput>;
  update?: Maybe<AddressUpdateWithoutInvoicesDataInput>;
  upsert?: Maybe<AddressUpsertWithoutInvoicesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<AddressWhereUniqueInput>;
}

export interface AddressUpdateWithoutInvoicesDataInput {
  name?: Maybe<String>;
  Address?: Maybe<String>;
  customer?: Maybe<UserUpdateOneRequiredWithoutAddressesInput>;
  shipping?: Maybe<ShippingUpdateManyWithoutAddressInput>;
}

export interface ShippingUpdateManyWithoutAddressInput {
  create?: Maybe<
    ShippingCreateWithoutAddressInput[] | ShippingCreateWithoutAddressInput
  >;
  delete?: Maybe<ShippingWhereUniqueInput[] | ShippingWhereUniqueInput>;
  connect?: Maybe<ShippingWhereUniqueInput[] | ShippingWhereUniqueInput>;
  set?: Maybe<ShippingWhereUniqueInput[] | ShippingWhereUniqueInput>;
  disconnect?: Maybe<ShippingWhereUniqueInput[] | ShippingWhereUniqueInput>;
  update?: Maybe<
    | ShippingUpdateWithWhereUniqueWithoutAddressInput[]
    | ShippingUpdateWithWhereUniqueWithoutAddressInput
  >;
  upsert?: Maybe<
    | ShippingUpsertWithWhereUniqueWithoutAddressInput[]
    | ShippingUpsertWithWhereUniqueWithoutAddressInput
  >;
  deleteMany?: Maybe<ShippingScalarWhereInput[] | ShippingScalarWhereInput>;
  updateMany?: Maybe<
    | ShippingUpdateManyWithWhereNestedInput[]
    | ShippingUpdateManyWithWhereNestedInput
  >;
}

export interface ShippingUpdateWithWhereUniqueWithoutAddressInput {
  where: ShippingWhereUniqueInput;
  data: ShippingUpdateWithoutAddressDataInput;
}

export interface ShippingUpdateWithoutAddressDataInput {
  docId?: Maybe<String>;
  dueDate?: Maybe<DateTimeInput>;
  status?: Maybe<String>;
  invoce?: Maybe<InvoiceUpdateOneRequiredInput>;
  quotation?: Maybe<QuotationUpdateOneRequiredWithoutShippingInput>;
}

export interface QuotationUpdateOneRequiredWithoutShippingInput {
  create?: Maybe<QuotationCreateWithoutShippingInput>;
  update?: Maybe<QuotationUpdateWithoutShippingDataInput>;
  upsert?: Maybe<QuotationUpsertWithoutShippingInput>;
  connect?: Maybe<QuotationWhereUniqueInput>;
}

export interface QuotationUpdateWithoutShippingDataInput {
  docId?: Maybe<String>;
  quotationItem?: Maybe<QuotationItemUpdateManyWithoutQuotationInput>;
  salesman?: Maybe<SalesmanUpdateOneWithoutQuotationsInput>;
  payment?: Maybe<PaymentUpdateOneWithoutQuotationInput>;
  customer?: Maybe<UserUpdateOneRequiredWithoutQuotationsInput>;
  status?: Maybe<String>;
}

export interface UserUpdateOneRequiredWithoutQuotationsInput {
  create?: Maybe<UserCreateWithoutQuotationsInput>;
  update?: Maybe<UserUpdateWithoutQuotationsDataInput>;
  upsert?: Maybe<UserUpsertWithoutQuotationsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutQuotationsDataInput {
  runningId?: Maybe<Int>;
  type?: Maybe<String>;
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  avatar?: Maybe<String>;
  activated?: Maybe<Boolean>;
  shoppingCart?: Maybe<ShoppingCartUpdateOneRequiredWithoutCustomerInput>;
  payments?: Maybe<PaymentUpdateManyWithoutCustomerInput>;
  addresses?: Maybe<AddressUpdateManyWithoutCustomerInput>;
}

export interface UserUpsertWithoutQuotationsInput {
  update: UserUpdateWithoutQuotationsDataInput;
  create: UserCreateWithoutQuotationsInput;
}

export interface QuotationUpsertWithoutShippingInput {
  update: QuotationUpdateWithoutShippingDataInput;
  create: QuotationCreateWithoutShippingInput;
}

export interface ShippingUpsertWithWhereUniqueWithoutAddressInput {
  where: ShippingWhereUniqueInput;
  update: ShippingUpdateWithoutAddressDataInput;
  create: ShippingCreateWithoutAddressInput;
}

export interface ShippingScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  docId?: Maybe<String>;
  docId_not?: Maybe<String>;
  docId_in?: Maybe<String[] | String>;
  docId_not_in?: Maybe<String[] | String>;
  docId_lt?: Maybe<String>;
  docId_lte?: Maybe<String>;
  docId_gt?: Maybe<String>;
  docId_gte?: Maybe<String>;
  docId_contains?: Maybe<String>;
  docId_not_contains?: Maybe<String>;
  docId_starts_with?: Maybe<String>;
  docId_not_starts_with?: Maybe<String>;
  docId_ends_with?: Maybe<String>;
  docId_not_ends_with?: Maybe<String>;
  dueDate?: Maybe<DateTimeInput>;
  dueDate_not?: Maybe<DateTimeInput>;
  dueDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dueDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dueDate_lt?: Maybe<DateTimeInput>;
  dueDate_lte?: Maybe<DateTimeInput>;
  dueDate_gt?: Maybe<DateTimeInput>;
  dueDate_gte?: Maybe<DateTimeInput>;
  status?: Maybe<String>;
  status_not?: Maybe<String>;
  status_in?: Maybe<String[] | String>;
  status_not_in?: Maybe<String[] | String>;
  status_lt?: Maybe<String>;
  status_lte?: Maybe<String>;
  status_gt?: Maybe<String>;
  status_gte?: Maybe<String>;
  status_contains?: Maybe<String>;
  status_not_contains?: Maybe<String>;
  status_starts_with?: Maybe<String>;
  status_not_starts_with?: Maybe<String>;
  status_ends_with?: Maybe<String>;
  status_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ShippingScalarWhereInput[] | ShippingScalarWhereInput>;
  OR?: Maybe<ShippingScalarWhereInput[] | ShippingScalarWhereInput>;
  NOT?: Maybe<ShippingScalarWhereInput[] | ShippingScalarWhereInput>;
}

export interface ShippingUpdateManyWithWhereNestedInput {
  where: ShippingScalarWhereInput;
  data: ShippingUpdateManyDataInput;
}

export interface ShippingUpdateManyDataInput {
  docId?: Maybe<String>;
  dueDate?: Maybe<DateTimeInput>;
  status?: Maybe<String>;
}

export interface AddressUpsertWithoutInvoicesInput {
  update: AddressUpdateWithoutInvoicesDataInput;
  create: AddressCreateWithoutInvoicesInput;
}

export interface PaymentUpdateOneWithoutInvoiceInput {
  create?: Maybe<PaymentCreateWithoutInvoiceInput>;
  update?: Maybe<PaymentUpdateWithoutInvoiceDataInput>;
  upsert?: Maybe<PaymentUpsertWithoutInvoiceInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PaymentWhereUniqueInput>;
}

export interface PaymentUpdateWithoutInvoiceDataInput {
  docId?: Maybe<String>;
  amount?: Maybe<String>;
  customer?: Maybe<UserUpdateOneRequiredWithoutPaymentsInput>;
  salesman?: Maybe<SalesmanUpdateOneWithoutPaymentsInput>;
  quotation?: Maybe<QuotationUpdateOneRequiredWithoutPaymentInput>;
  rawEvent?: Maybe<String>;
}

export interface QuotationUpdateOneRequiredWithoutPaymentInput {
  create?: Maybe<QuotationCreateWithoutPaymentInput>;
  update?: Maybe<QuotationUpdateWithoutPaymentDataInput>;
  upsert?: Maybe<QuotationUpsertWithoutPaymentInput>;
  connect?: Maybe<QuotationWhereUniqueInput>;
}

export interface QuotationUpdateWithoutPaymentDataInput {
  docId?: Maybe<String>;
  quotationItem?: Maybe<QuotationItemUpdateManyWithoutQuotationInput>;
  salesman?: Maybe<SalesmanUpdateOneWithoutQuotationsInput>;
  shipping?: Maybe<ShippingUpdateOneWithoutQuotationInput>;
  customer?: Maybe<UserUpdateOneRequiredWithoutQuotationsInput>;
  status?: Maybe<String>;
}

export interface QuotationUpsertWithoutPaymentInput {
  update: QuotationUpdateWithoutPaymentDataInput;
  create: QuotationCreateWithoutPaymentInput;
}

export interface PaymentUpsertWithoutInvoiceInput {
  update: PaymentUpdateWithoutInvoiceDataInput;
  create: PaymentCreateWithoutInvoiceInput;
}

export interface InvoiceUpsertNestedInput {
  update: InvoiceUpdateDataInput;
  create: InvoiceCreateInput;
}

export interface AddressUpdateOneRequiredWithoutShippingInput {
  create?: Maybe<AddressCreateWithoutShippingInput>;
  update?: Maybe<AddressUpdateWithoutShippingDataInput>;
  upsert?: Maybe<AddressUpsertWithoutShippingInput>;
  connect?: Maybe<AddressWhereUniqueInput>;
}

export interface AddressUpdateWithoutShippingDataInput {
  name?: Maybe<String>;
  Address?: Maybe<String>;
  customer?: Maybe<UserUpdateOneRequiredWithoutAddressesInput>;
  invoices?: Maybe<InvoiceUpdateManyWithoutAddressInput>;
}

export interface AddressUpsertWithoutShippingInput {
  update: AddressUpdateWithoutShippingDataInput;
  create: AddressCreateWithoutShippingInput;
}

export interface ShippingUpsertWithoutQuotationInput {
  update: ShippingUpdateWithoutQuotationDataInput;
  create: ShippingCreateWithoutQuotationInput;
}

export interface QuotationUpsertWithWhereUniqueWithoutSalesmanInput {
  where: QuotationWhereUniqueInput;
  update: QuotationUpdateWithoutSalesmanDataInput;
  create: QuotationCreateWithoutSalesmanInput;
}

export interface QuotationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  docId?: Maybe<String>;
  docId_not?: Maybe<String>;
  docId_in?: Maybe<String[] | String>;
  docId_not_in?: Maybe<String[] | String>;
  docId_lt?: Maybe<String>;
  docId_lte?: Maybe<String>;
  docId_gt?: Maybe<String>;
  docId_gte?: Maybe<String>;
  docId_contains?: Maybe<String>;
  docId_not_contains?: Maybe<String>;
  docId_starts_with?: Maybe<String>;
  docId_not_starts_with?: Maybe<String>;
  docId_ends_with?: Maybe<String>;
  docId_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  status?: Maybe<String>;
  status_not?: Maybe<String>;
  status_in?: Maybe<String[] | String>;
  status_not_in?: Maybe<String[] | String>;
  status_lt?: Maybe<String>;
  status_lte?: Maybe<String>;
  status_gt?: Maybe<String>;
  status_gte?: Maybe<String>;
  status_contains?: Maybe<String>;
  status_not_contains?: Maybe<String>;
  status_starts_with?: Maybe<String>;
  status_not_starts_with?: Maybe<String>;
  status_ends_with?: Maybe<String>;
  status_not_ends_with?: Maybe<String>;
  AND?: Maybe<QuotationScalarWhereInput[] | QuotationScalarWhereInput>;
  OR?: Maybe<QuotationScalarWhereInput[] | QuotationScalarWhereInput>;
  NOT?: Maybe<QuotationScalarWhereInput[] | QuotationScalarWhereInput>;
}

export interface QuotationUpdateManyWithWhereNestedInput {
  where: QuotationScalarWhereInput;
  data: QuotationUpdateManyDataInput;
}

export interface QuotationUpdateManyDataInput {
  docId?: Maybe<String>;
  status?: Maybe<String>;
}

export interface SalesmanUpsertWithoutInvoicesInput {
  update: SalesmanUpdateWithoutInvoicesDataInput;
  create: SalesmanCreateWithoutInvoicesInput;
}

export interface InvoiceUpsertWithoutPaymentInput {
  update: InvoiceUpdateWithoutPaymentDataInput;
  create: InvoiceCreateWithoutPaymentInput;
}

export interface PaymentUpsertWithoutQuotationInput {
  update: PaymentUpdateWithoutQuotationDataInput;
  create: PaymentCreateWithoutQuotationInput;
}

export interface QuotationUpsertNestedInput {
  update: QuotationUpdateDataInput;
  create: QuotationCreateInput;
}

export interface InvoiceUpsertWithWhereUniqueWithoutSalesmanInput {
  where: InvoiceWhereUniqueInput;
  update: InvoiceUpdateWithoutSalesmanDataInput;
  create: InvoiceCreateWithoutSalesmanInput;
}

export interface InvoiceScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  docId?: Maybe<String>;
  docId_not?: Maybe<String>;
  docId_in?: Maybe<String[] | String>;
  docId_not_in?: Maybe<String[] | String>;
  docId_lt?: Maybe<String>;
  docId_lte?: Maybe<String>;
  docId_gt?: Maybe<String>;
  docId_gte?: Maybe<String>;
  docId_contains?: Maybe<String>;
  docId_not_contains?: Maybe<String>;
  docId_starts_with?: Maybe<String>;
  docId_not_starts_with?: Maybe<String>;
  docId_ends_with?: Maybe<String>;
  docId_not_ends_with?: Maybe<String>;
  creditTerm?: Maybe<String>;
  creditTerm_not?: Maybe<String>;
  creditTerm_in?: Maybe<String[] | String>;
  creditTerm_not_in?: Maybe<String[] | String>;
  creditTerm_lt?: Maybe<String>;
  creditTerm_lte?: Maybe<String>;
  creditTerm_gt?: Maybe<String>;
  creditTerm_gte?: Maybe<String>;
  creditTerm_contains?: Maybe<String>;
  creditTerm_not_contains?: Maybe<String>;
  creditTerm_starts_with?: Maybe<String>;
  creditTerm_not_starts_with?: Maybe<String>;
  creditTerm_ends_with?: Maybe<String>;
  creditTerm_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<InvoiceScalarWhereInput[] | InvoiceScalarWhereInput>;
  OR?: Maybe<InvoiceScalarWhereInput[] | InvoiceScalarWhereInput>;
  NOT?: Maybe<InvoiceScalarWhereInput[] | InvoiceScalarWhereInput>;
}

export interface InvoiceUpdateManyWithWhereNestedInput {
  where: InvoiceScalarWhereInput;
  data: InvoiceUpdateManyDataInput;
}

export interface InvoiceUpdateManyDataInput {
  docId?: Maybe<String>;
  creditTerm?: Maybe<String>;
}

export interface SalesmanUpsertWithoutPaymentsInput {
  update: SalesmanUpdateWithoutPaymentsDataInput;
  create: SalesmanCreateWithoutPaymentsInput;
}

export interface PaymentUpsertWithWhereUniqueWithoutCustomerInput {
  where: PaymentWhereUniqueInput;
  update: PaymentUpdateWithoutCustomerDataInput;
  create: PaymentCreateWithoutCustomerInput;
}

export interface PaymentScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  docId?: Maybe<String>;
  docId_not?: Maybe<String>;
  docId_in?: Maybe<String[] | String>;
  docId_not_in?: Maybe<String[] | String>;
  docId_lt?: Maybe<String>;
  docId_lte?: Maybe<String>;
  docId_gt?: Maybe<String>;
  docId_gte?: Maybe<String>;
  docId_contains?: Maybe<String>;
  docId_not_contains?: Maybe<String>;
  docId_starts_with?: Maybe<String>;
  docId_not_starts_with?: Maybe<String>;
  docId_ends_with?: Maybe<String>;
  docId_not_ends_with?: Maybe<String>;
  amount?: Maybe<String>;
  amount_not?: Maybe<String>;
  amount_in?: Maybe<String[] | String>;
  amount_not_in?: Maybe<String[] | String>;
  amount_lt?: Maybe<String>;
  amount_lte?: Maybe<String>;
  amount_gt?: Maybe<String>;
  amount_gte?: Maybe<String>;
  amount_contains?: Maybe<String>;
  amount_not_contains?: Maybe<String>;
  amount_starts_with?: Maybe<String>;
  amount_not_starts_with?: Maybe<String>;
  amount_ends_with?: Maybe<String>;
  amount_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  rawEvent?: Maybe<String>;
  rawEvent_not?: Maybe<String>;
  rawEvent_in?: Maybe<String[] | String>;
  rawEvent_not_in?: Maybe<String[] | String>;
  rawEvent_lt?: Maybe<String>;
  rawEvent_lte?: Maybe<String>;
  rawEvent_gt?: Maybe<String>;
  rawEvent_gte?: Maybe<String>;
  rawEvent_contains?: Maybe<String>;
  rawEvent_not_contains?: Maybe<String>;
  rawEvent_starts_with?: Maybe<String>;
  rawEvent_not_starts_with?: Maybe<String>;
  rawEvent_ends_with?: Maybe<String>;
  rawEvent_not_ends_with?: Maybe<String>;
  AND?: Maybe<PaymentScalarWhereInput[] | PaymentScalarWhereInput>;
  OR?: Maybe<PaymentScalarWhereInput[] | PaymentScalarWhereInput>;
  NOT?: Maybe<PaymentScalarWhereInput[] | PaymentScalarWhereInput>;
}

export interface PaymentUpdateManyWithWhereNestedInput {
  where: PaymentScalarWhereInput;
  data: PaymentUpdateManyDataInput;
}

export interface PaymentUpdateManyDataInput {
  docId?: Maybe<String>;
  amount?: Maybe<String>;
  rawEvent?: Maybe<String>;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface InvoiceUpsertWithWhereUniqueWithoutAddressInput {
  where: InvoiceWhereUniqueInput;
  update: InvoiceUpdateWithoutAddressDataInput;
  create: InvoiceCreateWithoutAddressInput;
}

export interface AddressUpsertWithWhereUniqueWithoutCustomerInput {
  where: AddressWhereUniqueInput;
  update: AddressUpdateWithoutCustomerDataInput;
  create: AddressCreateWithoutCustomerInput;
}

export interface AddressScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  Address?: Maybe<String>;
  Address_not?: Maybe<String>;
  Address_in?: Maybe<String[] | String>;
  Address_not_in?: Maybe<String[] | String>;
  Address_lt?: Maybe<String>;
  Address_lte?: Maybe<String>;
  Address_gt?: Maybe<String>;
  Address_gte?: Maybe<String>;
  Address_contains?: Maybe<String>;
  Address_not_contains?: Maybe<String>;
  Address_starts_with?: Maybe<String>;
  Address_not_starts_with?: Maybe<String>;
  Address_ends_with?: Maybe<String>;
  Address_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<AddressScalarWhereInput[] | AddressScalarWhereInput>;
  OR?: Maybe<AddressScalarWhereInput[] | AddressScalarWhereInput>;
  NOT?: Maybe<AddressScalarWhereInput[] | AddressScalarWhereInput>;
}

export interface AddressUpdateManyWithWhereNestedInput {
  where: AddressScalarWhereInput;
  data: AddressUpdateManyDataInput;
}

export interface AddressUpdateManyDataInput {
  name?: Maybe<String>;
  Address?: Maybe<String>;
}

export interface UserUpsertWithoutPaymentsInput {
  update: UserUpdateWithoutPaymentsDataInput;
  create: UserCreateWithoutPaymentsInput;
}

export interface PaymentUpsertWithWhereUniqueWithoutSalesmanInput {
  where: PaymentWhereUniqueInput;
  update: PaymentUpdateWithoutSalesmanDataInput;
  create: PaymentCreateWithoutSalesmanInput;
}

export interface SalesmanUpsertWithoutQuotationsInput {
  update: SalesmanUpdateWithoutQuotationsDataInput;
  create: SalesmanCreateWithoutQuotationsInput;
}

export interface QuotationUpsertWithWhereUniqueWithoutCustomerInput {
  where: QuotationWhereUniqueInput;
  update: QuotationUpdateWithoutCustomerDataInput;
  create: QuotationCreateWithoutCustomerInput;
}

export interface UserUpsertWithoutShoppingCartInput {
  update: UserUpdateWithoutShoppingCartDataInput;
  create: UserCreateWithoutShoppingCartInput;
}

export interface ShoppingCartUpsertNestedInput {
  update: ShoppingCartUpdateDataInput;
  create: ShoppingCartCreateInput;
}

export interface QuotationUpdateOneInput {
  create?: Maybe<QuotationCreateInput>;
  update?: Maybe<QuotationUpdateDataInput>;
  upsert?: Maybe<QuotationUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<QuotationWhereUniqueInput>;
}

export interface ProductItemUpdateManyInput {
  create?: Maybe<ProductItemCreateInput[] | ProductItemCreateInput>;
  update?: Maybe<
    | ProductItemUpdateWithWhereUniqueNestedInput[]
    | ProductItemUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ProductItemUpsertWithWhereUniqueNestedInput[]
    | ProductItemUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ProductItemWhereUniqueInput[] | ProductItemWhereUniqueInput>;
  connect?: Maybe<ProductItemWhereUniqueInput[] | ProductItemWhereUniqueInput>;
  set?: Maybe<ProductItemWhereUniqueInput[] | ProductItemWhereUniqueInput>;
  disconnect?: Maybe<
    ProductItemWhereUniqueInput[] | ProductItemWhereUniqueInput
  >;
  deleteMany?: Maybe<
    ProductItemScalarWhereInput[] | ProductItemScalarWhereInput
  >;
  updateMany?: Maybe<
    | ProductItemUpdateManyWithWhereNestedInput[]
    | ProductItemUpdateManyWithWhereNestedInput
  >;
}

export interface ProductItemUpdateWithWhereUniqueNestedInput {
  where: ProductItemWhereUniqueInput;
  data: ProductItemUpdateDataInput;
}

export interface ProductItemUpsertWithWhereUniqueNestedInput {
  where: ProductItemWhereUniqueInput;
  update: ProductItemUpdateDataInput;
  create: ProductItemCreateInput;
}

export interface ProductItemScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  price?: Maybe<String>;
  price_not?: Maybe<String>;
  price_in?: Maybe<String[] | String>;
  price_not_in?: Maybe<String[] | String>;
  price_lt?: Maybe<String>;
  price_lte?: Maybe<String>;
  price_gt?: Maybe<String>;
  price_gte?: Maybe<String>;
  price_contains?: Maybe<String>;
  price_not_contains?: Maybe<String>;
  price_starts_with?: Maybe<String>;
  price_not_starts_with?: Maybe<String>;
  price_ends_with?: Maybe<String>;
  price_not_ends_with?: Maybe<String>;
  salePrice?: Maybe<String>;
  salePrice_not?: Maybe<String>;
  salePrice_in?: Maybe<String[] | String>;
  salePrice_not_in?: Maybe<String[] | String>;
  salePrice_lt?: Maybe<String>;
  salePrice_lte?: Maybe<String>;
  salePrice_gt?: Maybe<String>;
  salePrice_gte?: Maybe<String>;
  salePrice_contains?: Maybe<String>;
  salePrice_not_contains?: Maybe<String>;
  salePrice_starts_with?: Maybe<String>;
  salePrice_not_starts_with?: Maybe<String>;
  salePrice_ends_with?: Maybe<String>;
  salePrice_not_ends_with?: Maybe<String>;
  brand?: Maybe<String>;
  brand_not?: Maybe<String>;
  brand_in?: Maybe<String[] | String>;
  brand_not_in?: Maybe<String[] | String>;
  brand_lt?: Maybe<String>;
  brand_lte?: Maybe<String>;
  brand_gt?: Maybe<String>;
  brand_gte?: Maybe<String>;
  brand_contains?: Maybe<String>;
  brand_not_contains?: Maybe<String>;
  brand_starts_with?: Maybe<String>;
  brand_not_starts_with?: Maybe<String>;
  brand_ends_with?: Maybe<String>;
  brand_not_ends_with?: Maybe<String>;
  unitType?: Maybe<String>;
  unitType_not?: Maybe<String>;
  unitType_in?: Maybe<String[] | String>;
  unitType_not_in?: Maybe<String[] | String>;
  unitType_lt?: Maybe<String>;
  unitType_lte?: Maybe<String>;
  unitType_gt?: Maybe<String>;
  unitType_gte?: Maybe<String>;
  unitType_contains?: Maybe<String>;
  unitType_not_contains?: Maybe<String>;
  unitType_starts_with?: Maybe<String>;
  unitType_not_starts_with?: Maybe<String>;
  unitType_ends_with?: Maybe<String>;
  unitType_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  MenuDetail?: Maybe<String>;
  MenuDetail_not?: Maybe<String>;
  MenuDetail_in?: Maybe<String[] | String>;
  MenuDetail_not_in?: Maybe<String[] | String>;
  MenuDetail_lt?: Maybe<String>;
  MenuDetail_lte?: Maybe<String>;
  MenuDetail_gt?: Maybe<String>;
  MenuDetail_gte?: Maybe<String>;
  MenuDetail_contains?: Maybe<String>;
  MenuDetail_not_contains?: Maybe<String>;
  MenuDetail_starts_with?: Maybe<String>;
  MenuDetail_not_starts_with?: Maybe<String>;
  MenuDetail_ends_with?: Maybe<String>;
  MenuDetail_not_ends_with?: Maybe<String>;
  TermDetail?: Maybe<String>;
  TermDetail_not?: Maybe<String>;
  TermDetail_in?: Maybe<String[] | String>;
  TermDetail_not_in?: Maybe<String[] | String>;
  TermDetail_lt?: Maybe<String>;
  TermDetail_lte?: Maybe<String>;
  TermDetail_gt?: Maybe<String>;
  TermDetail_gte?: Maybe<String>;
  TermDetail_contains?: Maybe<String>;
  TermDetail_not_contains?: Maybe<String>;
  TermDetail_starts_with?: Maybe<String>;
  TermDetail_not_starts_with?: Maybe<String>;
  TermDetail_ends_with?: Maybe<String>;
  TermDetail_not_ends_with?: Maybe<String>;
  amount?: Maybe<Int>;
  amount_not?: Maybe<Int>;
  amount_in?: Maybe<Int[] | Int>;
  amount_not_in?: Maybe<Int[] | Int>;
  amount_lt?: Maybe<Int>;
  amount_lte?: Maybe<Int>;
  amount_gt?: Maybe<Int>;
  amount_gte?: Maybe<Int>;
  isPublished?: Maybe<Boolean>;
  isPublished_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  AND?: Maybe<ProductItemScalarWhereInput[] | ProductItemScalarWhereInput>;
  OR?: Maybe<ProductItemScalarWhereInput[] | ProductItemScalarWhereInput>;
  NOT?: Maybe<ProductItemScalarWhereInput[] | ProductItemScalarWhereInput>;
}

export interface ProductItemUpdateManyWithWhereNestedInput {
  where: ProductItemScalarWhereInput;
  data: ProductItemUpdateManyDataInput;
}

export interface ProductItemUpdateManyDataInput {
  name?: Maybe<String>;
  price?: Maybe<String>;
  salePrice?: Maybe<String>;
  brand?: Maybe<String>;
  unitType?: Maybe<String>;
  description?: Maybe<String>;
  MenuDetail?: Maybe<String>;
  TermDetail?: Maybe<String>;
  amount?: Maybe<Int>;
  isPublished?: Maybe<Boolean>;
  image?: Maybe<String>;
}

export interface ProductItemUpsertWithWhereUniqueWithoutCategoryInput {
  where: ProductItemWhereUniqueInput;
  update: ProductItemUpdateWithoutCategoryDataInput;
  create: ProductItemCreateWithoutCategoryInput;
}

export interface CategoryUpsertNestedInput {
  update: CategoryUpdateDataInput;
  create: CategoryCreateInput;
}

export interface CategoryUpsertWithoutProductItemInput {
  update: CategoryUpdateWithoutProductItemDataInput;
  create: CategoryCreateWithoutProductItemInput;
}

export interface ProductItemUpsertNestedInput {
  update: ProductItemUpdateDataInput;
  create: ProductItemCreateInput;
}

export interface ShoppingCartItemUpsertWithWhereUniqueWithoutShoppingCartInput {
  where: ShoppingCartItemWhereUniqueInput;
  update: ShoppingCartItemUpdateWithoutShoppingCartDataInput;
  create: ShoppingCartItemCreateWithoutShoppingCartInput;
}

export interface ShoppingCartItemScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  key?: Maybe<String>;
  key_not?: Maybe<String>;
  key_in?: Maybe<String[] | String>;
  key_not_in?: Maybe<String[] | String>;
  key_lt?: Maybe<String>;
  key_lte?: Maybe<String>;
  key_gt?: Maybe<String>;
  key_gte?: Maybe<String>;
  key_contains?: Maybe<String>;
  key_not_contains?: Maybe<String>;
  key_starts_with?: Maybe<String>;
  key_not_starts_with?: Maybe<String>;
  key_ends_with?: Maybe<String>;
  key_not_ends_with?: Maybe<String>;
  amount?: Maybe<Int>;
  amount_not?: Maybe<Int>;
  amount_in?: Maybe<Int[] | Int>;
  amount_not_in?: Maybe<Int[] | Int>;
  amount_lt?: Maybe<Int>;
  amount_lte?: Maybe<Int>;
  amount_gt?: Maybe<Int>;
  amount_gte?: Maybe<Int>;
  AND?: Maybe<
    ShoppingCartItemScalarWhereInput[] | ShoppingCartItemScalarWhereInput
  >;
  OR?: Maybe<
    ShoppingCartItemScalarWhereInput[] | ShoppingCartItemScalarWhereInput
  >;
  NOT?: Maybe<
    ShoppingCartItemScalarWhereInput[] | ShoppingCartItemScalarWhereInput
  >;
}

export interface ShoppingCartItemUpdateManyWithWhereNestedInput {
  where: ShoppingCartItemScalarWhereInput;
  data: ShoppingCartItemUpdateManyDataInput;
}

export interface ShoppingCartItemUpdateManyDataInput {
  key?: Maybe<String>;
  amount?: Maybe<Int>;
}

export interface ShoppingCartUpsertWithoutCustomerInput {
  update: ShoppingCartUpdateWithoutCustomerDataInput;
  create: ShoppingCartCreateWithoutCustomerInput;
}

export interface UserUpsertWithoutAddressesInput {
  update: UserUpdateWithoutAddressesDataInput;
  create: UserCreateWithoutAddressesInput;
}

export interface AddressUpdateManyMutationInput {
  name?: Maybe<String>;
  Address?: Maybe<String>;
}

export interface CategoryUpdateInput {
  name?: Maybe<String>;
  productItem?: Maybe<ProductItemUpdateManyWithoutCategoryInput>;
  category?: Maybe<CategoryUpdateOneInput>;
}

export interface CategoryUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface InvoiceUpdateInput {
  docId?: Maybe<String>;
  creditTerm?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredInput>;
  quotation?: Maybe<QuotationUpdateOneRequiredInput>;
  salesman?: Maybe<SalesmanUpdateOneRequiredWithoutInvoicesInput>;
  address?: Maybe<AddressUpdateOneWithoutInvoicesInput>;
  payment?: Maybe<PaymentUpdateOneWithoutInvoiceInput>;
}

export interface InvoiceUpdateManyMutationInput {
  docId?: Maybe<String>;
  creditTerm?: Maybe<String>;
}

export interface PaymentCreateInput {
  id?: Maybe<ID_Input>;
  docId: String;
  amount: String;
  customer: UserCreateOneWithoutPaymentsInput;
  salesman?: Maybe<SalesmanCreateOneWithoutPaymentsInput>;
  quotation: QuotationCreateOneWithoutPaymentInput;
  Invoice?: Maybe<InvoiceCreateOneWithoutPaymentInput>;
  rawEvent?: Maybe<String>;
}

export interface PaymentUpdateInput {
  docId?: Maybe<String>;
  amount?: Maybe<String>;
  customer?: Maybe<UserUpdateOneRequiredWithoutPaymentsInput>;
  salesman?: Maybe<SalesmanUpdateOneWithoutPaymentsInput>;
  quotation?: Maybe<QuotationUpdateOneRequiredWithoutPaymentInput>;
  Invoice?: Maybe<InvoiceUpdateOneWithoutPaymentInput>;
  rawEvent?: Maybe<String>;
}

export interface PaymentUpdateManyMutationInput {
  docId?: Maybe<String>;
  amount?: Maybe<String>;
  rawEvent?: Maybe<String>;
}

export interface ProductItemUpdateInput {
  name?: Maybe<String>;
  price?: Maybe<String>;
  salePrice?: Maybe<String>;
  brand?: Maybe<String>;
  unitType?: Maybe<String>;
  description?: Maybe<String>;
  MenuDetail?: Maybe<String>;
  TermDetail?: Maybe<String>;
  amount?: Maybe<Int>;
  isPublished?: Maybe<Boolean>;
  category?: Maybe<CategoryUpdateOneRequiredWithoutProductItemInput>;
  shoppingCart?: Maybe<ShoppingCartUpdateOneInput>;
  quotation?: Maybe<QuotationUpdateOneInput>;
  image?: Maybe<String>;
  relatedProduct?: Maybe<ProductItemUpdateManyInput>;
}

export interface ProductItemUpdateManyMutationInput {
  name?: Maybe<String>;
  price?: Maybe<String>;
  salePrice?: Maybe<String>;
  brand?: Maybe<String>;
  unitType?: Maybe<String>;
  description?: Maybe<String>;
  MenuDetail?: Maybe<String>;
  TermDetail?: Maybe<String>;
  amount?: Maybe<Int>;
  isPublished?: Maybe<Boolean>;
  image?: Maybe<String>;
}

export interface QuotationUpdateInput {
  docId?: Maybe<String>;
  quotationItem?: Maybe<QuotationItemUpdateManyWithoutQuotationInput>;
  salesman?: Maybe<SalesmanUpdateOneWithoutQuotationsInput>;
  payment?: Maybe<PaymentUpdateOneWithoutQuotationInput>;
  shipping?: Maybe<ShippingUpdateOneWithoutQuotationInput>;
  customer?: Maybe<UserUpdateOneRequiredWithoutQuotationsInput>;
  status?: Maybe<String>;
}

export interface QuotationUpdateManyMutationInput {
  docId?: Maybe<String>;
  status?: Maybe<String>;
}

export interface QuotationItemCreateInput {
  id?: Maybe<ID_Input>;
  key: String;
  product: ProductItemCreateOneInput;
  amount: Int;
  realPrice: Float;
  quotation: QuotationCreateOneWithoutQuotationItemInput;
}

export interface QuotationCreateOneWithoutQuotationItemInput {
  create?: Maybe<QuotationCreateWithoutQuotationItemInput>;
  connect?: Maybe<QuotationWhereUniqueInput>;
}

export interface QuotationCreateWithoutQuotationItemInput {
  id?: Maybe<ID_Input>;
  docId?: Maybe<String>;
  salesman?: Maybe<SalesmanCreateOneWithoutQuotationsInput>;
  payment?: Maybe<PaymentCreateOneWithoutQuotationInput>;
  shipping?: Maybe<ShippingCreateOneWithoutQuotationInput>;
  customer: UserCreateOneWithoutQuotationsInput;
  status?: Maybe<String>;
}

export interface QuotationItemUpdateInput {
  key?: Maybe<String>;
  product?: Maybe<ProductItemUpdateOneRequiredInput>;
  amount?: Maybe<Int>;
  realPrice?: Maybe<Float>;
  quotation?: Maybe<QuotationUpdateOneRequiredWithoutQuotationItemInput>;
}

export interface QuotationUpdateOneRequiredWithoutQuotationItemInput {
  create?: Maybe<QuotationCreateWithoutQuotationItemInput>;
  update?: Maybe<QuotationUpdateWithoutQuotationItemDataInput>;
  upsert?: Maybe<QuotationUpsertWithoutQuotationItemInput>;
  connect?: Maybe<QuotationWhereUniqueInput>;
}

export interface QuotationUpdateWithoutQuotationItemDataInput {
  docId?: Maybe<String>;
  salesman?: Maybe<SalesmanUpdateOneWithoutQuotationsInput>;
  payment?: Maybe<PaymentUpdateOneWithoutQuotationInput>;
  shipping?: Maybe<ShippingUpdateOneWithoutQuotationInput>;
  customer?: Maybe<UserUpdateOneRequiredWithoutQuotationsInput>;
  status?: Maybe<String>;
}

export interface QuotationUpsertWithoutQuotationItemInput {
  update: QuotationUpdateWithoutQuotationItemDataInput;
  create: QuotationCreateWithoutQuotationItemInput;
}

export interface QuotationItemUpdateManyMutationInput {
  key?: Maybe<String>;
  amount?: Maybe<Int>;
  realPrice?: Maybe<Float>;
}

export interface SalesmanCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  phone: String;
  payments?: Maybe<PaymentCreateManyWithoutSalesmanInput>;
  invoices?: Maybe<InvoiceCreateManyWithoutSalesmanInput>;
  quotations?: Maybe<QuotationCreateManyWithoutSalesmanInput>;
}

export interface SalesmanUpdateInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  phone?: Maybe<String>;
  payments?: Maybe<PaymentUpdateManyWithoutSalesmanInput>;
  invoices?: Maybe<InvoiceUpdateManyWithoutSalesmanInput>;
  quotations?: Maybe<QuotationUpdateManyWithoutSalesmanInput>;
}

export interface SalesmanUpdateManyMutationInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  phone?: Maybe<String>;
}

export interface ShippingCreateInput {
  id?: Maybe<ID_Input>;
  docId: String;
  dueDate: DateTimeInput;
  status: String;
  invoce: InvoiceCreateOneInput;
  address: AddressCreateOneWithoutShippingInput;
  quotation: QuotationCreateOneWithoutShippingInput;
}

export interface ShippingUpdateInput {
  docId?: Maybe<String>;
  dueDate?: Maybe<DateTimeInput>;
  status?: Maybe<String>;
  invoce?: Maybe<InvoiceUpdateOneRequiredInput>;
  address?: Maybe<AddressUpdateOneRequiredWithoutShippingInput>;
  quotation?: Maybe<QuotationUpdateOneRequiredWithoutShippingInput>;
}

export interface ShippingUpdateManyMutationInput {
  docId?: Maybe<String>;
  dueDate?: Maybe<DateTimeInput>;
  status?: Maybe<String>;
}

export interface ShoppingCartUpdateInput {
  total_cost?: Maybe<Float>;
  productItems?: Maybe<ShoppingCartItemUpdateManyWithoutShoppingCartInput>;
  customer?: Maybe<UserUpdateOneRequiredWithoutShoppingCartInput>;
}

export interface ShoppingCartUpdateManyMutationInput {
  total_cost?: Maybe<Float>;
}

export interface ShoppingCartItemCreateInput {
  id?: Maybe<ID_Input>;
  key: String;
  product: ProductItemCreateOneInput;
  amount: Int;
  ShoppingCart?: Maybe<ShoppingCartCreateOneWithoutProductItemsInput>;
}

export interface ShoppingCartCreateOneWithoutProductItemsInput {
  create?: Maybe<ShoppingCartCreateWithoutProductItemsInput>;
  connect?: Maybe<ShoppingCartWhereUniqueInput>;
}

export interface ShoppingCartCreateWithoutProductItemsInput {
  id?: Maybe<ID_Input>;
  total_cost: Float;
  customer: UserCreateOneWithoutShoppingCartInput;
}

export interface ShoppingCartItemUpdateInput {
  key?: Maybe<String>;
  product?: Maybe<ProductItemUpdateOneRequiredInput>;
  amount?: Maybe<Int>;
  ShoppingCart?: Maybe<ShoppingCartUpdateOneWithoutProductItemsInput>;
}

export interface ShoppingCartUpdateOneWithoutProductItemsInput {
  create?: Maybe<ShoppingCartCreateWithoutProductItemsInput>;
  update?: Maybe<ShoppingCartUpdateWithoutProductItemsDataInput>;
  upsert?: Maybe<ShoppingCartUpsertWithoutProductItemsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ShoppingCartWhereUniqueInput>;
}

export interface ShoppingCartUpdateWithoutProductItemsDataInput {
  total_cost?: Maybe<Float>;
  customer?: Maybe<UserUpdateOneRequiredWithoutShoppingCartInput>;
}

export interface ShoppingCartUpsertWithoutProductItemsInput {
  update: ShoppingCartUpdateWithoutProductItemsDataInput;
  create: ShoppingCartCreateWithoutProductItemsInput;
}

export interface ShoppingCartItemUpdateManyMutationInput {
  key?: Maybe<String>;
  amount?: Maybe<Int>;
}

export interface UserUpdateInput {
  runningId?: Maybe<Int>;
  type?: Maybe<String>;
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  avatar?: Maybe<String>;
  activated?: Maybe<Boolean>;
  shoppingCart?: Maybe<ShoppingCartUpdateOneRequiredWithoutCustomerInput>;
  quotations?: Maybe<QuotationUpdateManyWithoutCustomerInput>;
  payments?: Maybe<PaymentUpdateManyWithoutCustomerInput>;
  addresses?: Maybe<AddressUpdateManyWithoutCustomerInput>;
}

export interface UserUpdateManyMutationInput {
  runningId?: Maybe<Int>;
  type?: Maybe<String>;
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  avatar?: Maybe<String>;
  activated?: Maybe<Boolean>;
}

export interface AddressSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AddressWhereInput>;
  AND?: Maybe<AddressSubscriptionWhereInput[] | AddressSubscriptionWhereInput>;
  OR?: Maybe<AddressSubscriptionWhereInput[] | AddressSubscriptionWhereInput>;
  NOT?: Maybe<AddressSubscriptionWhereInput[] | AddressSubscriptionWhereInput>;
}

export interface CategorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CategoryWhereInput>;
  AND?: Maybe<
    CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput
  >;
  OR?: Maybe<CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput>;
  NOT?: Maybe<
    CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput
  >;
}

export interface InvoiceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<InvoiceWhereInput>;
  AND?: Maybe<InvoiceSubscriptionWhereInput[] | InvoiceSubscriptionWhereInput>;
  OR?: Maybe<InvoiceSubscriptionWhereInput[] | InvoiceSubscriptionWhereInput>;
  NOT?: Maybe<InvoiceSubscriptionWhereInput[] | InvoiceSubscriptionWhereInput>;
}

export interface PaymentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PaymentWhereInput>;
  AND?: Maybe<PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput>;
  OR?: Maybe<PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput>;
  NOT?: Maybe<PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput>;
}

export interface ProductItemSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductItemWhereInput>;
  AND?: Maybe<
    ProductItemSubscriptionWhereInput[] | ProductItemSubscriptionWhereInput
  >;
  OR?: Maybe<
    ProductItemSubscriptionWhereInput[] | ProductItemSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ProductItemSubscriptionWhereInput[] | ProductItemSubscriptionWhereInput
  >;
}

export interface QuotationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<QuotationWhereInput>;
  AND?: Maybe<
    QuotationSubscriptionWhereInput[] | QuotationSubscriptionWhereInput
  >;
  OR?: Maybe<
    QuotationSubscriptionWhereInput[] | QuotationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    QuotationSubscriptionWhereInput[] | QuotationSubscriptionWhereInput
  >;
}

export interface QuotationItemSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<QuotationItemWhereInput>;
  AND?: Maybe<
    QuotationItemSubscriptionWhereInput[] | QuotationItemSubscriptionWhereInput
  >;
  OR?: Maybe<
    QuotationItemSubscriptionWhereInput[] | QuotationItemSubscriptionWhereInput
  >;
  NOT?: Maybe<
    QuotationItemSubscriptionWhereInput[] | QuotationItemSubscriptionWhereInput
  >;
}

export interface SalesmanSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SalesmanWhereInput>;
  AND?: Maybe<
    SalesmanSubscriptionWhereInput[] | SalesmanSubscriptionWhereInput
  >;
  OR?: Maybe<SalesmanSubscriptionWhereInput[] | SalesmanSubscriptionWhereInput>;
  NOT?: Maybe<
    SalesmanSubscriptionWhereInput[] | SalesmanSubscriptionWhereInput
  >;
}

export interface ShippingSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ShippingWhereInput>;
  AND?: Maybe<
    ShippingSubscriptionWhereInput[] | ShippingSubscriptionWhereInput
  >;
  OR?: Maybe<ShippingSubscriptionWhereInput[] | ShippingSubscriptionWhereInput>;
  NOT?: Maybe<
    ShippingSubscriptionWhereInput[] | ShippingSubscriptionWhereInput
  >;
}

export interface ShoppingCartSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ShoppingCartWhereInput>;
  AND?: Maybe<
    ShoppingCartSubscriptionWhereInput[] | ShoppingCartSubscriptionWhereInput
  >;
  OR?: Maybe<
    ShoppingCartSubscriptionWhereInput[] | ShoppingCartSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ShoppingCartSubscriptionWhereInput[] | ShoppingCartSubscriptionWhereInput
  >;
}

export interface ShoppingCartItemSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ShoppingCartItemWhereInput>;
  AND?: Maybe<
    | ShoppingCartItemSubscriptionWhereInput[]
    | ShoppingCartItemSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ShoppingCartItemSubscriptionWhereInput[]
    | ShoppingCartItemSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ShoppingCartItemSubscriptionWhereInput[]
    | ShoppingCartItemSubscriptionWhereInput
  >;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Address {
  id: ID_Output;
  name: String;
  Address: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AddressPromise extends Promise<Address>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  Address: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  customer: <T = UserPromise>() => T;
  invoices: <T = FragmentableArray<Invoice>>(args?: {
    where?: InvoiceWhereInput;
    orderBy?: InvoiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  shipping: <T = FragmentableArray<Shipping>>(args?: {
    where?: ShippingWhereInput;
    orderBy?: ShippingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AddressSubscription
  extends Promise<AsyncIterator<Address>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  Address: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  customer: <T = UserSubscription>() => T;
  invoices: <T = Promise<AsyncIterator<InvoiceSubscription>>>(args?: {
    where?: InvoiceWhereInput;
    orderBy?: InvoiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  shipping: <T = Promise<AsyncIterator<ShippingSubscription>>>(args?: {
    where?: ShippingWhereInput;
    orderBy?: ShippingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AddressNullablePromise
  extends Promise<Address | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  Address: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  customer: <T = UserPromise>() => T;
  invoices: <T = FragmentableArray<Invoice>>(args?: {
    where?: InvoiceWhereInput;
    orderBy?: InvoiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  shipping: <T = FragmentableArray<Shipping>>(args?: {
    where?: ShippingWhereInput;
    orderBy?: ShippingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface User {
  id: ID_Output;
  runningId?: Int;
  type?: String;
  name: String;
  email: String;
  password: String;
  phone: String;
  avatar?: String;
  activated: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  runningId: () => Promise<Int>;
  type: () => Promise<String>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  avatar: () => Promise<String>;
  activated: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  shoppingCart: <T = ShoppingCartPromise>() => T;
  quotations: <T = FragmentableArray<Quotation>>(args?: {
    where?: QuotationWhereInput;
    orderBy?: QuotationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  payments: <T = FragmentableArray<Payment>>(args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  addresses: <T = FragmentableArray<Address>>(args?: {
    where?: AddressWhereInput;
    orderBy?: AddressOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  runningId: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  avatar: () => Promise<AsyncIterator<String>>;
  activated: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  shoppingCart: <T = ShoppingCartSubscription>() => T;
  quotations: <T = Promise<AsyncIterator<QuotationSubscription>>>(args?: {
    where?: QuotationWhereInput;
    orderBy?: QuotationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  payments: <T = Promise<AsyncIterator<PaymentSubscription>>>(args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  addresses: <T = Promise<AsyncIterator<AddressSubscription>>>(args?: {
    where?: AddressWhereInput;
    orderBy?: AddressOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  runningId: () => Promise<Int>;
  type: () => Promise<String>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  avatar: () => Promise<String>;
  activated: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  shoppingCart: <T = ShoppingCartPromise>() => T;
  quotations: <T = FragmentableArray<Quotation>>(args?: {
    where?: QuotationWhereInput;
    orderBy?: QuotationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  payments: <T = FragmentableArray<Payment>>(args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  addresses: <T = FragmentableArray<Address>>(args?: {
    where?: AddressWhereInput;
    orderBy?: AddressOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ShoppingCart {
  id: ID_Output;
  total_cost: Float;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ShoppingCartPromise
  extends Promise<ShoppingCart>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  total_cost: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  productItems: <T = FragmentableArray<ShoppingCartItem>>(args?: {
    where?: ShoppingCartItemWhereInput;
    orderBy?: ShoppingCartItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  customer: <T = UserPromise>() => T;
}

export interface ShoppingCartSubscription
  extends Promise<AsyncIterator<ShoppingCart>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  total_cost: () => Promise<AsyncIterator<Float>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  productItems: <
    T = Promise<AsyncIterator<ShoppingCartItemSubscription>>
  >(args?: {
    where?: ShoppingCartItemWhereInput;
    orderBy?: ShoppingCartItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  customer: <T = UserSubscription>() => T;
}

export interface ShoppingCartNullablePromise
  extends Promise<ShoppingCart | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  total_cost: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  productItems: <T = FragmentableArray<ShoppingCartItem>>(args?: {
    where?: ShoppingCartItemWhereInput;
    orderBy?: ShoppingCartItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  customer: <T = UserPromise>() => T;
}

export interface ShoppingCartItem {
  id: ID_Output;
  key: String;
  amount: Int;
}

export interface ShoppingCartItemPromise
  extends Promise<ShoppingCartItem>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  key: () => Promise<String>;
  product: <T = ProductItemPromise>() => T;
  amount: () => Promise<Int>;
  ShoppingCart: <T = ShoppingCartPromise>() => T;
}

export interface ShoppingCartItemSubscription
  extends Promise<AsyncIterator<ShoppingCartItem>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  key: () => Promise<AsyncIterator<String>>;
  product: <T = ProductItemSubscription>() => T;
  amount: () => Promise<AsyncIterator<Int>>;
  ShoppingCart: <T = ShoppingCartSubscription>() => T;
}

export interface ShoppingCartItemNullablePromise
  extends Promise<ShoppingCartItem | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  key: () => Promise<String>;
  product: <T = ProductItemPromise>() => T;
  amount: () => Promise<Int>;
  ShoppingCart: <T = ShoppingCartPromise>() => T;
}

export interface ProductItem {
  id: ID_Output;
  name: String;
  price: String;
  salePrice: String;
  brand: String;
  unitType: String;
  description?: String;
  MenuDetail: String;
  TermDetail: String;
  amount: Int;
  isPublished: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  image?: String;
}

export interface ProductItemPromise extends Promise<ProductItem>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  price: () => Promise<String>;
  salePrice: () => Promise<String>;
  brand: () => Promise<String>;
  unitType: () => Promise<String>;
  description: () => Promise<String>;
  MenuDetail: () => Promise<String>;
  TermDetail: () => Promise<String>;
  amount: () => Promise<Int>;
  isPublished: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  category: <T = CategoryPromise>() => T;
  shoppingCart: <T = ShoppingCartPromise>() => T;
  quotation: <T = QuotationPromise>() => T;
  image: () => Promise<String>;
  relatedProduct: <T = FragmentableArray<ProductItem>>(args?: {
    where?: ProductItemWhereInput;
    orderBy?: ProductItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProductItemSubscription
  extends Promise<AsyncIterator<ProductItem>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<String>>;
  salePrice: () => Promise<AsyncIterator<String>>;
  brand: () => Promise<AsyncIterator<String>>;
  unitType: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  MenuDetail: () => Promise<AsyncIterator<String>>;
  TermDetail: () => Promise<AsyncIterator<String>>;
  amount: () => Promise<AsyncIterator<Int>>;
  isPublished: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  category: <T = CategorySubscription>() => T;
  shoppingCart: <T = ShoppingCartSubscription>() => T;
  quotation: <T = QuotationSubscription>() => T;
  image: () => Promise<AsyncIterator<String>>;
  relatedProduct: <T = Promise<AsyncIterator<ProductItemSubscription>>>(args?: {
    where?: ProductItemWhereInput;
    orderBy?: ProductItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProductItemNullablePromise
  extends Promise<ProductItem | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  price: () => Promise<String>;
  salePrice: () => Promise<String>;
  brand: () => Promise<String>;
  unitType: () => Promise<String>;
  description: () => Promise<String>;
  MenuDetail: () => Promise<String>;
  TermDetail: () => Promise<String>;
  amount: () => Promise<Int>;
  isPublished: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  category: <T = CategoryPromise>() => T;
  shoppingCart: <T = ShoppingCartPromise>() => T;
  quotation: <T = QuotationPromise>() => T;
  image: () => Promise<String>;
  relatedProduct: <T = FragmentableArray<ProductItem>>(args?: {
    where?: ProductItemWhereInput;
    orderBy?: ProductItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Category {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CategoryPromise extends Promise<Category>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  productItem: <T = FragmentableArray<ProductItem>>(args?: {
    where?: ProductItemWhereInput;
    orderBy?: ProductItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  category: <T = CategoryPromise>() => T;
}

export interface CategorySubscription
  extends Promise<AsyncIterator<Category>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  productItem: <T = Promise<AsyncIterator<ProductItemSubscription>>>(args?: {
    where?: ProductItemWhereInput;
    orderBy?: ProductItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  category: <T = CategorySubscription>() => T;
}

export interface CategoryNullablePromise
  extends Promise<Category | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  productItem: <T = FragmentableArray<ProductItem>>(args?: {
    where?: ProductItemWhereInput;
    orderBy?: ProductItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  category: <T = CategoryPromise>() => T;
}

export interface Quotation {
  id: ID_Output;
  docId?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  status?: String;
}

export interface QuotationPromise extends Promise<Quotation>, Fragmentable {
  id: () => Promise<ID_Output>;
  docId: () => Promise<String>;
  quotationItem: <T = FragmentableArray<QuotationItem>>(args?: {
    where?: QuotationItemWhereInput;
    orderBy?: QuotationItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  salesman: <T = SalesmanPromise>() => T;
  payment: <T = PaymentPromise>() => T;
  shipping: <T = ShippingPromise>() => T;
  customer: <T = UserPromise>() => T;
  status: () => Promise<String>;
}

export interface QuotationSubscription
  extends Promise<AsyncIterator<Quotation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  docId: () => Promise<AsyncIterator<String>>;
  quotationItem: <
    T = Promise<AsyncIterator<QuotationItemSubscription>>
  >(args?: {
    where?: QuotationItemWhereInput;
    orderBy?: QuotationItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  salesman: <T = SalesmanSubscription>() => T;
  payment: <T = PaymentSubscription>() => T;
  shipping: <T = ShippingSubscription>() => T;
  customer: <T = UserSubscription>() => T;
  status: () => Promise<AsyncIterator<String>>;
}

export interface QuotationNullablePromise
  extends Promise<Quotation | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  docId: () => Promise<String>;
  quotationItem: <T = FragmentableArray<QuotationItem>>(args?: {
    where?: QuotationItemWhereInput;
    orderBy?: QuotationItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  salesman: <T = SalesmanPromise>() => T;
  payment: <T = PaymentPromise>() => T;
  shipping: <T = ShippingPromise>() => T;
  customer: <T = UserPromise>() => T;
  status: () => Promise<String>;
}

export interface QuotationItem {
  id: ID_Output;
  key: String;
  amount: Int;
  realPrice: Float;
}

export interface QuotationItemPromise
  extends Promise<QuotationItem>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  key: () => Promise<String>;
  product: <T = ProductItemPromise>() => T;
  amount: () => Promise<Int>;
  realPrice: () => Promise<Float>;
  quotation: <T = QuotationPromise>() => T;
}

export interface QuotationItemSubscription
  extends Promise<AsyncIterator<QuotationItem>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  key: () => Promise<AsyncIterator<String>>;
  product: <T = ProductItemSubscription>() => T;
  amount: () => Promise<AsyncIterator<Int>>;
  realPrice: () => Promise<AsyncIterator<Float>>;
  quotation: <T = QuotationSubscription>() => T;
}

export interface QuotationItemNullablePromise
  extends Promise<QuotationItem | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  key: () => Promise<String>;
  product: <T = ProductItemPromise>() => T;
  amount: () => Promise<Int>;
  realPrice: () => Promise<Float>;
  quotation: <T = QuotationPromise>() => T;
}

export interface Salesman {
  id: ID_Output;
  name: String;
  email: String;
  phone: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SalesmanPromise extends Promise<Salesman>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  phone: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  payments: <T = FragmentableArray<Payment>>(args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  invoices: <T = FragmentableArray<Invoice>>(args?: {
    where?: InvoiceWhereInput;
    orderBy?: InvoiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  quotations: <T = FragmentableArray<Quotation>>(args?: {
    where?: QuotationWhereInput;
    orderBy?: QuotationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface SalesmanSubscription
  extends Promise<AsyncIterator<Salesman>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  payments: <T = Promise<AsyncIterator<PaymentSubscription>>>(args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  invoices: <T = Promise<AsyncIterator<InvoiceSubscription>>>(args?: {
    where?: InvoiceWhereInput;
    orderBy?: InvoiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  quotations: <T = Promise<AsyncIterator<QuotationSubscription>>>(args?: {
    where?: QuotationWhereInput;
    orderBy?: QuotationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface SalesmanNullablePromise
  extends Promise<Salesman | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  phone: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  payments: <T = FragmentableArray<Payment>>(args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  invoices: <T = FragmentableArray<Invoice>>(args?: {
    where?: InvoiceWhereInput;
    orderBy?: InvoiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  quotations: <T = FragmentableArray<Quotation>>(args?: {
    where?: QuotationWhereInput;
    orderBy?: QuotationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Payment {
  id: ID_Output;
  docId: String;
  amount: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  rawEvent?: String;
}

export interface PaymentPromise extends Promise<Payment>, Fragmentable {
  id: () => Promise<ID_Output>;
  docId: () => Promise<String>;
  amount: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  customer: <T = UserPromise>() => T;
  salesman: <T = SalesmanPromise>() => T;
  quotation: <T = QuotationPromise>() => T;
  Invoice: <T = InvoicePromise>() => T;
  rawEvent: () => Promise<String>;
}

export interface PaymentSubscription
  extends Promise<AsyncIterator<Payment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  docId: () => Promise<AsyncIterator<String>>;
  amount: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  customer: <T = UserSubscription>() => T;
  salesman: <T = SalesmanSubscription>() => T;
  quotation: <T = QuotationSubscription>() => T;
  Invoice: <T = InvoiceSubscription>() => T;
  rawEvent: () => Promise<AsyncIterator<String>>;
}

export interface PaymentNullablePromise
  extends Promise<Payment | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  docId: () => Promise<String>;
  amount: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  customer: <T = UserPromise>() => T;
  salesman: <T = SalesmanPromise>() => T;
  quotation: <T = QuotationPromise>() => T;
  Invoice: <T = InvoicePromise>() => T;
  rawEvent: () => Promise<String>;
}

export interface Invoice {
  id: ID_Output;
  docId: String;
  creditTerm: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface InvoicePromise extends Promise<Invoice>, Fragmentable {
  id: () => Promise<ID_Output>;
  docId: () => Promise<String>;
  creditTerm: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  quotation: <T = QuotationPromise>() => T;
  salesman: <T = SalesmanPromise>() => T;
  address: <T = AddressPromise>() => T;
  payment: <T = PaymentPromise>() => T;
}

export interface InvoiceSubscription
  extends Promise<AsyncIterator<Invoice>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  docId: () => Promise<AsyncIterator<String>>;
  creditTerm: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  user: <T = UserSubscription>() => T;
  quotation: <T = QuotationSubscription>() => T;
  salesman: <T = SalesmanSubscription>() => T;
  address: <T = AddressSubscription>() => T;
  payment: <T = PaymentSubscription>() => T;
}

export interface InvoiceNullablePromise
  extends Promise<Invoice | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  docId: () => Promise<String>;
  creditTerm: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  quotation: <T = QuotationPromise>() => T;
  salesman: <T = SalesmanPromise>() => T;
  address: <T = AddressPromise>() => T;
  payment: <T = PaymentPromise>() => T;
}

export interface Shipping {
  id: ID_Output;
  docId: String;
  dueDate: DateTimeOutput;
  status: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ShippingPromise extends Promise<Shipping>, Fragmentable {
  id: () => Promise<ID_Output>;
  docId: () => Promise<String>;
  dueDate: () => Promise<DateTimeOutput>;
  status: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  invoce: <T = InvoicePromise>() => T;
  address: <T = AddressPromise>() => T;
  quotation: <T = QuotationPromise>() => T;
}

export interface ShippingSubscription
  extends Promise<AsyncIterator<Shipping>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  docId: () => Promise<AsyncIterator<String>>;
  dueDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  invoce: <T = InvoiceSubscription>() => T;
  address: <T = AddressSubscription>() => T;
  quotation: <T = QuotationSubscription>() => T;
}

export interface ShippingNullablePromise
  extends Promise<Shipping | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  docId: () => Promise<String>;
  dueDate: () => Promise<DateTimeOutput>;
  status: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  invoce: <T = InvoicePromise>() => T;
  address: <T = AddressPromise>() => T;
  quotation: <T = QuotationPromise>() => T;
}

export interface AddressConnection {
  pageInfo: PageInfo;
  edges: AddressEdge[];
}

export interface AddressConnectionPromise
  extends Promise<AddressConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AddressEdge>>() => T;
  aggregate: <T = AggregateAddressPromise>() => T;
}

export interface AddressConnectionSubscription
  extends Promise<AsyncIterator<AddressConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AddressEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAddressSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AddressEdge {
  node: Address;
  cursor: String;
}

export interface AddressEdgePromise extends Promise<AddressEdge>, Fragmentable {
  node: <T = AddressPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AddressEdgeSubscription
  extends Promise<AsyncIterator<AddressEdge>>,
    Fragmentable {
  node: <T = AddressSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAddress {
  count: Int;
}

export interface AggregateAddressPromise
  extends Promise<AggregateAddress>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAddressSubscription
  extends Promise<AsyncIterator<AggregateAddress>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CategoryConnection {
  pageInfo: PageInfo;
  edges: CategoryEdge[];
}

export interface CategoryConnectionPromise
  extends Promise<CategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CategoryEdge>>() => T;
  aggregate: <T = AggregateCategoryPromise>() => T;
}

export interface CategoryConnectionSubscription
  extends Promise<AsyncIterator<CategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCategorySubscription>() => T;
}

export interface CategoryEdge {
  node: Category;
  cursor: String;
}

export interface CategoryEdgePromise
  extends Promise<CategoryEdge>,
    Fragmentable {
  node: <T = CategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CategoryEdgeSubscription
  extends Promise<AsyncIterator<CategoryEdge>>,
    Fragmentable {
  node: <T = CategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCategory {
  count: Int;
}

export interface AggregateCategoryPromise
  extends Promise<AggregateCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCategorySubscription
  extends Promise<AsyncIterator<AggregateCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface InvoiceConnection {
  pageInfo: PageInfo;
  edges: InvoiceEdge[];
}

export interface InvoiceConnectionPromise
  extends Promise<InvoiceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InvoiceEdge>>() => T;
  aggregate: <T = AggregateInvoicePromise>() => T;
}

export interface InvoiceConnectionSubscription
  extends Promise<AsyncIterator<InvoiceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InvoiceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInvoiceSubscription>() => T;
}

export interface InvoiceEdge {
  node: Invoice;
  cursor: String;
}

export interface InvoiceEdgePromise extends Promise<InvoiceEdge>, Fragmentable {
  node: <T = InvoicePromise>() => T;
  cursor: () => Promise<String>;
}

export interface InvoiceEdgeSubscription
  extends Promise<AsyncIterator<InvoiceEdge>>,
    Fragmentable {
  node: <T = InvoiceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateInvoice {
  count: Int;
}

export interface AggregateInvoicePromise
  extends Promise<AggregateInvoice>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInvoiceSubscription
  extends Promise<AsyncIterator<AggregateInvoice>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PaymentConnection {
  pageInfo: PageInfo;
  edges: PaymentEdge[];
}

export interface PaymentConnectionPromise
  extends Promise<PaymentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PaymentEdge>>() => T;
  aggregate: <T = AggregatePaymentPromise>() => T;
}

export interface PaymentConnectionSubscription
  extends Promise<AsyncIterator<PaymentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PaymentEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePaymentSubscription>() => T;
}

export interface PaymentEdge {
  node: Payment;
  cursor: String;
}

export interface PaymentEdgePromise extends Promise<PaymentEdge>, Fragmentable {
  node: <T = PaymentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PaymentEdgeSubscription
  extends Promise<AsyncIterator<PaymentEdge>>,
    Fragmentable {
  node: <T = PaymentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePayment {
  count: Int;
}

export interface AggregatePaymentPromise
  extends Promise<AggregatePayment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePaymentSubscription
  extends Promise<AsyncIterator<AggregatePayment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductItemConnection {
  pageInfo: PageInfo;
  edges: ProductItemEdge[];
}

export interface ProductItemConnectionPromise
  extends Promise<ProductItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductItemEdge>>() => T;
  aggregate: <T = AggregateProductItemPromise>() => T;
}

export interface ProductItemConnectionSubscription
  extends Promise<AsyncIterator<ProductItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductItemSubscription>() => T;
}

export interface ProductItemEdge {
  node: ProductItem;
  cursor: String;
}

export interface ProductItemEdgePromise
  extends Promise<ProductItemEdge>,
    Fragmentable {
  node: <T = ProductItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductItemEdgeSubscription
  extends Promise<AsyncIterator<ProductItemEdge>>,
    Fragmentable {
  node: <T = ProductItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProductItem {
  count: Int;
}

export interface AggregateProductItemPromise
  extends Promise<AggregateProductItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductItemSubscription
  extends Promise<AsyncIterator<AggregateProductItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface QuotationConnection {
  pageInfo: PageInfo;
  edges: QuotationEdge[];
}

export interface QuotationConnectionPromise
  extends Promise<QuotationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QuotationEdge>>() => T;
  aggregate: <T = AggregateQuotationPromise>() => T;
}

export interface QuotationConnectionSubscription
  extends Promise<AsyncIterator<QuotationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<QuotationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateQuotationSubscription>() => T;
}

export interface QuotationEdge {
  node: Quotation;
  cursor: String;
}

export interface QuotationEdgePromise
  extends Promise<QuotationEdge>,
    Fragmentable {
  node: <T = QuotationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface QuotationEdgeSubscription
  extends Promise<AsyncIterator<QuotationEdge>>,
    Fragmentable {
  node: <T = QuotationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateQuotation {
  count: Int;
}

export interface AggregateQuotationPromise
  extends Promise<AggregateQuotation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQuotationSubscription
  extends Promise<AsyncIterator<AggregateQuotation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface QuotationItemConnection {
  pageInfo: PageInfo;
  edges: QuotationItemEdge[];
}

export interface QuotationItemConnectionPromise
  extends Promise<QuotationItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QuotationItemEdge>>() => T;
  aggregate: <T = AggregateQuotationItemPromise>() => T;
}

export interface QuotationItemConnectionSubscription
  extends Promise<AsyncIterator<QuotationItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<QuotationItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateQuotationItemSubscription>() => T;
}

export interface QuotationItemEdge {
  node: QuotationItem;
  cursor: String;
}

export interface QuotationItemEdgePromise
  extends Promise<QuotationItemEdge>,
    Fragmentable {
  node: <T = QuotationItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface QuotationItemEdgeSubscription
  extends Promise<AsyncIterator<QuotationItemEdge>>,
    Fragmentable {
  node: <T = QuotationItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateQuotationItem {
  count: Int;
}

export interface AggregateQuotationItemPromise
  extends Promise<AggregateQuotationItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQuotationItemSubscription
  extends Promise<AsyncIterator<AggregateQuotationItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SalesmanConnection {
  pageInfo: PageInfo;
  edges: SalesmanEdge[];
}

export interface SalesmanConnectionPromise
  extends Promise<SalesmanConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SalesmanEdge>>() => T;
  aggregate: <T = AggregateSalesmanPromise>() => T;
}

export interface SalesmanConnectionSubscription
  extends Promise<AsyncIterator<SalesmanConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SalesmanEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSalesmanSubscription>() => T;
}

export interface SalesmanEdge {
  node: Salesman;
  cursor: String;
}

export interface SalesmanEdgePromise
  extends Promise<SalesmanEdge>,
    Fragmentable {
  node: <T = SalesmanPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SalesmanEdgeSubscription
  extends Promise<AsyncIterator<SalesmanEdge>>,
    Fragmentable {
  node: <T = SalesmanSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSalesman {
  count: Int;
}

export interface AggregateSalesmanPromise
  extends Promise<AggregateSalesman>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSalesmanSubscription
  extends Promise<AsyncIterator<AggregateSalesman>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ShippingConnection {
  pageInfo: PageInfo;
  edges: ShippingEdge[];
}

export interface ShippingConnectionPromise
  extends Promise<ShippingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ShippingEdge>>() => T;
  aggregate: <T = AggregateShippingPromise>() => T;
}

export interface ShippingConnectionSubscription
  extends Promise<AsyncIterator<ShippingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ShippingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateShippingSubscription>() => T;
}

export interface ShippingEdge {
  node: Shipping;
  cursor: String;
}

export interface ShippingEdgePromise
  extends Promise<ShippingEdge>,
    Fragmentable {
  node: <T = ShippingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ShippingEdgeSubscription
  extends Promise<AsyncIterator<ShippingEdge>>,
    Fragmentable {
  node: <T = ShippingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateShipping {
  count: Int;
}

export interface AggregateShippingPromise
  extends Promise<AggregateShipping>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateShippingSubscription
  extends Promise<AsyncIterator<AggregateShipping>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ShoppingCartConnection {
  pageInfo: PageInfo;
  edges: ShoppingCartEdge[];
}

export interface ShoppingCartConnectionPromise
  extends Promise<ShoppingCartConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ShoppingCartEdge>>() => T;
  aggregate: <T = AggregateShoppingCartPromise>() => T;
}

export interface ShoppingCartConnectionSubscription
  extends Promise<AsyncIterator<ShoppingCartConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ShoppingCartEdgeSubscription>>>() => T;
  aggregate: <T = AggregateShoppingCartSubscription>() => T;
}

export interface ShoppingCartEdge {
  node: ShoppingCart;
  cursor: String;
}

export interface ShoppingCartEdgePromise
  extends Promise<ShoppingCartEdge>,
    Fragmentable {
  node: <T = ShoppingCartPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ShoppingCartEdgeSubscription
  extends Promise<AsyncIterator<ShoppingCartEdge>>,
    Fragmentable {
  node: <T = ShoppingCartSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateShoppingCart {
  count: Int;
}

export interface AggregateShoppingCartPromise
  extends Promise<AggregateShoppingCart>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateShoppingCartSubscription
  extends Promise<AsyncIterator<AggregateShoppingCart>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ShoppingCartItemConnection {
  pageInfo: PageInfo;
  edges: ShoppingCartItemEdge[];
}

export interface ShoppingCartItemConnectionPromise
  extends Promise<ShoppingCartItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ShoppingCartItemEdge>>() => T;
  aggregate: <T = AggregateShoppingCartItemPromise>() => T;
}

export interface ShoppingCartItemConnectionSubscription
  extends Promise<AsyncIterator<ShoppingCartItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ShoppingCartItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateShoppingCartItemSubscription>() => T;
}

export interface ShoppingCartItemEdge {
  node: ShoppingCartItem;
  cursor: String;
}

export interface ShoppingCartItemEdgePromise
  extends Promise<ShoppingCartItemEdge>,
    Fragmentable {
  node: <T = ShoppingCartItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ShoppingCartItemEdgeSubscription
  extends Promise<AsyncIterator<ShoppingCartItemEdge>>,
    Fragmentable {
  node: <T = ShoppingCartItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateShoppingCartItem {
  count: Int;
}

export interface AggregateShoppingCartItemPromise
  extends Promise<AggregateShoppingCartItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateShoppingCartItemSubscription
  extends Promise<AsyncIterator<AggregateShoppingCartItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AddressSubscriptionPayload {
  mutation: MutationType;
  node: Address;
  updatedFields: String[];
  previousValues: AddressPreviousValues;
}

export interface AddressSubscriptionPayloadPromise
  extends Promise<AddressSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AddressPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AddressPreviousValuesPromise>() => T;
}

export interface AddressSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AddressSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AddressSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AddressPreviousValuesSubscription>() => T;
}

export interface AddressPreviousValues {
  id: ID_Output;
  name: String;
  Address: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AddressPreviousValuesPromise
  extends Promise<AddressPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  Address: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AddressPreviousValuesSubscription
  extends Promise<AsyncIterator<AddressPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  Address: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CategorySubscriptionPayload {
  mutation: MutationType;
  node: Category;
  updatedFields: String[];
  previousValues: CategoryPreviousValues;
}

export interface CategorySubscriptionPayloadPromise
  extends Promise<CategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CategoryPreviousValuesPromise>() => T;
}

export interface CategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CategoryPreviousValuesSubscription>() => T;
}

export interface CategoryPreviousValues {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CategoryPreviousValuesPromise
  extends Promise<CategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<CategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InvoiceSubscriptionPayload {
  mutation: MutationType;
  node: Invoice;
  updatedFields: String[];
  previousValues: InvoicePreviousValues;
}

export interface InvoiceSubscriptionPayloadPromise
  extends Promise<InvoiceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InvoicePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InvoicePreviousValuesPromise>() => T;
}

export interface InvoiceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InvoiceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InvoiceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InvoicePreviousValuesSubscription>() => T;
}

export interface InvoicePreviousValues {
  id: ID_Output;
  docId: String;
  creditTerm: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface InvoicePreviousValuesPromise
  extends Promise<InvoicePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  docId: () => Promise<String>;
  creditTerm: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface InvoicePreviousValuesSubscription
  extends Promise<AsyncIterator<InvoicePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  docId: () => Promise<AsyncIterator<String>>;
  creditTerm: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PaymentSubscriptionPayload {
  mutation: MutationType;
  node: Payment;
  updatedFields: String[];
  previousValues: PaymentPreviousValues;
}

export interface PaymentSubscriptionPayloadPromise
  extends Promise<PaymentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PaymentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PaymentPreviousValuesPromise>() => T;
}

export interface PaymentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PaymentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PaymentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PaymentPreviousValuesSubscription>() => T;
}

export interface PaymentPreviousValues {
  id: ID_Output;
  docId: String;
  amount: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  rawEvent?: String;
}

export interface PaymentPreviousValuesPromise
  extends Promise<PaymentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  docId: () => Promise<String>;
  amount: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  rawEvent: () => Promise<String>;
}

export interface PaymentPreviousValuesSubscription
  extends Promise<AsyncIterator<PaymentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  docId: () => Promise<AsyncIterator<String>>;
  amount: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  rawEvent: () => Promise<AsyncIterator<String>>;
}

export interface ProductItemSubscriptionPayload {
  mutation: MutationType;
  node: ProductItem;
  updatedFields: String[];
  previousValues: ProductItemPreviousValues;
}

export interface ProductItemSubscriptionPayloadPromise
  extends Promise<ProductItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductItemPreviousValuesPromise>() => T;
}

export interface ProductItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductItemPreviousValuesSubscription>() => T;
}

export interface ProductItemPreviousValues {
  id: ID_Output;
  name: String;
  price: String;
  salePrice: String;
  brand: String;
  unitType: String;
  description?: String;
  MenuDetail: String;
  TermDetail: String;
  amount: Int;
  isPublished: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  image?: String;
}

export interface ProductItemPreviousValuesPromise
  extends Promise<ProductItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  price: () => Promise<String>;
  salePrice: () => Promise<String>;
  brand: () => Promise<String>;
  unitType: () => Promise<String>;
  description: () => Promise<String>;
  MenuDetail: () => Promise<String>;
  TermDetail: () => Promise<String>;
  amount: () => Promise<Int>;
  isPublished: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  image: () => Promise<String>;
}

export interface ProductItemPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<String>>;
  salePrice: () => Promise<AsyncIterator<String>>;
  brand: () => Promise<AsyncIterator<String>>;
  unitType: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  MenuDetail: () => Promise<AsyncIterator<String>>;
  TermDetail: () => Promise<AsyncIterator<String>>;
  amount: () => Promise<AsyncIterator<Int>>;
  isPublished: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  image: () => Promise<AsyncIterator<String>>;
}

export interface QuotationSubscriptionPayload {
  mutation: MutationType;
  node: Quotation;
  updatedFields: String[];
  previousValues: QuotationPreviousValues;
}

export interface QuotationSubscriptionPayloadPromise
  extends Promise<QuotationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QuotationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QuotationPreviousValuesPromise>() => T;
}

export interface QuotationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QuotationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QuotationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QuotationPreviousValuesSubscription>() => T;
}

export interface QuotationPreviousValues {
  id: ID_Output;
  docId?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  status?: String;
}

export interface QuotationPreviousValuesPromise
  extends Promise<QuotationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  docId: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  status: () => Promise<String>;
}

export interface QuotationPreviousValuesSubscription
  extends Promise<AsyncIterator<QuotationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  docId: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<String>>;
}

export interface QuotationItemSubscriptionPayload {
  mutation: MutationType;
  node: QuotationItem;
  updatedFields: String[];
  previousValues: QuotationItemPreviousValues;
}

export interface QuotationItemSubscriptionPayloadPromise
  extends Promise<QuotationItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QuotationItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QuotationItemPreviousValuesPromise>() => T;
}

export interface QuotationItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QuotationItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QuotationItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QuotationItemPreviousValuesSubscription>() => T;
}

export interface QuotationItemPreviousValues {
  id: ID_Output;
  key: String;
  amount: Int;
  realPrice: Float;
}

export interface QuotationItemPreviousValuesPromise
  extends Promise<QuotationItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  key: () => Promise<String>;
  amount: () => Promise<Int>;
  realPrice: () => Promise<Float>;
}

export interface QuotationItemPreviousValuesSubscription
  extends Promise<AsyncIterator<QuotationItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  key: () => Promise<AsyncIterator<String>>;
  amount: () => Promise<AsyncIterator<Int>>;
  realPrice: () => Promise<AsyncIterator<Float>>;
}

export interface SalesmanSubscriptionPayload {
  mutation: MutationType;
  node: Salesman;
  updatedFields: String[];
  previousValues: SalesmanPreviousValues;
}

export interface SalesmanSubscriptionPayloadPromise
  extends Promise<SalesmanSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SalesmanPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SalesmanPreviousValuesPromise>() => T;
}

export interface SalesmanSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SalesmanSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SalesmanSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SalesmanPreviousValuesSubscription>() => T;
}

export interface SalesmanPreviousValues {
  id: ID_Output;
  name: String;
  email: String;
  phone: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SalesmanPreviousValuesPromise
  extends Promise<SalesmanPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  phone: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SalesmanPreviousValuesSubscription
  extends Promise<AsyncIterator<SalesmanPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ShippingSubscriptionPayload {
  mutation: MutationType;
  node: Shipping;
  updatedFields: String[];
  previousValues: ShippingPreviousValues;
}

export interface ShippingSubscriptionPayloadPromise
  extends Promise<ShippingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ShippingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ShippingPreviousValuesPromise>() => T;
}

export interface ShippingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ShippingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ShippingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ShippingPreviousValuesSubscription>() => T;
}

export interface ShippingPreviousValues {
  id: ID_Output;
  docId: String;
  dueDate: DateTimeOutput;
  status: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ShippingPreviousValuesPromise
  extends Promise<ShippingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  docId: () => Promise<String>;
  dueDate: () => Promise<DateTimeOutput>;
  status: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ShippingPreviousValuesSubscription
  extends Promise<AsyncIterator<ShippingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  docId: () => Promise<AsyncIterator<String>>;
  dueDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ShoppingCartSubscriptionPayload {
  mutation: MutationType;
  node: ShoppingCart;
  updatedFields: String[];
  previousValues: ShoppingCartPreviousValues;
}

export interface ShoppingCartSubscriptionPayloadPromise
  extends Promise<ShoppingCartSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ShoppingCartPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ShoppingCartPreviousValuesPromise>() => T;
}

export interface ShoppingCartSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ShoppingCartSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ShoppingCartSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ShoppingCartPreviousValuesSubscription>() => T;
}

export interface ShoppingCartPreviousValues {
  id: ID_Output;
  total_cost: Float;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ShoppingCartPreviousValuesPromise
  extends Promise<ShoppingCartPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  total_cost: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ShoppingCartPreviousValuesSubscription
  extends Promise<AsyncIterator<ShoppingCartPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  total_cost: () => Promise<AsyncIterator<Float>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ShoppingCartItemSubscriptionPayload {
  mutation: MutationType;
  node: ShoppingCartItem;
  updatedFields: String[];
  previousValues: ShoppingCartItemPreviousValues;
}

export interface ShoppingCartItemSubscriptionPayloadPromise
  extends Promise<ShoppingCartItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ShoppingCartItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ShoppingCartItemPreviousValuesPromise>() => T;
}

export interface ShoppingCartItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ShoppingCartItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ShoppingCartItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ShoppingCartItemPreviousValuesSubscription>() => T;
}

export interface ShoppingCartItemPreviousValues {
  id: ID_Output;
  key: String;
  amount: Int;
}

export interface ShoppingCartItemPreviousValuesPromise
  extends Promise<ShoppingCartItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  key: () => Promise<String>;
  amount: () => Promise<Int>;
}

export interface ShoppingCartItemPreviousValuesSubscription
  extends Promise<AsyncIterator<ShoppingCartItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  key: () => Promise<AsyncIterator<String>>;
  amount: () => Promise<AsyncIterator<Int>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  runningId?: Int;
  type?: String;
  name: String;
  email: String;
  password: String;
  phone: String;
  avatar?: String;
  activated: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  runningId: () => Promise<Int>;
  type: () => Promise<String>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  avatar: () => Promise<String>;
  activated: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  runningId: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  avatar: () => Promise<AsyncIterator<String>>;
  activated: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Address",
    embedded: false
  },
  {
    name: "Payment",
    embedded: false
  },
  {
    name: "Salesman",
    embedded: false
  },
  {
    name: "Invoice",
    embedded: false
  },
  {
    name: "Shipping",
    embedded: false
  },
  {
    name: "Category",
    embedded: false
  },
  {
    name: "ProductItem",
    embedded: false
  },
  {
    name: "ShoppingCartItem",
    embedded: false
  },
  {
    name: "ShoppingCart",
    embedded: false
  },
  {
    name: "QuotationItem",
    embedded: false
  },
  {
    name: "Quotation",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `https://eu1.prisma.sh/mrearth25-5430b1/gypstore-prisma/dev`
});
export const prisma = new Prisma();
